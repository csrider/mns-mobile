/*************************************************************
 * Module:	smcgi_favorites
 *
 * Author:	Chris Rider		chris.rider@messagenetsystems.com	csrider@gmail.com
 *
 * General Notes:
 * 	- This module is responsible for the Favorite messages program - whether on PC or mobile device. It works alongside smcgi.
 * 	- A "favorite" is just a special type (BBT_FAVORITES) of message that has basic data about a message-template (it's like a "pointer" to a "real" message).
 * 	- A favorite is keyed by (key#2):
 * 		db_bann->res_id			(the usual standard field)
 * 		db_bann->dbb_pin		(the user to get favorites for)
 * 		db_bann->dbb_msg_type_cod	(the message type, BBT_FAVORITES)
 * 		db_bann->dbb_read_flag		(not sure, but necessary as part of key#2)
 * 	- A favorite message re-purposes many normal message fields for its own special use:
 * 		db_bann->dbb_directory		--> message template directory location		(the directory of the message that this favorite-message points to)
 * 		db_bann->dbb_msg_name		--> message template name			(the message that this favorite-message points to)
 * 		db_bann->dbb_rec_dtsec		--> customizable favorite-icon position		(encoded string that indicates the "message"'s location in the list / grid, as well as type of favorite -- see smcgi_favorites.h for explanation)
 * 		db_bann->dbb_msg_1		--> customized label for the favorite icon 1	(favorite message's main label)  (at last check, the max characters would be 69 ... 70 counting the null-character) (defined by MSGLINE_LENGTH in local.h)
 * 		db_bann->dbb_msg_2		--> customized label for the favorite icon 2	(favorite message's description)  (at last check, the max characters would be 69 ... 70 counting the null-character) (defined by MSGLINE_LENGTH in local.h)
 * 		db_bann->dbb_msg_3		--> customized icon for this favorite message	(favorite message's icon filename)  (at last check, the max characters would be 69 ... 70 counting the null-character) (defined by MSGLINE_LENGTH in local.h)
 * 		db_bann->dbb_msg_4		--> (RESERVED: second icon?)			(favorite message's icon filename #2)  (at last check, the max characters would be 69 ... 70 counting the null-character) (defined by MSGLINE_LENGTH in local.h)
 * 		db_bann->dbb_msg_5		--> active copies for toggle			(list of active copies of the message - used for knowing which ones to display toggle for)  (at last check, the max characters would be 69 ... 70 counting the null-character) (defined by MSGLINE_LENGTH in local.h)
 * 		db_bann->dbb_description	--> reusing for the same purpose		(just a verbatim copy of the message template's description, so we can get it easily if no favorite description is used or something)
 * 		db_bann->dbb_dtsec		--> timestamp for keeping track of changes	(probably should use mostly for explicit changes by the user to a particular favorite? - flexible?)
 * 	- This module primarily provides a JavaScript program to the client - and is thus vastly different than the usual smcgi program.
 * 	- There is a lot of printf usage, but it's desirable instead of using external JS files since there are many places we require interfacing with smcgi, dynamic content, bringing in #define values, server-logging, etc.
 *
 * JavaScript Development Notes for any/all Developers:
 * 	- JavaScript variables are not typed... a "var" can contain any type of data, at any time, merely by storing that data in it. In other words, they are implicitly typed.
 * 	- JavaScript function arguments are (mostly) "passed-by-value" -- meaning that, if you pass some variable to a function, that function will mostly leave the larger-scope value alone, modifying it locally in the function's scope (unless you explicitly save a global or return it, of course).
 * 	- JavaScript function arguments (only objects, though) can be "passed-by-reference" *IF* the function changes the passed object's internals in a special way -- say, by calling a ".sort()" method on a recordset object that was passed to it, for example.
 * 	- We primarily try to use the YUI framework, to provide advanced cross-browser abilities; but it's usually alright to use "native" JavaScript & DOM calls, as long as it's kept pretty basic (for cross-browser compatible reasons). IE is the main problem here, since it has used its own "JScript."
 * 	  One method or dot-notation operation that works in one browser, may not work in another. TEST THOROUGHLY IF YOU DO THIS!
 * 	  	NOTE: As of September 2014, Yahoo announced that they would cease further development of YUI. Try to use native JavaScript wherever possible. If absolutely necessary to use a framework, consider dojo, or possibly jquery? Dojo may be more similar to YUI?
 * 	- If you are in a situation where an array looks attractive, you may want to consider whether an array or an "object-literal" is more appropriate.
 * 	- This is a large and complex application that MUST STAY FAST AND RESPONSIVE! So stay cognizant of efficient design... be mindful of proper scope, avoid unnecessary memory usage and CPU cycles, etc...
 *
 * Major Milestones/Revisions/Notes:
 * 	2013.08 - 2014.03	Prototyping, creation, proof-of-concept & initial development
 * 	2014.03 - 08		Alpha version (internal company testing / further development and refinement)
 * 	2014.06.27		Mobile app publish: Apple App-Store version 1.0 (proof-of-concept for loading favorites in a native app's UIWebView instance)
 * 	2014.07.30		Mobile app updated: Apple app-store version 1.1 (mainly design tweaks and bug fixes)
 * 	2014.08.13		Mobile app updated: Apple app-store version 1.2 (mainly automatic login capability and http-layer tweaks)
 * 	2014.08.30		Mobile app updated: Apple app-store version 1.4 (added native screen to assist with server setup, fixed some scroll bouncing, tweaked connectivity testing and error reporting)
 * 	2014.08.28		Upgraded to "Beta" version
 * 	2014.09.01		Yahoo announced to cease YUI development... I decided to no longer focus on YUI stuff (with the exception of existing core functionality - e.g. recordset, IO, etc.), and rely on native JavaScript wherever possible
 * 	2014.09.xx		Mobile app udpated: Apple app-store version 1.5 (fixed scroll bounce) --Rob didn't submit it correctly, so it never went live
 * 	2014.10.09		Mobile app updated: Apple app-store version 1.6 (added native-app geolocation acquisition, ability to reload uiwebview document whenever it requests, explicitly configured to parse textual phone numbers, etc.)
 * 	2014.10.22		Beta release: Mississippi School for the Deaf (v0.15.1-beta)
 * 	2014.10 - 11	Added ability to show and work with inbox messages (v0.16+)
 * 	2014.11.21		Mobile app updated: Apple app-store version 1.7 (better handles 404 responses, check for server availability on foreground focus, revised JS/ObjC bridge, suppressed geolocation error message)
 * 	(multiple updates including mobile app updates)
 * 	2015.?? 		Go-to-market
 *
*************************************************************/


/* CODE TEMPLATES... */
/************************************************************
 ---[HTTP ASYNC TRANSACTION USING YUI-IO]---
printf("function DOTXN(){");
printf("	YUI().use(\"io\", \"io-base\", function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("			FavScreen.log('log',\"DOTXN(): YUI-IO Txn ID#\"+ioId+\" starting.\",false);");
printf("		};");
printf("		var handleSuccess = function(ioId, o){");						//what should happen when response HTTP status resolves to 2xx
printf("			FavScreen.log('log',\"DOTXN(): YUI-IO Txn ID#\"+ioId+\" succeeded.\",false);");
printf("			var rt = o.responseText;");
//	DO ANY EXTRA PROCESSING OF RESPONSE HERE
printf("		};");
printf("		var handleFailure = function(ioId, o){");						//what should happen when response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('warn',\"DOTXN(): YUI-IO Txn ID#\"+ioId+\" failed or timed-out.\",false);");
printf("			var rt = o.responseText;");
printf("			FavScreen.log('log',\"Txn ID#\"+ioId+\"'s responseText returned by server = '\"+rt+\"'\",false);");
printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("		};");
printf("		var handleEnd = function(ioId, o){");							//what should happen when YUI-IO transaction is finished
printf("			FavScreen.log('log',\"DOTXN(): YUI-IO Txn ID#\"+ioId+\" finished.\",false);");
printf("		};");
printf("		var cfg ={");										//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");							//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");								//subscribe the above custom end handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
printf("				'COMMAND':'true',");							//smcgi command flag
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP()");
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:false,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:20000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("		};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");								//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("	});");
printf("}");//end function DOTXN()
-------------------------------------------------------------
 ---[HTTP SYNC TRANSACTION USING YUI-IO, WITH RETURN]---
printf("function DOTXN(){");
printf("	var result = undefined;");
printf("	YUI().use(\"io\", \"io-base\", function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("			FavScreen.log('log',\"DOTXN(): YUI-IO Txn ID#\"+ioId+\" starting.\",false);");
printf("		};");
printf("		var handleSuccess = function(ioId, o){");						//what should happen when response HTTP status resolves to 2xx
printf("			FavScreen.log('log',\"DOTXN(): YUI-IO Txn ID#\"+ioId+\" succeeded.\",false);");
printf("			var rt = o.responseText;");
//	DO ANY EXTRA PROCESSING OF RESPONSE HERE
printf("		};");
printf("		var handleFailure = function(ioId, o){");						//what should happen when response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('warn',\"DOTXN(): YUI-IO Txn ID#\"+ioId+\" failed or timed-out.\",false);");
printf("			var rt = o.responseText;");
printf("			FavScreen.log('log',\"Txn ID#\"+ioId+\"'s responseText returned by server = '\"+rt+\"'\",false);");
printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("			result = rt;");
printf("		};");
printf("		var handleEnd = function(ioId, o){");							//what should happen when YUI-IO transaction is finished
printf("			FavScreen.log('log',\"DOTXN(): YUI-IO Txn ID#\"+ioId+\" finished.\",false);");
printf("		};");
printf("		var cfg ={");										//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");							//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");								//subscribe the above custom end handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
printf("				'COMMAND':'true',");							//smcgi command flag
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP()");
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:false,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:10000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("		};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");								//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("	});");
printf("	return result;");
printf("}");//end function DOTXN()

*************************************************************/


#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <netdb.h>
#include <time.h>
#include <arpa/inet.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <fnmatch.h>

/***** REDACTED *****/

#include "smcgi_favorites.h"
#include "smcgi_yui.h"


#define HTML_OUTPUT_BUFFER	(1*1024*1024)	/* 1 MB */
#define MAX_BUFFER		    (3*1024*1024)	/* 3 MEG input buffer */


int main_favorites_window_width = 410;
int main_favorites_window_height = 700;


/***********************************************************************
* Add various support and helper functions
***********************************************************************/

// Add the client scripting necessary to determine whether we're loaded in the mobile app
// If loaded and called on a normal PC, the JavaScript will just return false.
void add_js_function_isLoadedInMobileApp(void)
	{
	printf("<script type=\"text/javascript\">");
	printf("function isLoadedInMobileApp(){");			//Returns whether we're loaded in the mobile app or not...
	printf("	var ret = false;");					//initialize a default return value
	printf("	var ua = \"\";");						//initialize a variable for the user agent string (which is where the mobile app provides its custom string)
	printf("	if(typeof YUI===\"undefined\"){");				//if YUI is not available, use the native browser method to get the user-agent string
	printf("		ua = navigator.userAgent;");
	printf("	}else{");
	printf("		ua = YUI.Env.UA.userAgent;");
	printf("	}");
	printf("	if(ua.length>0){");						//if we have a valid user-agent string, test it for our mobile app identification string and update the return value appropriately
	printf("		if(ua.indexOf(\"%s\")>-1){", FAVS_APP_USERAGENT);
	printf("			ret = true;");
	printf("		}");
	printf("	}");
	printf("	return ret;");
	printf("}\n");//end function isLoadedInMobileApp()
	printf("</script>");
	}

void add_js_function_isLoadedInMobileApp_fprintf(FILE *fp)
	{
	fprintf(fp, "<script type=\"text/javascript\">");
	fprintf(fp, "function isLoadedInMobileApp(){");			//Returns whether we're loaded in the mobile app or not...
	fprintf(fp, "	var ret = false;");					//initialize a default return value
	fprintf(fp, "	var ua = \"\";");						//initialize a variable for the user agent string (which is where the mobile app provides its custom string)
	fprintf(fp, "	if(typeof YUI===\"undefined\"){");				//if YUI is not available, use the native browser method to get the user-agent string
	fprintf(fp, "		ua = navigator.userAgent;");
	fprintf(fp, "	}else{");
	fprintf(fp, "		ua = YUI.Env.UA.userAgent;");
	fprintf(fp, "	}");
	fprintf(fp, "	if(ua.length>0){");						//if we have a valid user-agent string, test it for our mobile app identification string and update the return value appropriately
	fprintf(fp, "		if(ua.indexOf(\"%s\")>-1){", FAVS_APP_USERAGENT);
	fprintf(fp, "			ret = true;");
	fprintf(fp, "		}");
	fprintf(fp, "	}");
	fprintf(fp, "	return ret;");
	fprintf(fp, "}\n");//end function isLoadedInMobileApp()
	fprintf(fp, "</script>");
	}

void add_js_function_isLoadedOnMobilePlatform_fprintf(FILE *fp)
	{
	fprintf(fp, "<script type=\"text/javascript\">");
	fprintf(fp, "function isLoadedOnMobilePlatform(){");		//Returns whether we're loaded on some mobile platform or not...
	fprintf(fp, "	var ret = false;");					//initialize a default return value
	fprintf(fp, "	var ua = \"\";");					//initialize a variable for the user agent string (which is where the mobile app provides its custom string)
	fprintf(fp, "	if(typeof YUI===\"undefined\"){");			//if YUI is not available, use the native browser method to get the user-agent string
	fprintf(fp, "		ua = navigator.userAgent;");
	fprintf(fp, "	}else{");
	fprintf(fp, "		ua = YUI.Env.UA.userAgent;");
	fprintf(fp, "	}");
	fprintf(fp, "	if(ua.length>0){");					//if we have a valid user-agent string, test it for some mobile platform identification strings and update the return value appropriately
	fprintf(fp, "		if(ua.indexOf(\"%s\")>-1", FAVS_PLATFORM_HTTPUA_IPHONE);
	fprintf(fp, "		   || ua.indexOf(\"%s\")>-1", FAVS_PLATFORM_HTTPUA_IPAD);
	fprintf(fp, "		   || ua.indexOf(\"%s\")>-1", FAVS_PLATFORM_HTTPUA_IPOD);
	fprintf(fp, "		   || ua.indexOf(\"%s\")>-1){", FAVS_PLATFORM_HTTPUA_ANDROID);
	fprintf(fp, "			ret = true;");
	fprintf(fp, "		}");
	fprintf(fp, "	}");
	fprintf(fp, "	return ret;");
	fprintf(fp, "}\n");
	fprintf(fp, "</script>");
	}

// Add the server side logic necessary to determine whether we're loaded in the mobile app -- looks for the unique user agent string for our mobile app (defined in the native code and in this .h file)
int isLoadedInMobileApp(void)
	{
	int ret = FALSE;						//default value to return
	if( strstr(getenv("HTTP_USER_AGENT"), FAVS_APP_USERAGENT) )	//if the user agent string contains the unique substring that our mobile app provides, then return true
		{
		ret = TRUE;
		}
	return ret;
	}

// Determine the platform of the native app -- DEV-NOTE: how?
int mobileAppPlatform(void)
	{
	int ret = 0;
	ret = FAVS_APP_PLATFORM_APPLE;	//DEV-NOTE: hard coded for now
	return ret;
	}

// Determine the version number (as a string) of the native app -- indicated by the native app's method of appending it to the http user-agent string
char *versionOfMobileApp(char *httpUserAgent)
	{
	#define MAX_CHARS_IN_VERSION (5)
	static char ret[MAX_CHARS_IN_VERSION];
	strcpy(ret, "0.00");								//initialize a default return value
	char *appUserAgent = strstr(httpUserAgent, FAVS_APP_USERAGENT);			//figure out the starting point of the app's user agent substring within the httpUserAgent string referenced
	memcpy(ret, appUserAgent+sizeof(FAVS_APP_USERAGENT), MAX_CHARS_IN_VERSION);	//copy the characters that we want, into the return value
	return ret;
	}

// Determine the version number (as an actual number) of the native app -- indicated by the native app's method of appending it to the http user-agent string
float versionNumberOfMobileApp()
	{
	float ret = 0;

	char *httpUserAgent = getenv("HTTP_USER_AGENT");					//use this here instead of cgi_detect_browser() because we want more detailed info than just the few it offers
	char *subStringStartingWithAppUserAgent = strstr(httpUserAgent, FAVS_APP_USERAGENT);	//figure out the starting point of the app's user agent substring within the httpUserAgent string referenced (looks like: "MessageNet Connections Mobile/1.6 uuid/A6E87C5C-4F8F-4732-825D-9A9DDF9FC1A3")

	char *appUserAgent = NULL;
	char *pch = NULL;

	appUserAgent = malloc(MAX_BUFFER);							//allocate memory for a user agent substring of unknown size (this will also allow us to do a 'free()' on it later, to clear it for possible repeated usage without strtok clobbering stuff)
	strcpy(appUserAgent, subStringStartingWithAppUserAgent);

	pch = strtok(appUserAgent, "/");							//go to the part of that string (ex: "MessageNet Connections Mobile/1.6 uuid/A6E87C5C-4F8F-4732-825D-9A9DDF9FC1A3"), up to the first slash
	pch = strtok (NULL, " ");								//go to the part of that string (ex: "1.6 uuid/A6E87C5C-4F8F-4732-825D-9A9DDF9FC1A3"), up to the first space... which should now give us the version number

	if(pch != NULL)
		{
		ret = atof(pch);
		}

	free(appUserAgent);									//also helps restore the clobbering that strtok seems to do, so future calls to this function will succeed

	return ret;
	}

// Determine whether we're loaded on a mobile platform (could be app or browser)
int isLoadedOnMobileDevice(void)
	{
	int ret = FALSE;
	char *httpUserAgent = getenv("HTTP_USER_AGENT");        // use this here instead of cgi_detect_browser() because we want more detailed info than just the few it offers
	if(httpUserAgent && 
		(  strstr(httpUserAgent, "iPad")		//example: Mozilla/5.0 (iPad; CPU OS 7_0_6 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11B651 Safari/9537.53
		|| strstr(httpUserAgent, "iPhone")
		|| strstr(httpUserAgent, "iPod")		//likely not needed, since iPod Touch seems to be caught by iPhone above, but can't hurt
		|| strstr(httpUserAgent, "Android")
		))
		{
		ret = TRUE;
		}
	return ret;
	}

// Handle adding a record number to the active copies (for toggle) encoded string of the favorite-template record.
// Also, copying toggle-data from the primary msg template, so we can have a "local" copy of that data to work with (in case screen get refreshed while toggle-able msg is active or something).
// NOTE: this has been adapted (2015.03.24) to use a FIFO scheme... since the field is limited in length to something around 12~18 records
// NOTE: this function sets currency, so be sure to save it before calling it, if needed.
// NOTE: this function is basically the inverse of db_banne.c:BannerRemoveActiveCopyRecnoFromAllFavTemplates() -- so be sure that necessary converse fields exist in both (e.g. if you add a field value here, re-init/clear it over there)
int addActiveCopyRecnoToFavTemplate(DBRECORD favRecno, DBRECORD recnoToAdd, UCHAR toggleDuration_raw, long msgDuration_raw, long toggleDuration_translated)
	{
	static const int RET_FAIL	= -1;			//define a return value for general failure
	static const int RET_DEFAULT	= FALSE;	//define a return value for default
	static const int RET_SUCCESS	= TRUE;		//define a return value for success
	int ret = RET_DEFAULT;						//initialize a default return value

	if( db_bann_setcur(favRecno) > 0			//set currency to the favorite record that we want to add an active copy recno to (making sure we're working with an actual favorite record, just to be safe)
		&& !strcmp(db_bann->dbb_msg_type_cod, bb_valid_types[BBT_FAVORITES].string) )
		{
		char favRec_activeCopyRecnos[MSGLINE_LENGTH];   //declare a temporary string that we'll use for working with the favorite record's list of active copy recnos
		char activeCopyRecnoStringToAdd[10];		    //declare a temporary string that we'll use for working with a string version of the record number of the active record that we want to add (including trailing delimiter)
	
		strcpy(favRec_activeCopyRecnos, db_bann->dbb_msg_5);  //copy the favorite record's list of record numbers of active copies to our local/temporary string
		remove_trailing_space(favRec_activeCopyRecnos);		  //strip trailing space from the local copy

		sprintf(activeCopyRecnoStringToAdd, FORMAT_DBRECORD_STR",", recnoToAdd);   //generate the string version of the active copy recno that will be added to the favorite record
		remove_trailing_space(activeCopyRecnoStringToAdd);					       //just to be safe

		int remaining_space = sizeof(db_bann->dbb_msg_5) - strlen(favRec_activeCopyRecnos);	//calculate how many blank spaces remain in the space for active copy record numbers

		if( remaining_space < strlen(activeCopyRecnoStringToAdd) )				//if there's no more empty space in the database field to add the active copy recno, return error (updated 2015.03.24 to remove first record and behave like FIFO)
			{
			//FAVS_GOTO_REMOVE_FIRST_ACTIVE_COPY_RECNO:
			//DEV-NOTE:  ADD FIFO LOGIC HERE... SUCCEED IT WITH GOTO NEXT ELSE-IF BRANCH... FAIL IT TO THE FOLLOWING ERROR...
			char *tokenPtr;
			DIAGNOSTIC_LOG_1("addActiveCopyRecnoToFavTemplate(): No space left in dbb_msg_5. Now going to perform FIFO on string: '%s'...", favRec_activeCopyRecnos);
			tokenPtr = strtok(favRec_activeCopyRecnos, ",");				//go to the part of the record-line up to the first comma delimiter (which should be the active-copy-recno we want to throw away, so we won't use or save this tokenPtr)
			DIAGNOSTIC_LOG_1("addActiveCopyRecnoToFavTemplate():  FIFO removing active-copy-recno: '%s'.", tokenPtr);
			tokenPtr = strtok(NULL, "\n");							//from previous tokenPtr, go all the way until the end of the line (which should be the bit we want to keep, minus the first recno of course)
			DIAGNOSTIC_LOG_1("addActiveCopyRecnoToFavTemplate():  FIFO finished. DB record will retain: '%s'.", tokenPtr);
			strcpyl(db_bann->dbb_msg_5, tokenPtr, MSGLINE_LENGTH);				//copy our newly-cleaned up active-copy-recno string to the dbb_msg_5 structure member, so it can be used as the base-string to concatenate the recno to add (after our goto) onto
			goto FAVS_GOTO_ADD_ACTIVE_COPY_RECNO;						//goto label that will enable us to add the recno to the end of the field's string

			DIAGNOSTIC_LOG_3("ERROR addActiveCopyRecnoToFavTemplate(): No space left in db_msg_5 to update the %s-message (recno "FORMAT_DBRECORD_STR") with data (%s).", FAVS_NAME_FULL, favRecno, activeCopyRecnoStringToAdd);
			ret = RET_FAIL;
			}
		else if( strstr(db_bann->dbb_msg_5, activeCopyRecnoStringToAdd) == NULL )		//else if the active copy recno does NOT exist in the fav record (and, naturally, we must have space remaining, since we made it here)
			{
			FAVS_GOTO_ADD_ACTIVE_COPY_RECNO:
			strcatl(db_bann->dbb_msg_5, activeCopyRecnoStringToAdd, MSGLINE_LENGTH);	//add the active copy recno to the fav record
			// the following field assignments aren't really a static part of a favorites-template record, we're just using the DB infrastructure to pass data... their data should only be relied upon as long as an active copy exists - and even then, be careful if there are multiple!
			// DEV-NOTE: ultimately, you probably need to offload these into a safe place, in the case of multiple active copies?
			#ifdef USE_INT64
			db_bann->dbb_toggle_duration = toggleDuration_raw;				//also add the main message template's selected toggle duration
			#endif
			db_bann->dbb_duration = msgDuration_raw;					//also, just to make life easy later at launch-time (in case they selected msg-dur for toggle duration), let's add the main message template's specified duration so BannerToggleDurationGetValue() will work
			if(toggleDuration_translated == -1)						//if toggle duration was set to message duration, but message duration was set to no-expire
				{
				strcpyl(db_bann->dbb_rec_dtsec_plus_duration, "9999999999", DTSEC_LENGTH);	//calculate an unlikely long-term value for ending toggle (this is equal to a few more millennia... sometime past the year 5000)
				}
			else
				{
				get_dtsec_plus_offset(db_bann->dbb_rec_dtsec_plus_duration, toggleDuration_translated);//also, pass along the calculated toggle-end-dtsec (note: this will be in server-time)
				}

			if(db_bann_write() < 0)								//try to save the change to the database, and if save operation failed...
				{
				ret = RET_FAIL;
				DIAGNOSTIC_LOG_3("ERROR addActiveCopyRecnoToFavTemplate(): Could not update the %s-message (recno "FORMAT_DBRECORD_STR") with data (%s).", FAVS_NAME_FULL, favRecno, activeCopyRecnoStringToAdd);
				}
			else										//else save operation succeeded...
				{
				ret = RET_SUCCESS;
				DIAGNOSTIC_LOG_2("addActiveCopyRecnoToFavTemplate(): FV record "FORMAT_DBRECORD_STR"'s active-copies field is now '%s'.", favRecno, db_bann->dbb_msg_5);
				}
			}
		/*else just continue to finish and return default value*/
		}
	else											//else could not set currency for some reason
		{
		ret = RET_FAIL;
		DIAGNOSTIC_LOG_1("ERROR addActiveCopyRecnoToFavTemplate(): Could not set database currency for favRecno "FORMAT_DBRECORD_STR".", favRecno);
		}
	
	return ret;
	}
/* Update for v0.43.0-beta... for now just going to save a single active-copy recno. 
 * The toggle duration only saves 1 anyway, so going to have to figure out another way to support multiple toggles, later down the road.
 * Note: this will obliterate any older active-copy recnos in the FV's field! */
int saveSingleActiveCopyRecnoToFavTemplate(DBRECORD favRecno, DBRECORD recnoToAdd, UCHAR toggleDuration_raw, long msgDuration_raw, long toggleDuration_translated)
	{
	static const int RET_FAIL	= -1;							//define a return value for general failure
	static const int RET_DEFAULT	= FALSE;						//define a return value for default
	static const int RET_SUCCESS	= TRUE;							//define a return value for success
	int ret = RET_DEFAULT;									//initialize a default return value

	//DIAGNOSTIC_LOG_4("saveSingleActiveCopyRecnoToFavTemplate(): favrecno='"FORMAT_DBRECORD_STR"', activerecno='"FORMAT_DBRECORD_STR"', toggledur='%c', msgdur='%ld'", favRecno, recnoToAdd, toggleDuration_raw, msgDuration_raw);
	if( db_bann_setcur(favRecno) > 0							//set currency to the favorite record that we want to add an active copy recno to (making sure we're working with an actual favorite record, just to be safe)
		&& !strcmp(db_bann->dbb_msg_type_cod, bb_valid_types[BBT_FAVORITES].string) )
		{
		char activeCopyRecnoStringToAdd[10];							//declare a temporary string that we'll use for working with a string version of the record number of the active record that we want to add (including trailing delimiter)
	
		sprintf(activeCopyRecnoStringToAdd, FORMAT_DBRECORD_STR",", recnoToAdd);		//generate the string version of the active copy recno that will be added to the favorite record
		remove_trailing_space(activeCopyRecnoStringToAdd);					//just to be safe

		strcpyl(db_bann->dbb_msg_5, activeCopyRecnoStringToAdd, MSGLINE_LENGTH);		//save the active copy recno to the fav record (again, note this will overwrite any existing active-copy recno, of course)
	
		// the following field assignments aren't really a static part of a favorites-template record, we're just using the DB infrastructure to pass data... their data should only be relied upon as long as an active copy exists - and even then, be careful if there are multiple!
		// DEV-NOTE: ultimately, you probably need to offload these into a safe place, in the case of multiple active copies?
		#ifdef USE_INT64
		db_bann->dbb_toggle_duration = toggleDuration_raw;					//also add the main message template's selected toggle duration
		#endif
		db_bann->dbb_duration = msgDuration_raw;						//also, just to make life easy later at launch-time (in case they selected msg-dur for toggle duration), let's add the main message template's specified duration so BannerToggleDurationGetValue() will work
		if(toggleDuration_translated == -1)							//if toggle duration was set to message duration, but message duration was set to no-expire
			{
			strcpyl(db_bann->dbb_rec_dtsec_plus_duration, "9999999999", DTSEC_LENGTH);		//calculate an unlikely long-term value for ending toggle (this is equal to a few more millennia... sometime past the year 5000)
			}
		else
			{
			get_dtsec_plus_offset(db_bann->dbb_rec_dtsec_plus_duration, toggleDuration_translated);	//also, pass along the calculated toggle-end-dtsec (note: this will be in server-time)
			}

		if(db_bann_write() < 0)									//try to save the change to the database, and if save operation failed...
			{
			ret = RET_FAIL;
			DIAGNOSTIC_LOG_3("ERROR saveSingleActiveCopyRecnoToFavTemplate(): Could not update the %s-message (recno "FORMAT_DBRECORD_STR") with data (%s).", FAVS_NAME_FULL, favRecno, activeCopyRecnoStringToAdd);
			}
		else											//else save operation succeeded...
			{
			ret = RET_SUCCESS;
			DIAGNOSTIC_LOG_2("saveSingleActiveCopyRecnoToFavTemplate(): FV record "FORMAT_DBRECORD_STR"'s active-copies field is now '%s'.", favRecno, db_bann->dbb_msg_5);
			}
		}
	else											//else could not set currency for some reason
		{
		ret = RET_FAIL;
		DIAGNOSTIC_LOG_1("ERROR saveSingleActiveCopyRecnoToFavTemplate(): Could not set database currency for favRecno "FORMAT_DBRECORD_STR".", favRecno);
		}
	
	return ret;
	}


// Add a new favorite-message record, based on data posted through HTTP (e.g. a form submission, YUI-IO, etc.)
// 	NOTE: this is an abstraction/migration from the original "addMsgToFavs=" smcgi-command logic (see smcgi.c file prior to 2014.11.20) ~ intention is so we can add a new fav record from anywhere
/* Minimum form fields (their names) that must be posted to the branch wherever this function is called from:
 * 	addMsgToFavs			(this routine's initiating command, obviously)
 * 	userPin				(user "pin" -really a string- of the user under which to add a favorite message)
 * 	msgName				(the name of the message template that this favorite will reference)
 * 	msgDir				(the directory of the message template that this favorite will reference) 
 * 	msgParentRecnoToFavorite	(the recno of the message template that this favorite will reference)
 * 	msgDesc				(the description field of the message to be favorited) */
int add_new_favorite_message_from_http_post(void)
	{
	char addMsgToFav_userPin[PIN_LENGTH];
	char addMsgToFav_msgName[MSG_NAME_LENGTH];
	char addMsgToFav_directory[DIRECTORY_LENGTH];
	DBRECORD addMsgToFav_msgTemplateRecno;
	char addMsgToFav_position[DTSEC_LENGTH];
	char *buf = NULL;
	char buf2[6];						//temporarily, for building the numerical position values (some char/str representing an integer, with up to 4 leading zeros)
	char addMsgToFav_description[DESCRIPTION_LENGTH];
	int status;
	int i = 0;
	int ret = FALSE;					//initialize a default return value

	char curtime[DTSEC_LENGTH];
	get_dtsec(curtime);

	// Parse the data that was sent through the HTTP POST action... this data gets posted by JavaScript:doInboxMsgLineContextMenuItemClick() in smcgi_yui.c:add_yui_inboxMsgContextMenuAction()
	cgi_parsed_lookup("userPin=", addMsgToFav_userPin, PIN_LENGTH);
	cgi_parsed_lookup("msgName=", addMsgToFav_msgName, MSG_NAME_LENGTH);
	cgi_parsed_lookup("msgDir=", addMsgToFav_directory, DIRECTORY_LENGTH);
	addMsgToFav_msgTemplateRecno = cgi_parsed_lookup_record_number("msgParentRecnoToFavorite=", 0);
	cgi_parsed_lookup("msgDesc=", addMsgToFav_description, DESCRIPTION_LENGTH);

	// Count how many favorite messages this user has.... to see whether or not this will be the user's first/only favorite message (if it is, then we will later need to save it as the first sorted favorite)
	db_bann_select(2);										//select with keys: res_id, dbb_pin, dbb_msg_type_cod, dbb_read_flag, dbb_rec_dtsec...
	strcpy(db_bann->res_id, res_id);
	strcpy(db_bann->dbb_pin, addMsgToFav_userPin);
	strcpy(db_bann->dbb_msg_type_cod, bb_valid_types[BBT_FAVORITES].string);
	strcpy(db_bann->dbb_read_flag, BANN_READ);
	BannerSetIgnoreFavoritesType(FALSE);
	status = db_bann_find();									//find the initial database record that matches the criteria above
	while( status > 0										//while there are database records that are favorite-type messages... (count how many)
		&& !strcmp(db_bann->res_id, res_id)
		&& !strcmp(db_bann->dbb_pin, addMsgToFav_userPin)
		&& !strcmp(db_bann->dbb_msg_type_cod, bb_valid_types[BBT_FAVORITES].string)
		&& !strcmp(db_bann->dbb_read_flag, BANN_READ) )
		{
		i++;
		status = db_bann_next();
		}

	// Setup the initial flag and position for this new favorite-message  (format example: "U:0,0,0" -- see smcgi_favorites.h for detailed explanation of this encoding syntax)
	buf = malloc(MAX_BUFFER);
		strcpy(buf, FAVS_UNSORTED_FLAG);								//set our position type flag as "unsorted" (aka "dropbox")
		strcat(buf, FAVS_POSITION_DELINEATE_TYPE);
		snprintf(buf2, sizeof(buf2), "%05d", FAVS_UNSORTED_INDEX_A_MIN);				//our unsorted indexing (A-level) with up to 4 leading zeros (using snprintf ensures we won't do more than 5 digits no matter what the FAVS_UNSORTED_INDEX_A_MIN value is)
		strcat(buf, buf2);
		strcat(buf, FAVS_POSITION_DELINEATE_COORD);
		snprintf(buf2, sizeof(buf2), "%05d", FAVS_UNSORTED_INDEX_B_MIN);				//our unsorted indexing (B-level) with up to 4 leading zeros (using snprintf ensures we won't do more than 5 digits no matter what the FAVS_UNSORTED_INDEX_B_MIN value is)
		strcat(buf, buf2);
		strcat(buf, FAVS_POSITION_DELINEATE_COORD);
		snprintf(buf2, sizeof(buf2), "%05d", FAVS_UNSORTED_INDEX_C_MIN);				//our unsorted indexing (C-level) with up to 4 leading zeros (using snprintf ensures we won't do more than 5 digits no matter what the FAVS_UNSORTED_INDEX_C_MIN value is)
		strcat(buf, buf2);
	strcpy(addMsgToFav_position, buf);
	free(buf);

	// Copy all those values to the database structure
	//BannerInitializeFieldsForAdding();								//NOTE: this wasn't actually initializing ALL fields... some junk data was coming through to our add operation below, after the find above)
	memset(db_bann, 0, sizeof(DB_FM_BAN));								//make sure our db_bann structure is completely cleared out before doing our add (especially since we just did a find, above)
	strcpy(db_bann->res_id, res_id);
        strcpy(db_bann->dbb_pin, addMsgToFav_userPin);							//(key field) user pin under which to save the message as a favorite
        strcpy(db_bann->dbb_msg_type_cod, bb_valid_types[BBT_FAVORITES].string);			//(key field) type of message is "favorite"
	strcpy(db_bann->dbb_read_flag, BANN_READ);							//(key field) unused? but can't be empty ("")
	strcpyl(db_bann->dbb_rec_dtsec, addMsgToFav_position, sizeof(db_bann->dbb_rec_dtsec));		//(key field) favorites "position"
	strcpyl(db_bann->dbb_directory, addMsgToFav_directory, sizeof(db_bann->dbb_directory));		//directory the message template is located in
	strcpyl(db_bann->dbb_msg_name, addMsgToFav_msgName, sizeof(db_bann->dbb_msg_name));		//name of the message template
	db_bann->dbb_parent_record = addMsgToFav_msgTemplateRecno;					//record number of the message template (what may actually get launched later from the favorites screen)
	strcpyl(db_bann->dbb_description, addMsgToFav_description, sizeof(db_bann->dbb_description));	//message template's description
	strcpyl(db_bann->dbb_dtsec, curtime, sizeof(db_bann->dbb_dtsec));				//current time (for letting us know when the favorite was created)
	#ifdef USE_INT64
	db_bann->dbb_confirm_send = FAVS_CONFIRMSEND_ALL;						//all newly-added favs default to confirm send on all devices
	strcpysl(db_bann->dbb_building_group, "", BUILDING_LENGTH);					//used for custom color
	#endif

	DIAGNOSTIC_LOG_6("Adding message template (recno:'"FORMAT_DBRECORD_STR"', name:'%s', dir:'%s') to user's (%s) %s-list (position:'%s')...", addMsgToFav_msgTemplateRecno, addMsgToFav_msgName, addMsgToFav_directory, addMsgToFav_userPin, FAVS_NAME_FULL, addMsgToFav_position);

	// Save new favorite-message record to database
	if(db_bann_add() < 0)
		{
		DIAGNOSTIC_LOG_1("  ERROR: db_bann_add() failed. Message was not added to %s-list database.", FAVS_NAME_FULL);						//log to server
		printf("Server reports failure at db_bann_add() operation in smcgi. Message most likely was not added to %s-list due to error.", FAVS_NAME_FULL);	//log to client
		}
	else
		{
		DIAGNOSTIC_LOG_3("  Success: message added to %s %s-list database (new recno "FORMAT_DBRECORD_STR")", FAVS_NAME_FULL, FAVS_NAME_SINGULAR, db_bann_getcur());			//log to server
		printf("Server reports success. Message added to %s %s-list as record number "FORMAT_DBRECORD_STR".", FAVS_NAME_FULL, FAVS_NAME_SINGULAR, db_bann_getcur());			//log to client
		ret = TRUE;
		}

	return ret;
	}//add_new_favorite_message_from_http_post()

// Add a new favorite-message record, based on data passed through arguments
/* Minimum arguments that must be posted to the branch wherever this function is called from:
 * 	userPin		(user "pin" -really a string- of the user under which to add a favorite message)
 * 	position	(position value)
 * 	label1		(the label1-text to assign to the label1 field of the new FV record that will be created) */
int add_new_favorite_message_from_arguments(char *userPin, char *position, char *label1)
	{
	int ret = FALSE;					//initialize a default return value

	char curtime[DTSEC_LENGTH];
	get_dtsec(curtime);

	// Copy all those values to the database structure
	//BannerInitializeFieldsForAdding();								//NOTE: this wasn't actually initializing ALL fields... some junk data was coming through to our add operation below, after the find above)
	memset(db_bann, 0, sizeof(DB_FM_BAN));								//make sure our db_bann structure is completely cleared out before doing our add (especially since we just did a find, above)
	strcpy(db_bann->res_id, res_id);
        strcpyl(db_bann->dbb_pin, userPin, PIN_LENGTH);							//(key field) user pin under which to save the message as a favorite
        strcpy(db_bann->dbb_msg_type_cod, bb_valid_types[BBT_FAVORITES].string);			//(key field) type of message is "favorite"
	strcpy(db_bann->dbb_read_flag, BANN_READ);							//(key field) unused? but can't be empty ("")
	strcpyl(db_bann->dbb_rec_dtsec, position, sizeof(db_bann->dbb_rec_dtsec));			//(key field) favorites "position"
	strcpyl(db_bann->dbb_directory, "", sizeof(db_bann->dbb_directory));				//directory the message template is located in
	strcpyl(db_bann->dbb_msg_name, "", sizeof(db_bann->dbb_msg_name));				//name of the message template
	db_bann->dbb_parent_record = 0;									//record number of the message template (what may actually get launched later from the favorites screen)
	strcpyl(db_bann->dbb_description, "", sizeof(db_bann->dbb_description));			//message template's description
	strcpyl(db_bann->dbb_dtsec, curtime, sizeof(db_bann->dbb_dtsec));				//current time (for letting us know when the favorite was created)
	#ifdef USE_INT64
	db_bann->dbb_confirm_send = FAVS_CONFIRMSEND_ALL;						//all newly-added favs default to confirm send on all devices
	strcpyl(db_bann->dbb_building_group, "", BUILDING_LENGTH);					//used for custom color
	#endif
	strcpyl(db_bann->dbb_msg_1, label1, MSGLINE_LENGTH);						//used for fav/subheader name
	strcpyl(db_bann->dbb_rec_dtsec_plus_duration, "", sizeof(db_bann->dbb_rec_dtsec_plus_duration));//toggle-end dtsec

	DIAGNOSTIC_LOG_4("Adding new record to user's (%s) %s-list (position:'%s'  label1:'%s')...", db_bann->dbb_pin, FAVS_NAME_SINGULAR, db_bann->dbb_rec_dtsec, db_bann->dbb_msg_1);

	// Save new favorite-message record to database
	if(db_bann_add() < 0)
		{
		DIAGNOSTIC_LOG_1("  ERROR: db_bann_add() failed. Message was not added to %s-list database.", FAVS_NAME_FULL);						//log to server
		printf("Server reports failure at db_bann_add() operation in smcgi. Message most likely was not added to %s-list due to error.", FAVS_NAME_FULL);	//log to client
		}
	else
		{
		DIAGNOSTIC_LOG_3("  Success: message added to %s %s-list database (new recno "FORMAT_DBRECORD_STR")", FAVS_NAME_FULL, FAVS_NAME_SINGULAR, db_bann_getcur());			//log to server
		printf("Server reports success. Message added to %s %s-list as record number "FORMAT_DBRECORD_STR".", FAVS_NAME_FULL, FAVS_NAME_SINGULAR, db_bann_getcur());			//log to client
		ret = TRUE;
		}

	return ret;
	}//add_new_favorite_message_from_http_post()


// Add the client scripting necessary to perform an HTTP POST
// The JavaScript simulates an HTTP-POST by constructing a logical form and submitting it
// JavaScript usage example:  doHttpRequest_post('[cgi_server string]', {myname:'somevalue', anotheritem:'anothervalue'});
void add_js_function_doHttpRequest_post_fprintf(FILE *fp)
	{
	fprintf(fp, "<script type=\"text/javascript\">");
	fprintf(fp, "function doHttpRequest_post(path, params){");						//path is the server resource to process the POST... params is an object-literal of name-value pairs to actually send
	fprintf(fp, "	var form = document.createElement(\"form\");");
	fprintf(fp, "	form.setAttribute(\"method\", \"post\");");
	fprintf(fp, "	form.setAttribute(\"action\", path);");
	fprintf(fp, "	for(var key in params){");
	fprintf(fp, "		if(params.hasOwnProperty(key)){");                                              //ensure there aren't any bugs with params
	fprintf(fp, "			var hiddenField = document.createElement(\"input\");");
	fprintf(fp, "			hiddenField.setAttribute(\"type\", \"hidden\");");
	fprintf(fp, "			hiddenField.setAttribute(\"name\", key);");
	fprintf(fp, "			hiddenField.setAttribute(\"value\", params[key]);");
	fprintf(fp, "			form.appendChild(hiddenField);");
	fprintf(fp, "		}");//end if
	fprintf(fp, "	}");//end for
	fprintf(fp, "	document.body.appendChild(form);");
	fprintf(fp, "	form.submit();");
	fprintf(fp, "}");//end function doHttpRequest_post()
	fprintf(fp, "</script>");
	}//add_js_function_doHttpRequest_post_fprintf()

// Add the client scripting necessary to perform an HTTP POST
// The JavaScript simulates an HTTP-POST by constructing a logical form and submitting it
// JavaScript usage example:  doHttpRequest_post('[cgi_server string]', {myname:'somevalue', anotheritem:'anothervalue'});
void add_js_function_doHttpRequest_post_printf()
	{
	printf("<script type=\"text/javascript\">");
	printf("function doHttpRequest_post(path, params){");						//path is the server resource to process the POST... params is an object-literal of name-value pairs to actually send
	printf("	var form = document.createElement(\"form\");");
	printf("	form.setAttribute(\"method\", \"post\");");
	printf("	form.setAttribute(\"action\", path);");
	printf("	for(var key in params){");
	printf("		if(params.hasOwnProperty(key)){");                                              //ensure there aren't any bugs with params
	printf("			var hiddenField = document.createElement(\"input\");");
	printf("			hiddenField.setAttribute(\"type\", \"hidden\");");
	printf("			hiddenField.setAttribute(\"name\", key);");
	printf("			hiddenField.setAttribute(\"value\", params[key]);");
	printf("			form.appendChild(hiddenField);");
	printf("		}");//end if
	printf("	}");//end for
	printf("	document.body.appendChild(form);");
	printf("	form.submit();");
	printf("}");//end function doHttpRequest_post()
	printf("</script>");
	}//add_js_function_doHttpRequest_post_printf()

// Add the client scripting necessary to perform an asynchronous HTTP POST via YUI
// JavaScript usage example:  doHttpRequest_post('[cgi_server string]', {myname:'somevalue', anotheritem:'anothervalue'});
void add_js_function_doHttpRequest_async_post_printf()
	{
	printf("<script type=\"text/javascript\">");
	printf("function doHttpRequest_async_post(path, data, callback){");				//path is the server resource to process the POST... data is an object-literal of name-value pairs to actually send ~ex: {field1:'value1'}... callback is optional
	printf("	var XHR = new XMLHttpRequest();");
	printf("	var urlEncodedData = \"\";");
	printf("	var urlEncodedDataPairs = [];");
	printf("	var name;");
	printf("	for(name in data) {");									//turn the data object into an array of URL encoded key value pairs
	printf("		urlEncodedDataPairs.push(encodeURIComponent(name) + '=' + encodeURIComponent(data[name]));");
	printf("	}");
	printf("	urlEncodedData = urlEncodedDataPairs.join('&').replace(/%%20/g, '+');");		//combine the pairs into a single string and replace all encoded spaces to the plus character to match the behaviour of the web browser form submit
	printf("	XHR.addEventListener('load', function(event) {");					//define what will happen if the data is successfully sent
	printf("		if(callback){callback(true);}");						//if a callback was specified, then call it (sending a true to represent success)
	printf("		});");
	printf("	XHR.addEventListener('error', function(event) {");					//define what will happen in case of error
	printf("		if(callback){callback(false);}");						//if a callback was specified, then call it (sending a false to represent some kind of error)
	printf("		});");
	printf("	XHR.open('POST', path);");								//setup the request
	printf("	XHR.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');");		//add the required HTTP header to handle a form data POST request
	printf("	XHR.setRequestHeader('Content-Length', urlEncodedData.length);");			//add the required HTTP header to handle a form data POST request
	printf("	XHR.send(urlEncodedData);");								//actually send the data
	printf("}");//end function doHttpRequest_async_post()
	printf("</script>");
	}//add_js_function_doHttpRequest_async_post_printf()


/***********************************************************************
* functions for dealing with URL encoding/decoding
***********************************************************************/
// Converts a hex character to its integer value...
char from_hex(char ch)
	{
	return isdigit(ch) ? ch - '0' : tolower(ch) - 'a' + 10;
	}
// Converts an integer value to its hex character...
char to_hex(char code)
	{
	static char hex[] = "0123456789abcdef";
	return hex[code & 15];
	}
// Returns a url-encoded version of str... (NOTE: be sure to free() the returned string after use)
char *url_encode(char *str)
	{
	char *pstr = str;
	char *buf = malloc(strlen(str) * 3 + 1);
	char *pbuf = buf;
	while(*pstr)
		{
		if(isalnum(*pstr) || *pstr=='-' || *pstr=='_' || *pstr=='.' || *pstr=='~') *pbuf++ = *pstr;
		else if(*pstr==' ') *pbuf++ = '+';
		else *pbuf++ = '%', *pbuf++ = to_hex(*pstr >> 4), *pbuf++ = to_hex(*pstr & 15);
		pstr++;
		}
	*pbuf = '\0';
	return buf;
	}
// Returns a url-decode version of str... (NOTE: be sure to free() the returned string after use)
char *url_decode(char *str)
	{
	char *pstr = str;
	char *buf = malloc(strlen(str) + 1);
	char *pbuf = buf;
	while(*pstr)
		{
		if(*pstr=='%')
			{
			if(pstr[1] && pstr[2])
				{
				*pbuf++ = from_hex(pstr[1]) << 4 | from_hex(pstr[2]);
				pstr += 2;
				}
			}
		else if(*pstr=='+') *pbuf++ = ' ';
		else *pbuf++ = *pstr;
		pstr++;
		}
	*pbuf = '\0';
	return buf;
	}


/***********************************************************************
* void generate_favTestData(int printScriptTags)
*
* 	This function should only be used for development/testing
* 	It generates hard-coded test data, rather than using database.
*
* 	DEV-NOTE: because this was an early development, it may need fields updated/added if used again!
*
***********************************************************************/
void generate_favTestData(int printScriptTags)
{
int i;
int numberOfUnsortedRecords = 3;	//specify number of unsorted records to simulate
int numberOfSortedRecords = 10;		//specify number of sorted records to simulate

if(printScriptTags)
	{
	printf("<script type=\"text/javascript\">\n");
	}

printf("var favsFromDB=[\n");							//begin constructing an array that will be used by YUI recordset to instantiate a recordset object...

/*simulate unsorted favorites...*/
i = FAVS_UNSORTED_INDEX_A_MIN;
while(i < FAVS_UNSORTED_INDEX_A_MIN + numberOfUnsortedRecords)
	{
	// The following constructs a JavaScript array (called favsFromDB) that will then be used by the client's YUI logic to build a YUI recordset object.
	// By doing it this way, the client should have more autonomous control over the data for adding, sorting, etc. - all without constant calls back to the server, hammering the database, etc.
	// Syntax-Note: each 'column' in the recordset is allowed/given a custom name (e.g. icon, label1, label2, etc.), followed by the data itself
	if(i > 0) printf("	,\n");						// A comma is needed between records, so do it this way
	printf("		{recno_fav:\"0%d\",", i);
	printf("		msgdir:\"DIRECTORY NAME %d\",", i);
	printf("		msgname:\"MESSAGE NAME %d\",", i);
	printf("		position:\"%s:%d,%d,%d\",", FAVS_UNSORTED_FLAG, FAVS_UNSORTED_INDEX_A_MIN, FAVS_UNSORTED_INDEX_B_MIN, FAVS_UNSORTED_INDEX_C_MIN);
	printf("		label1:\"\",");
	printf("		label2:\"\",");
	printf("		msgdesc:\"\",");
	printf("		icon:\"\"}");
	i++;
	}

/*simulate already-sorted favorites...*/
i = FAVS_SORTED_INDEX_A_MIN;
while(i < FAVS_SORTED_INDEX_A_MIN + numberOfSortedRecords)
	{
	// The following constructs a JavaScript array (called favsFromDB) that will then be used by the client's YUI logic to build a YUI recordset object.
	// By doing it this way, the client should have more autonomous control over the data for adding, sorting, etc. - all without constant calls back to the server, hammering the database, etc.
	// Syntax-Note: each 'column' in the recordset is allowed/given a custom name (e.g. icon, label1, label2, etc.), followed by the data itself
	if(i > 0) printf("	,\n");						// A comma is needed between records, so do it this way
	printf("		{recno_fav:\"0%d\",", i);
	printf("		msgdir:\"DIRECTORY NAME %d\",", i);
	printf("		msgname:\"MESSAGE NAME %d\",", i);
	printf("		position:\"%s:%d,%d,%d\",", FAVS_SORTED_FLAG, i, 0, 0);	//DEV-NOTE: no support yet for 2nd-dimension, so just hardcode 0's
	printf("		label1:\"Custom name for %d\",", i);
	printf("		label2:\"This is a custom description for %d\",", i);
	printf("		msgdesc:\"The message template description\",");
	printf("		icon:\"coded/bookmark-new-2.png\"}");
	i++;
	}

printf("\n	];\n");//end data scructure

if(printScriptTags)
	{
	printf("</script>\n");
	}
}


/***********************************************************************
* void generate_favData_forCurrentUser(int printScriptTags)
*
* 	This function generates an initial, data object (a JavaScript object-literal) from the favorites database.
* 	This object can then be used to populate a recordset or something like that.
*
* 	Mapping of how we are using and/or re-purposing the message fields for favorites...
* 		db_bann->res_id			--> the usual key
* 		db_bann->dbb_pin (recipient)	--> user					(this is how we correlate favorites-screen favorites-messages with the particular person's favorites screen)
* 		db_bann->dbb_msg_type_cod	--> these are 'favorites' type messages		(just another message type for "favorite" types of messages)
* 		db_bann->dbb_read_flag		--> (can't remember, but it's needed)
* 		db_bann->dbb_directory		--> message template directory location		(the directory of the message that this favorite-message points to)
* 		db_bann->dbb_msg_name		--> message template name			(the message that this favorite-message points to)
* 		db_bann->dbb_rec_dtsec		--> customizable favorite-icon position		(encoded string that indicates the "message"'s location in the list / grid, as well as type of favorite -- see smcgi_favorites.h for explanation)
* 		db_bann->dbb_msg_1		--> customized label for the favorite		(favorite message's main label)  (at last check, the max characters would be 69 ... 70 counting the null-character) (defined by MSGLINE_LENGTH in local.h)
* 		db_bann->dbb_msg_2		--> customized label for the favorite		(favorite message's description)  (at last check, the max characters would be 69 ... 70 counting the null-character) (defined by MSGLINE_LENGTH in local.h)
* 		db_bann->dbb_msg_3		--> customized icon-filename for the favorite	(favorite message's icon filename)  (at last check, the max characters would be 69 ... 70 counting the null-character) (defined by MSGLINE_LENGTH in local.h)
* 		db_bann->dbb_msg_4		--> (RESERVED: second icon?)			(favorite message's icon filename #2)  (at last check, the max characters would be 69 ... 70 counting the null-character) (defined by MSGLINE_LENGTH in local.h)
* 		db_bann->dbb_msg_5		--> active copies for toggle			(list of active copies of the message - used for knowing which ones to display toggle for)  (at last check, the max characters would be 69 ... 70 counting the null-character) (defined by MSGLINE_LENGTH in local.h)
* 		db_bann->dbb_description	--> reusing for the same purpose		(just a verbatim copy of the message template's description, so we can get it easily if no favorite description is used or something)
* 		db_bann->dbb_building_group	--> base-color					(a hex -or possibly RGB in future- color value used primarily/only for custom headers)
*
* 	DEV-NOTE: This should probably eventually be ported over to YUI-IO capability, but you'll need to figure out how to solve the asynchronicity issue to properly populate the recordset object...
* 		  Then again, this might be fine for an initial loading, as it is?
* 		  (we're already doing something similar down in refreshRecordset(), if you want to look at that as a model)
*
***********************************************************************/
void generate_favData_forCurrentUser(int printScriptTags)
{
int status;							//used for database-read loop navigation
int i = 0;							//used for loop indexing

db_bann_select(2);						//select with res_id, dbb_pin, dbb_msg_type_cod, dbb_read_flag, dbb_rec_dtsec...
strcpy(db_bann->res_id, res_id);
strcpy(db_bann->dbb_pin, CurrentUserPin);
strcpy(db_bann->dbb_msg_type_cod, bb_valid_types[BBT_FAVORITES].string);
strcpy(db_bann->dbb_read_flag, BANN_READ);
//dbb_rec_dtsec doesn't need specified (?) but is part of this key (so it should sort by that)

BannerSetIgnoreFavoritesType(FALSE);				//set our global flag to let favorites/cgi know to NOT ignore BBT_FAVORITES when it directs banner to read its database
status = db_bann_find();					//find the initial database record that matches the criteria above

if(printScriptTags)
	{
	printf("\n<script type=\"text/javascript\">\n");
	}

printf("var favsFromDB=[\n");					//begin constructing an array that will be used by YUI recordset to instantiate a recordset object...

while( status > 0 						//while there are database records that match our criteria (we know there should be at least one, so our structure should turn out syntactically correct)...
	&& !strcmp(db_bann->res_id, res_id) 
	&& !strcmp(db_bann->dbb_pin, CurrentUserPin)
	&& !strcmp(db_bann->dbb_msg_type_cod, bb_valid_types[BBT_FAVORITES].string) 
	&& !strcmp(db_bann->dbb_read_flag, BANN_READ) )
	{

	if( strstr(db_bann->dbb_rec_dtsec, FAVS_DELETED_FLAG) == NULL )	/* ignore deleted-flagged favorites... helps make load times faster... if you want deleted favs, then get them explicitly */
		{

		/* The following constructs a JavaScript object-literal (called favsFromDB) that will then be used by the client's YUI logic to build a YUI recordset object.
		 * By doing it that way, the client should have more autonomous control over the data for adding, sorting, etc. - all without constant calls back to the server, hammering the database, etc.
		 * Syntax-Note: each 'column' in the recordset is allowed/given a custom name (e.g. icon, label1, label2, etc.), followed by the data itself -- since this is an object-literal, the field/key names don't need to be strings */
		if( i > 0 ) printf(",\n");				//a comma is needed between records, so print one before each record (after the first one) ... the new-line
		printf("{");
		printf("recno_fav:\""FORMAT_DBRECORD_STR"\",", db_bann_getcur());
		printf("position:\"%s\",", db_bann->dbb_rec_dtsec);
		printf("icon:\"%s\",", db_bann->dbb_msg_3);
		printf("icon2:\"%s\",", db_bann->dbb_msg_4);
		printf("label1:\"%s\",", db_bann->dbb_msg_1);
		printf("label2:\"%s\",", db_bann->dbb_msg_2);
		printf("recno_msgtemplate:\""FORMAT_DBRECORD_STR"\",", db_bann->dbb_parent_record);
		printf("msgdir:\"%s\",", db_bann->dbb_directory);
		printf("msgdir_recno:\""FORMAT_DBRECORD_STR"\",", CheckValidDirectory(db_bann->dbb_directory));
		printf("msgname:\"%s\",", db_bann->dbb_msg_name);
		printf("msgdesc:\"%s\",", remove_trailing_space(db_bann->dbb_description));
		#ifdef USE_INT64
		printf("confirmSend:%d,", db_bann->dbb_confirm_send);
		printf("color:\"%s\",", remove_trailing_space(db_bann->dbb_building_group));
		#endif
		printf("active_copies:\"%s\",", db_bann->dbb_msg_5);
		printf("toggle_duration:\"%d\",", BannerToggleDurationGetValue());	//return the calculated-seconds equivalent of the raw UCHAR selection
		printf("toggle_end_dtsec:'%s',", db_bann->dbb_rec_dtsec_plus_duration);	//return the calculated-toggle-end-dtsec (calculated in addActiveCopyRecnoToFavTemplate)
		printf("dtsec:\"%s\"", remove_leading_space(db_bann->dbb_dtsec));
		/* DEV-NOTE: additional possible fields:
		 * - something about when the msg was last launched -- needs to be pulled from another database
		 * - verify send (msg template should override client if true for template)
		 */
		/******* IMPORTANT NOTE: If you add/modify/remove any fields here, you should make sure the corresponding logic in smcgi.c is also updated accordingly ******************/
		printf("}");
		i++;

		}//end if

	status = db_bann_next();
	}//end while

printf("\n];\n");//end data scructure

if(printScriptTags)
	{
	printf("</script>\n");
	}
}


/***********************************************************************
* void generate_inboxData_forCurrentUser(int printScriptTags)
*
* 	This function generates an initial, data object (a JavaScript object-literal) from the inbox database.
* 	This object can then be used to populate a recordset or something like that.
*
* 	DEV-NOTE: This should probably eventually be ported over to YUI-IO capability, but you'll need to figure out how to solve the asynchronicity issue to properly populate the recordset object...
* 		  Then again, this might be fine for an initial loading, as it is?
* 		  (we're already doing something similar down in refreshRecordset(), if you want to look at that as a model)
*
***********************************************************************/
void generate_inboxData_forCurrentUser(int printScriptTags)
{
int status;							//used for database-read loop navigation
int i = 0;							//used for loop indexing

char from_first_name[FIRST_NAME_LENGTH];
char from_last_name[LAST_NAME_LENGTH];
char courtesy_name[100];

char message[PAGE_MESSAGE_LENGTH];
char font[PAGE_MESSAGE_LENGTH];         //not using here, but initializing to make cgi_decode() happy
char mode[PAGE_MESSAGE_LENGTH];         //not using here, but initializing to make cgi_decode() happy
char color[PAGE_MESSAGE_LENGTH];        //not using here, but initializing to make cgi_decode() happy
char auto_addr[PIN_LENGTH];             //not using here, but initializing to make cgi_decode() happy

db_bann_select(9);						//select with res-id, user-pin, status, dtsec nines...

strcpy(db_bann->res_id, res_id);
strcpy(db_bann->dbb_pin, CurrentUserPin);
strcpy(db_bann->dbb_msg_status, bb_valid_status[BBS_ACTIVE]);
strcpy(db_bann->dbb_rec_dtsec_nines, "");

status = db_bann_find();					//find the initial database record that matches the criteria above

if(printScriptTags)
	{
	printf("\n<script type=\"text/javascript\">\n");
	}

printf("var inboxMsgsFromDB=[\n");				//begin constructing an array that will be used by YUI recordset to instantiate a recordset object...

while( status > 0 						//while there are database records that match our criteria (we know there should be at least one, so our structure should turn out syntactically correct)...
	&& i < FAVS_MAXRECORDSTOSHOW_INBOX
	&& !strcmp(db_bann->res_id, res_id) 
	&& !strcmp(db_bann->dbb_pin, CurrentUserPin)
	&& !strcmp(db_bann->dbb_msg_status, bb_valid_status[BBS_ACTIVE]) 
	/*&& !strcmp(db_bann->dbb_read_flag, BANN_READ)*/ )
	{

	/* need to decode the message */
	lm_decode_initialize(); //NOTE: do we need this? (probably, but decoding DOES seem to work without it)
	cgi_decode(db_bann_getcur(), LM_ANSWER, message, sizeof(message), color, sizeof(color), font, sizeof(font), mode, sizeof(mode), auto_addr, TRUE);

	/* construct name (from user pin) of the person who launched the message */
	cgi_fillin_name_from_pin(db_bann->dbb_launch_pin, from_first_name, from_last_name, courtesy_name);

	/* The following constructs a JavaScript object-literal (called inboxMsgsFromDB) that will then be used by the client's YUI logic to build a YUI recordset object.
	 * By doing it that way, the client should have more autonomous control over the data for adding, sorting, etc. - all without constant calls back to the server, hammering the database, etc.
	 * Syntax-Note: each 'column' in the recordset is allowed/given a custom name (e.g. icon, label1, label2, etc.), followed by the data itself -- since this is an object-literal, the field/key names don't need to be strings */
	if( i > 0 ) printf(",\n");				//a comma is needed between records, so print one before each record (after the first one) ... the new-line
	printf("{");
	printf("recno_inbox:\""FORMAT_DBRECORD_STR"\",", db_bann_getcur());
	printf("recno_msgtemplate:\""FORMAT_DBRECORD_STR"\",", db_bann->dbb_parent_record);
	printf("dtsec_nines:\"%s\",", db_bann->dbb_rec_dtsec_nines);
	printf("from_pin:\"%s\",", db_bann->dbb_launch_pin);
	printf("from_fullname:\"%s %s\",", from_first_name, from_last_name);
	printf("senders_note:\"%s\",", bann_sender_note);
	printf("msgname:\"%s\",", getBannerMessageNameForRecord(db_bann->dbb_parent_record));
	printf("msgdir:\"%s\",", getBannerDirectoryNameForRecord(db_bann->dbb_parent_record));
	printf("reply_dir_name:\"%s\",", getBannerMessageOptionsDataForRecord_replyDirectory(db_bann->dbb_parent_record));
	printf("reply_msg_name:\"%s\",", getBannerMessageOptionsDataForRecord_replyMessage(db_bann->dbb_parent_record));
	printf("alt_reply_dir:\"%s\",", getBannerMessageOptionsDataForRecord_altReplyDirectory(db_bann->dbb_parent_record));
	printf("message:\"%s\"", message);
	/******* IMPORTANT NOTE: If you add/modify/remove any fields here, you should make sure the corresponding logic in smcgi.c is also updated accordingly ******************/
	printf("}");

	i++;

	status = db_bann_next();
	}//end while

printf("\n];\n");//end data scructure

if(printScriptTags)
	{
	printf("</script>\n");
	}
}


/***********************************************************************
* void add_favSupport_recordset(void)
*
* 	Supporting JavaScript functions for YUI RecordSet stuff.
* 	These should all only focus on doing stuff with the client-loaded recordset object... sorting, filtering, getting field data, etc.
*
* 	List of JavaScript functions and what they return/do:
*
* 	bool	rs_isValidArg_yuiRecordsetObject	( obj objRS )					Returns whether argument is a valid YUI Recordset object or not
* 	bool	rs_isValidArg_favRecno			( str|int recno )				Returns whether argument is a valid YUI Recordset key for a favorite record number
* 	bool	rs_isValidArg_string			( str str, [str|int maxlength] )		Returns whether argument is a valid string. Optionally, can also check that it meets the maxlength specification.
*	bool	rs_isValidResult_getValuesByKey		( arr arrValues )				Returns whether argument (which should be an array created by YUI's "getValuesByKey" method) contains valid data... basically checks whether that method yielded something or not.
*
*
***********************************************************************/
void add_favSupport_recordset(void)
{
printf("<script type=\"text/javascript\">\n");

printf("function rs_isValidArg_yuiRecordsetObject(objRS){");					// Check the supplied argument to see whether it's a valid YUI Recordset object or not... returns true if valid, and false if invalid
printf("	if(typeof objRS===\"object\" && objRS.name===\"recordset\"){");
printf("		return true;");
printf("	}else if(eval(objRS)===\"object\" && eval(objRS).name===\"recordset\"){");
printf("		FavScreen.log('error', \"rs_isValidArg_yuiRecordsetObject(): Specified YUI recordset seems to be passed-in as a string. Convert the argument, first? Returning false.\", true);");
printf("		return false;");
printf("	}else{");
printf("		FavScreen.log('error', \"rs_isValidArg_yuiRecordsetObject(); Specified YUI recordset not valid. Returning false.\", true);");
printf("		return false;");
printf("	}");
printf("}\n");
printf("function rs_isValidArg_favRecno(recno){");						// Check the supplied argument to see whether it's a valid and propertly formatted representation of a YUI Recordset key value for fav-recno or not... returns true if valid, and false if invalid
printf("	if(isNaN(recno)){");
printf("		FavScreen.log('error', \"rs_isValidArg_favRecno(): Specified %s-recno (\"+recno+\") is not a number. Returning false.\", true);", FAVS_NAME_SINGULAR);
printf("		return false;");
printf("	}");
printf("	else if(typeof recno===\"string\" && recno.length>0){");
printf("		return true;");
printf("	}");
printf("	else{");
printf("		FavScreen.log('warn', \"rs_isValidArg_favRecno(): Specified %s-recno (\"+recno+\") might not be a valid type (\"+typeof recno+\"). It should be a 'string'-representation of a number. Returning false.\", true);", FAVS_NAME_SINGULAR);
printf("		return false;");
printf("	}");
printf("}\n");
printf("function rs_isValidArg_integer(int){");							// Check the supplied argument to see whether it's a valid integer number
printf("	if(typeof int===\"number\"){");
printf("		return true;");
printf("	}");
printf("	else if(typeof int===\"string\" && isNaN(int)==false){");
printf("		FavScreen.log('warn', \"rs_isValidArg_integer(): Specified value (\"+int+\") is a string that represents a number value. This might be okay. Returning true.\", true);");
printf("		return true;");
printf("	}");
printf("	else if(isNaN(int)){");									//if the value represents a number somehow
printf("		FavScreen.log('error', \"rs_isValidArg_integer(): Specified value (\"+int+\") is not a number. Returning false.\", true);");
printf("		return false;");
printf("	}else{");										//else some value does actually exist
printf("		FavScreen.log('error', \"rs_isValidArg_integer(): Specified value (\"+int+\") type (\"+typeof int+\") can not currently be handled. Returning false.\", true);");
printf("		return false;");
printf("	}");
printf("}\n");
printf("function rs_isValidArg_string(str,maxlength){");					// Check the supplied argument to see whether it's a valid (and optionally, correct length) string
printf("	if(typeof str===\"undefined\"){");							//if a valid argument wasn't supplied, then don't allow this function to continue
printf("		FavScreen.log('error', \"rs_isValidArg_string(): A string must be specified.\", true);");
printf("		return false;");
printf("	}");
printf("	else if(typeof str===\"string\"){");							//if the string argument is of a string type, continue...
printf("		if(typeof maxlength===\"undefined\" || isNaN(maxlength)){");			//if a maximum length was not specified for us to check
printf("			FavScreen.log('info', \"rs_isValidArg_string(): maxlength not provided or is NaN... validating for string type only. This might be okay. Returning true.\", true);");
printf("			return true;");
printf("		}else{");
printf("			if(str.length>parseInt(maxlength)){");
printf("				FavScreen.log('error', \"rs_isValidArg_string(): Specified string (\"+str+\") is longer than allowed (\"+maxlength+\"). Returning false.\", true);");
printf("				return false;");
printf("			}else{");
printf("				return true;");
printf("			}");
printf("		}");
printf("	}else{");
printf("		FavScreen.log('error', \"rs_isValidArg_string(): Valid string-type argument must be provided (type = \"+typeof str+\"). Returning false.\", true);");
printf("		return false;");
printf("	}");
printf("}\n");
printf("function rs_isValidResult_getValuesByKey(arrValues){");					// Check an array that's returned from YUI-Recordset method getValuesByKey for valid values
printf("	if(typeof arrValues === 'undefined') {");
printf("		FavScreen.log('error', \"rs_isValidResult_getValuesByKey(): Required argument missing. Returning false.\", true);");
printf("		return false;");
printf("	}");
printf("	if(arrValues.length == 0){");
printf("		FavScreen.log('info', \"rs_isValidResult_getValuesByKey(): Result of YUI-Recordset:getValuesByKey() returns no results. Probably, an empty array was provided to that method. Returning false.\", true);");
printf("		return false;");
printf("	}else if(typeof arrValues[0]===\"undefined\"){");						//make sure the key actually exists in the recordset (getValuesByKey returns an array of undefined items if the key didn't exist in the recordset)... just checking first element should suffice? (unless the first record legitamately has an undefined value for the key)
printf("		FavScreen.log('warn', \"rs_isValidResult_getValuesByKey(): Result of YUI-Recordset:getValuesByKey() was undefined. Most likely, an invalid key was provided to that method. Returning false.\", true);");
printf("		return false;");
printf("	}else{");										//else some value does actually exist
printf("		return true;");
printf("	}");
printf("}\n");

/* DEV-NOTE: doesn't seem to work, nor does it seem to be used anywhere -- commenting out for now (2014.09.29)
printf("function rs_getRecordsetOf(objRsToFilter,strFieldName,strValue){");			// Return a recordset object of record(s) matching the field and value specified for the given recordset
printf("	if(typeof objRsToFilter==='undefined'){");						//if the recordset isn't defined, then don't allow this function to continue
printf("		FavScreen.log('error', \"Calling the function rs_getRecordsetOf() requires that the specified recordset be instantiated, first.\", true);");
printf("		return false;");
printf("	}");//end if
printf("	if(typeof strFieldName===\"undefined\" || typeof strValue===\"undefined\"){");	//if arguments weren't supplied, then don't allow this function to continue
printf("		FavScreen.log('error', \"Calling the function rs_getRecordSetOf() requires all arguments to be supplied (strFieldName = '\"+strFieldName+\"', strValue = '\"+strValue+\"').\", true);");
printf("		return false;");
printf("	}");//end if
printf("	return objRsToFilter.filter.filter(strFieldName.toString(), strValue.toString());");	//return a recordset object containing record(s) that match the given arguments (we use toString method, just to be extra safe that we're passing actual strings to the filter method)
printf("}\n");//end function
*/
printf("function rs_getRecordsetOf_positionTypeFlag(objRsToFilter,strPosTypeFlag){");		// Return a recordset object of record(s) matching the position type flag specified
printf("	if(typeof objRsToFilter==='undefined'){");						//if the recordset isn't defined, then don't allow this function to continue
printf("		FavScreen.log('error', \"rs_getRecordsetOf_positionTypeFlag(): Specified recordset must be instantiated, first. Returning false.\", true);");
printf("		return false;");
printf("	}");//end if
printf("	if(typeof strPosTypeFlag==='undefined'){");						//if arguments weren't supplied, then don't allow this function to continue
printf("		FavScreen.log('error', \"rs_getRecordSetOf_positionTypeFlag(): strPosTypeFlag arg undefined. Returning false.\", true);");
printf("		return false;");
printf("	}");//end if
printf("	var cfg_positionKeyName = 'position';");						//configure what the name of the recordset field/key name is that stores our position type flag (NOTE: this likely won't ever change, but just trying to make the code as modular as possible)
printf("	var fnFilter = function(record){");							//create a custom filter function that will be passed to the filter plugin
printf("		var positionFirstChar = record.getValue(cfg_positionKeyName).charAt(0);");	//data should look something like "U:00000,00000,00000"..  so the character at position 0 should be the letter-code we're looking for
printf("		if(positionFirstChar===strPosTypeFlag.toString()){return true;}");
printf("		else{return false;}");
printf("		};");
printf("	var retRs = objRsToFilter.filter.filter(fnFilter);");
printf("	YUI().use('recordset-base', 'recordset-filter', 'recordset-sort', function(Y){");	//the filter plugin doesn't return any of the source recordset's plugins, so we need to plut them back in manually...  DEV-NOTE: make this more intelligent later?
printf("		retRs.plug(Y.Plugin.RecordsetFilter);");					//plug-in the filter stuff (access its stuff from the .filter namespace)
printf("		retRs.plug(Y.Plugin.RecordsetSort);");						//plug-in the sort stuff (access its stuff from the .sort namespace)
printf("		});");
printf("	return retRs;");
printf("}\n");//end function
printf("function rs_getRecordsetOf_favsWithActiveCopies(objRsToFilter){");			// Return a recordset object of record(s) that have active-copy-recnos
printf("	if(typeof objRsToFilter==='undefined'){");						//if the recordset isn't defined, then don't allow this function to continue
printf("		FavScreen.log('error', \"rs_getRecordsetOf_favsWithActiveCopies(): Specified recordset must be instantiated, first. Returning false.\", true);");
printf("		return false;");
printf("	}");//end if
printf("	var cfg_activeCopiesKeyName = 'active_copies';");					//configure what the name of the recordset field/key name is that stores our active-copy recnos (NOTE: this likely won't ever change, but just trying to make the code as modular as possible)
printf("	var fnFilter = function(record){");							//create a custom filter function that will be passed to the filter plugin
printf("		var strLen = record.getValue(cfg_activeCopiesKeyName).toString().length;");	//desired data should look something like "123,456," --- don't care about empty strings ("")
printf("		if(strLen>0){return true;}");
printf("		else{return false;}");
printf("		};");
printf("	var retRs = objRsToFilter.filter.filter(fnFilter);");
printf("	YUI().use('recordset-base', 'recordset-filter', 'recordset-sort', function(Y){");	//the filter plugin doesn't return any of the source recordset's plugins, so we need to plut them back in manually...  DEV-NOTE: make this more intelligent later?
printf("		retRs.plug(Y.Plugin.RecordsetFilter);");					//plug-in the filter stuff (access its stuff from the .filter namespace)
//printf("		retRs.plug(Y.Plugin.RecordsetSort);");						//plug-in the sort stuff (access its stuff from the .sort namespace)
printf("		});");
printf("	return retRs;");
printf("}\n");//end function

// Sort the recordset (passed by reference, so modifies the order of the original RS provided)... rs_sortRecordset( object YUI-RecordSet, string favsFromDB-field-name, ['asc' | 'desc'] )
// 	Example- sort deleted recordset by dtsec, latest at beginning:		rs_sortRecordset(FavScreen.rsOrig_deleted, "dtsec", "desc")
// 	Example- sort sorted recordset by favorite name, alphabetically:	rs_sortRecordset(FavScreen.rsOrig_sorted, "label1", "asc")
printf("function rs_sortRecordset(objRS,strSortFld,strSortOrder){");
printf("	var ret = false;");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(typeof strSortFld==='undefined'){");
printf("		FavScreen.log('error', \"rs_sortRecordset(): Recordset field-name to sort by must be specified. Aborting.\", true);");
printf("		return ret;");
printf("	}");
printf("	if(objRS.size()==0){");
printf("		FavScreen.log('verbose', \"rs_sortRecordset(): Recordset empty. Nothing to sort.\", false);");
printf("		return ret;");
printf("	}");
printf("	if(typeof objRS.getValuesByKey(strSortFld)[0]==='undefined'){");
printf("		FavScreen.log('warn', \"rs_sortRecordset(): Valid recordset field-name to sort by must be specified ('\"+strSortFld+\"'). Sort operation may not have succeeded?\", true);");
printf("	}");
printf("	if(typeof strSortOrder==='undefined' || (strSortOrder != \"asc\" && strSortOrder != \"desc\")){");
printf("		FavScreen.log('error', \"rs_sortRecordset(): Valid sort-order ('asc' or 'desc') must be specified (specified value was '\"+strSortOrder+\"'). Aborting.\", true);");
printf("		return ret;");
printf("	}");
printf("	if(strSortOrder==\"asc\"){strSortOrder = false;}");
printf("	else if(strSortOrder==\"desc\"){strSortOrder = true;}");
printf("	else{");
printf("		FavScreen.log('error', \"rs_sortRecordset(): Valid sort-order ('asc' or 'desc') must be specified. Aborting.\", true);");
printf("		return ret;");
printf("	}");
printf("	if(typeof objRS.sort===\"undefined\"){");						//if the sort plugin isn't in the source recordset
printf("		FavScreen.log('error', \"rs_sortRecordset(): Cannot find the 'sort' plugin in the specified recordset. Aborting.\", true);");
printf("		return ret;");
printf("	}");
printf("	else{");
printf("		objRS.sort.sort(strSortFld, strSortOrder);");					//apply the sort to the original recordset referenced in this function's parameter (JavaScript is always pass-by-value, except in cases where we modify the internals of an object) (note: sort() doesn't return anything, nor does the sort plugin have any event listeners, so we cannot test for successful completion or not)
printf("	}");
printf("}\n");
//printf("function rs_doAllDefaultSorting(){");							// Do all of our default desired sorting
//printf("	FavScreen.log('log', \"Function rs_doAllDefaultSorting() called.\", true);");
//printf("	rs_sortRecordset(FavScreen.rsOrig_sorted, \"position\", \"asc\");");			//sort unsorted so that the most recent one is first
//printf("	rs_sortRecordset(FavScreen.rsOrig_unsorted, \"dtsec\", \"desc\");");			//sort unsorted so that the most recent one is first
//printf("	rs_sortRecordset(FavScreen.rsOrig_deleted, \"dtsec\", \"desc\");");			//sort deleted so that the most recent one is first
//printf("}\n");

/* Extract records from the specified recordset (passed by reference) into related sub-recordsets */
printf("function rs_extractRecordsToRecordsets(strRsName){");
printf("	if(typeof strRsName==='undefined'){");
printf("		FavScreen.log('error', \"rs_extractRecordsToRecordsets(): Name of source recordset must be supplied. Returning false.\", true);");
printf("		return false;");
printf("	}");
printf("	var theRs = eval(strRsName);");											//try to convert the string that represents a recordset object into an actual recordset object
printf("	if(typeof theRs==='undefined'){");										//then see whether that really is an actual recordset object (DEV-NOTE: upgrade to check for that, rather than just undefined?)
printf("		FavScreen.log('error', \"rs_extractRecordsToRecordsets(): Name of valid source recordset must be supplied. '\"+strRsName+\"' refers to an undefined asset. Returning false.\", true);");
printf("		return false;");
printf("	}");
printf("	if(theRs.name != \"recordset\"){");
printf("		FavScreen.log('error', \"rs_extractRecordsToRecordsets(): Name of valid YUI recordset must be supplied. '\"+strRsName+\"' refers to '\"+theRs.name+\"'.\", true);");
printf("		return false;");
printf("	}");
printf("	var strSubRs = strRsName+\"_sorted\";");									//construct a string that will become the name of the sub-recordset object for sorted records
printf("	 tmpCmdStr = strSubRs+\" = rs_getRecordsetOf_positionTypeFlag(\"+strRsName+\",'%s')\";", FAVS_SORTED_FLAG);	//construct command to get sub-recordset of all records that have a position type flag for sorted
printf("	 eval(tmpCmdStr);");												//execute that command, to actually get the sub-recordset
printf("	 rs_sortRecordset(eval(strSubRs), \"position\", \"asc\");");							//re-order the sorted recordset, so that they are ordered correctly
printf("	strSubRs = strRsName+\"_unsorted\";");										//construct a string that will become the name of the sub-recordset object for unsorted records
printf("	 tmpCmdStr = strSubRs+\" = rs_getRecordsetOf_positionTypeFlag(\"+strRsName+\",'%s')\";", FAVS_UNSORTED_FLAG);	//construct command to get sub-recordset of all records that have a position type flag for unsorted
printf("	 eval(tmpCmdStr);");												//execute that command, to actually get the sub-recordset
printf("	 rs_sortRecordset(eval(strSubRs), \"dtsec\", \"desc\");");							//re-order the unsorted recordset, so that the most recent are at the top
printf("	strSubRs = strRsName+\"_deleted\";");										//construct a string that will become the name of the sub-recordset object for deleted records
printf("	 tmpCmdStr = strSubRs+\" = rs_getRecordsetOf_positionTypeFlag(\"+strRsName+\",'%s')\";", FAVS_DELETED_FLAG);	//construct command to get sub-recordset of all records that have a position type flag for deleted
printf("	 eval(tmpCmdStr);");												//execute that command, to actually get the sub-recordset
printf("	 rs_sortRecordset(eval(strSubRs), \"dtsec\", \"desc\");");							//re-order the deleted recordset, so that the most recent are at the top
printf("	strSubRs = strRsName+\"_libraries\";");										//construct a string that will become the name of the sub-recordset object for library records
printf("	 tmpCmdStr = strSubRs+\" = rs_getRecordsetOf_positionTypeFlag(\"+strRsName+\",'%s')\";", FAVS_LIBRARY_FLAG);	//construct command to get sub-recordset of all records that have a position type flag for library
printf("	 eval(tmpCmdStr);");												//execute that command, to actually get the sub-recordset
printf("	 rs_sortRecordset(eval(strSubRs), \"position\", \"asc\");");							//re-order the sorted recordset, so that they are ordered correctly
printf("	strSubRs = strRsName+\"_personalLibs\";");									//construct a string that will become the name of the sub-recordset object for personal-library records
printf("	 tmpCmdStr = strSubRs+\" = rs_getRecordsetOf_positionTypeFlag(\"+strRsName+\",'%s')\";", FAVS_LIBRARY_PERSONAL_FLAG);//construct command to get sub-recordset of all records that have a position type flag for personal-library
printf("	 eval(tmpCmdStr);");												//execute that command, to actually get the sub-recordset
printf("	 rs_sortRecordset(eval(strSubRs), \"position\", \"asc\");");							//re-order the sorted recordset, so that they are ordered correctly
printf("}\n");//end function

printf("function rs_getIndexOfFavMsgRecord(arrFavMsgRecnos, favRecnoToFind){");			// Return the array index of the specified favorite recno in the specified favorite recno array
printf("	if(typeof arrFavMsgRecnos===\"undefined\"){");
printf("		FavScreen.log('error', \"rs_getIndexOfFavMsgRecord(): Valid array arg required. Returning -1.\", true);");
printf("		return -1;");
printf("	}");
printf("	if(!rs_isValidArg_favRecno(favRecnoToFind)){return false;}");				//validate argument
printf("	for(var i=0; i<arrFavMsgRecnos.length; i++){");		
printf("		if(parseInt(arrFavMsgRecnos[i])==parseInt(favRecnoToFind)){");			//when we come across the record for the specified fav-msg (provided as this function's argument)...
printf("			return i;");								//return the corresponding record position in the array
printf("		}");//end if
printf("	}");//end for
printf("	return -1;");										//if function has gotten to this point, then the loop/if didn't return anything
printf("}\n");
printf("function rs_getIndexOfFavMsgRecord_byMsgTemplateRecno(arrMsgRecnos, recnoToFind){");// Return the array index of the specified message template recno in the specified recno array
printf("	if(typeof arrMsgRecnos===\"undefined\"){");
printf("		FavScreen.log('error', \"rs_getIndexOfFavMsgRecord_byMsgTemplateRecno(): Valid array arg required. Returning -1.\", true);");
printf("		return -1;");
printf("	}");
//printf("	if(!rs_isValidArg_favRecno(favRecnoToFind)){return false;}");				//validate argument
printf("	for(var i=0; i<arrMsgRecnos.length; i++){");		
printf("		if(parseInt(arrMsgRecnos[i])==parseInt(recnoToFind)){");			//when we come across the record for the specified recno (provided as this function's argument)...
printf("			return i;");								//return the corresponding record position in the array
printf("		}");//end if
printf("	}");//end for
printf("	return -1;");										//if function has gotten to this point, then the loop/if didn't return anything
printf("}\n");

printf("function rsRec_getMsgTemplateRecno(objRS, favRecno){");					// Return the recno of the actual message template that this favorite-msg points to...
printf("	var ret = 0;");										//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrMsgTempRecnos = objRS.getValuesByKey('recno_msgtemplate');");			//get an array of message template record numbers from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrMsgTempRecnos)){return ret;}");			//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrMsgTempRecnos[i];}");							//if we got a valid index-position, use it to lookup the favorite-record's message-template recno
printf("	return ret;");										//return the message template recno that we found in the loop above (or 0 if no match was found)
printf("}\n");
printf("function rsRec_getFavName(objRS, favRecno){");						// Return the specified favorite's name (label1)
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgLabel1s = objRS.getValuesByKey('label1');");				//get an array of favorite-label1's from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgLabel1s)){return ret;}");			//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrFavMsgLabel1s[i];}");							//if we got a valid index-position, use it to lookup the favorite-record's label1
printf("	return ret;");										//return the favorite's name that we found in the loop above (or "" if no match was found)
printf("}\n");
printf("function rsRec_getFavDescription(objRS, favRecno){");					// Return the specified favorite's description (label2)
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgLabel2s = objRS.getValuesByKey('label2');");				//get an array of favorite-label2's from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgLabel2s)){return ret;}");			//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrFavMsgLabel2s[i];}");							//if we got a valid index-position, use it to lookup the favorite-record's label2
printf("	return ret;");										//return the favorite's description that we found in the loop above (or "" if no match was found)
printf("}\n");
printf("function rsRec_getFavPosition(objRS, favRecno){");					// Return the specified favorite's position in the list/grid/etc.
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgPositions = objRS.getValuesByKey('position');");				//get an array of favorite-positions from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgPositions)){return ret;}");		//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrFavMsgPositions[i];}");						//if we got a valid index-position, use it to lookup the favorite-record's position
printf("	return ret;");										//return the favorite's position that we found (or "" if no match was found)
printf("}\n");
printf("function rsRec_getFavPositionTypeFlag(objRS, favRecno){");				// Return the specified favorite's position type flag (e.g. sorted, unsorted, deleted, etc.)
printf("	var ret = \"\";");									//initialize a string variable
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgPositions = objRS.getValuesByKey('position');");				//get an array of favorite-positions from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgPositions)){return ret;}");		//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){");										//if we got a valid index-position, use it to lookup the favorite-record's position... then figure out what part of it to return
printf("		ret = arrFavMsgPositions[i];");							//raw position data (e.g. "S:00002,00000,00000" )
printf("		if(ret==\"false\" || ret==\"undefined\" || ret==false || ret==undefined){");	//if there is trash data for some reason (such that .split will not work), make sure we avoid that error and still return some kind of valid value...
printf("			return \"%s\";", FAVS_ERROR_FLAG);					//return a value reflecting an error state
printf("		}");
printf("		else{");									//else it should hopefully be valid to run .split on
printf("			ret = ret.split(':');");						//should now have an array like this, for example: ret[0]="S" and ret[1]="00002,00000,00000"
printf("			return ret[0];");							//return the favorite's position type flag that we found, for example: "S"
printf("		}");
printf("	}");
printf("}\n");
printf("function rsRec_getFavIcon(objRS, favRecno){");						// Return the specified favorite's icon filename
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgIcons = objRS.getValuesByKey('icon');");					//get an array of favorite-icons from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgIcons)){return ret;}");			//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrFavMsgIcons[i];}");							//if we got a valid index-position, use it to lookup the favorite-record's icon filename
printf("	if(ret===\"\"){");									//if no user-specified or explicitly-defined icon... figure out what icon to show
printf("		switch(rsRec_getFavPositionTypeFlag(objRS, favRecno)) {");
printf("			case \"%s\":", FAVS_SORTED_FLAG);					//if no user-chosen icon for sorted (aka 'critical') messages
printf("				ret = \"%s\";", FAVS_DEFAULT_SORTED_ICON_FILE);
printf("				break;");//exit switch construct
printf("			case \"%s\":", FAVS_UNSORTED_FLAG);					//if no user-chosen icon for unsorted messages
printf("			case \"%s\":", FAVS_LIBRARY_FLAG);					//if no user-chosen icon for shared-library messages
printf("				ret = \"%s\";", FAVS_DEFAULT_UNSORTED_ICON_FILE);
printf("				break;");//exit switch construct
printf("			default:");
printf("				ret = \"%s\";", FAVS_ICON_DEFAULT);
printf("				break;");//exit switch construct
printf("		}");//end switch
printf("	}");
printf("	return ret;");										//return the favorite's icon filename that we found (or one of the default/fallback icons)
printf("}\n");
/*NEED TO FINISH THIS WHEN DOING 2nd ICON FEATURE...
printf("function rsRec_getFavIcon2(objRS, favRecno){");						// Return the specified favorite's secondary icon filename
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgIcons = objRS.getValuesByKey('icon2');");					//get an array of secondary favorite-icons from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgIcons)){return ret;}");			//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrFavMsgIcons[i];}");							//if we got a valid index-position, use it to lookup the favorite-record's icon filename
printf("	if(ret===\"\"){");									//if no user-specified or explicitly-defined icon... figure out what icon to show
printf("		if(rsRec_getFavPositionTypeFlag(objRS, favRecno)==\"%s\"){", FAVS_UNSORTED_FLAG);//if this is a new/unsorted favorite
printf("			ret = \"%s\";", FAVS_DEFAULT_UNSORTED_ICON_FILE);			//return the defined default unsorted favorite icon filename (if they haven't chosen an icon for an unsorted message)
printf("		}");
printf("		else if(rsRec_getFavPositionTypeFlag(objRS, favRecno)==\"%s\"){", FAVS_SORTED_FLAG);
printf("			ret = \"%s\";", FAVS_DEFAULT_SORTED_ICON_FILE);				//return the defined default sorted favorite icon filename (if they haven't chosen an icon for a sorted message)
printf("		}");
printf("		else{");									//else (no good reason this should ever happen) specify a backup-icon of some sort
printf("			ret = \"%s\";", FAVS_ICON_DEFAULT);
printf("		}");
printf("	}");
printf("	return ret;");										//return the favorite's icon filename that we found (or one of the default/fallback icons)
printf("}\n");
*/
printf("function rsRec_getFavRecno_byMsgTemplateRecno(objRS, msgTemplateRecno){");		// Return the record number of the favorite, specified by its message template recno
printf("	var ret = false;");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(msgTemplateRecno)){return ret;}");				//validate argument
printf("	var arrFavMsgRecnos;");
printf("	function doSearch(oRS){");								//define a routine to populate a list of fav-recnos available, and return which index should be the one we want for the provided recno
printf("		var arrMsgTemplateRecnos = oRS.getValuesByKey('recno_msgtemplate');");			//get an array of favorite-messages' messate-template record numbers from the recordset
printf("		if(!rs_isValidResult_getValuesByKey(arrMsgTemplateRecnos)){return ret;}");		//validate that array
printf("		arrFavMsgRecnos = oRS.getValuesByKey('recno_fav');");					//get an array of favorite-recnos from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("		if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("		return rs_getIndexOfFavMsgRecord_byMsgTemplateRecno(arrMsgTemplateRecnos,msgTemplateRecno);");//figure out the index-position of the msg-template recno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	}");
printf("	var i = doSearch(objRS);");								//first, try with the recordset specified to the function
printf("	if(i>-1){ret = arrFavMsgRecnos[i];}");							//if we got a valid index-position, use it to lookup the favorite-record's record number
printf("	else{");										//else we did not get a valid index-position, so fall-back to try looking in other available recordsets
printf("		FavScreen.log('warn',\"rsRec_getFavRecno_byMsgTemplateRecno(): No fav-recno found matching msg-template-recno \"+msgTemplateRecno+\".\",true);");
printf("		return ret;");
printf("	}");
printf("	return ret;");										//return the favorite's icon filename that we found (or one of the default/fallback icons)
printf("}\n");
printf("function rsRec_getFavIcon_byMsgTemplateRecno(objRS, msgTemplateRecno){");		// Return the icon filename of the favorite, specified by its message template recno (NOTE: this may not result in anything if user has no mobilized version of the msg-template or it's not in a library)
printf("	var ret = false;");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(msgTemplateRecno)){return ret;}");				//validate argument (should just be able to reuse favRecno check routine, as they're the same data-type)
printf("	var arrFavMsgIcons;");									//initialize an array to potentially hold the fav-msg icon names
printf("	function doSearch(oRS){");								//define a routine to populate a list of icon filenames available, and return which index should be the one we want for the provided recno
printf("		var arrMsgTemplateRecnos = oRS.getValuesByKey('recno_msgtemplate');");			//get an array of favorite-messages' messate-template record numbers from the recordset
printf("		if(!rs_isValidResult_getValuesByKey(arrMsgTemplateRecnos)){return ret;}");		//validate that array
printf("		arrFavMsgIcons = oRS.getValuesByKey('icon');");						//get an array of favorite-icons from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("		if(!rs_isValidResult_getValuesByKey(arrFavMsgIcons)){return ret;}");			//validate that array
printf("		return rs_getIndexOfFavMsgRecord_byMsgTemplateRecno(arrMsgTemplateRecnos,msgTemplateRecno);");//figure out the index-position of the msg-template recno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	}");
printf("	var i = doSearch(objRS);");								//first, try with the recordset specified to the function
printf("	if(i>-1){ret = arrFavMsgIcons[i];}");							//if we got a valid index-position, use it to lookup the favorite-record's icon filename
printf("	else{");										//else we did not get a valid index-position from the arg-specified recordset, so fall-back to try looking in other available recordsets just to be safe that there likely aren't any icons
printf("		try{");
printf("			for(var j=0; j<FavScreen.objLibsMsgs.length; j++){");				//first, try looking in each of the libraries' recordsets... return icon if found, otherwise just allow continuance to the end with default return value
printf("				i = doSearch(FavScreen.objLibsMsgs[j].rsLibMsgs);");
printf("				if(i!==false && i>-1){return arrFavMsgIcons[i];}");
printf("			}");
				//DEV-NOTE: add any other recordset searches here
printf("		}catch(err){");
printf("			FavScreen.log('info',\"rsRec_getFavIcon_byMsgTemplateRecno(): Caught issue looking in other available data/record-sets (\"+err+\"). This may just mean there aren't any icon filenames available for the msg template specified.\",true);");
printf("			return ret;");
printf("		}");//end try-catch
printf("	}");
printf("	return ret;");										//return the favorite's icon filename that we found (or one of the default/fallback icons)
printf("}\n");
printf("function rsRec_getMsgTemplateName_inbox(objRS, favRecno){");				// Return the specified favorite's template message name
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_inbox');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgMsgNames = objRS.getValuesByKey('msgname');");				//get an array of favorite-msgnames from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgMsgNames)){return ret;}");			//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
//printf("	if(i>-1){ret = arrFavMsgMsgNames[i];}");						//if we got a valid index-position, use it to lookup the favorite-record's message-template name
printf("	if(i>-1){ret = arrFavMsgMsgNames[i].trim();}");						//if we got a valid index-position, use it to lookup the favorite-record's message-template name
printf("	return ret;");										//return the message template name that we found (or "" if no match was found)
printf("}\n");
printf("function rsRec_getMsgTemplateDir_inbox(objRS, favRecno){");				// Return the specified favorite's template message directory
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_inbox');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgMsgDirs = objRS.getValuesByKey('msgdir');");				//get an array of favorite-msgdirs from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgMsgDirs)){return ret;}");			//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrFavMsgMsgDirs[i];}");							//if we got a valid index-position, use it to lookup the favorite-record's message-template directory
printf("	return ret;");										//return the message template directory that we found (or "" if no match was found)
printf("}\n");
printf("function rsRec_getMsgTemplateName(objRS, favRecno){");					// Return the specified favorite's template message name
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgMsgNames = objRS.getValuesByKey('msgname');");				//get an array of favorite-msgnames from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgMsgNames)){return ret;}");			//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
//printf("	if(i>-1){ret = arrFavMsgMsgNames[i];}");						//if we got a valid index-position, use it to lookup the favorite-record's message-template name
printf("	if(i>-1){ret = arrFavMsgMsgNames[i].trim();}");						//if we got a valid index-position, use it to lookup the favorite-record's message-template name
printf("	return ret;");										//return the message template name that we found (or "" if no match was found)
printf("}\n");
printf("function rsRec_getMsgTemplateDir(objRS, favRecno){");					// Return the specified favorite's template message directory
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgMsgDirs = objRS.getValuesByKey('msgdir');");				//get an array of favorite-msgdirs from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgMsgDirs)){return ret;}");			//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrFavMsgMsgDirs[i];}");							//if we got a valid index-position, use it to lookup the favorite-record's message-template directory
printf("	return ret;");										//return the message template directory that we found (or "" if no match was found)
printf("}\n");
printf("function rsRec_getMsgTemplateDesc(objRS, favRecno){");					// Return the specified favorite's template message description (NOTE: this is not favorite descriptions, but rather the original message-templates' descriptions)
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgMsgDescriptions = objRS.getValuesByKey('msgdesc');");			//get an array of favorite-msgdesc from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgMsgDescriptions)){return ret;}");		//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrFavMsgMsgDescriptions[i].trim();}");					//if we got a valid index-position, use it to lookup the favorite-record's message-template directory.. be sure to trim off the whitespace around the string, since we likely won't need it
printf("	return ret;");										//return the message template directory that we found (or "" if no match was found)
printf("}\n");

printf("function rsRec_getMsgTemplateAltReplyDirName(objRS, recno){");				// Return the specified record's template-message's alt-reply-directory (NOTE: initially made for getting from rsInbox)
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(recno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_inbox');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrWithDataWeWant = objRS.getValuesByKey('alt_reply_dir');");			//get an array of alt-reply-directories from the recordset (for all recordset-messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrWithDataWeWant)){return ret;}");			//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,recno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrWithDataWeWant[i];}");						//if we got a valid index-position, use it to lookup the favorite-record's message-template alt-reply-dir
printf("	return ret;");										//return the message template name that we found (or "" if no match was found)
printf("}\n");
printf("function rsRec_getMsgTemplateReplyDirName(objRS, recno){");				// Return the specified record's template-message's reply-directory (NOTE: initially made for getting from rsInbox)
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(recno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_inbox');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrWithDataWeWant = objRS.getValuesByKey('reply_dir_name');");			//get an array of alt-reply-directories from the recordset (for all recordset-messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrWithDataWeWant)){return ret;}");			//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,recno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrWithDataWeWant[i];}");						//if we got a valid index-position, use it to lookup the favorite-record's message-template alt-reply-dir
printf("	return ret;");										//return the message template name that we found (or "" if no match was found)
printf("}\n");
printf("function rsRec_getMsgTemplateReplyMsgName(objRS, recno){");				// Return the specified record's template-message's reply-message-name (NOTE: initially made for getting from rsInbox)
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(recno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_inbox');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrWithDataWeWant = objRS.getValuesByKey('reply_msg_name');");			//get an array of alt-reply-directories from the recordset (for all recordset-messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrWithDataWeWant)){return ret;}");			//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,recno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrWithDataWeWant[i];}");						//if we got a valid index-position, use it to lookup the favorite-record's message-template alt-reply-dir
printf("	return ret;");										//return the message template name that we found (or "" if no match was found)
printf("}\n");

printf("function rsRec_getConfirmSend(objRS, favRecno){");					// Return the specified favorite's confirmSend encoding
printf("	var ret = -1;");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgConfirmSend = objRS.getValuesByKey('confirmSend');");			//get an array of favorite-confirmsend flags from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgConfirmSend)){return ret;}");		//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrFavMsgConfirmSend[i];}");						//if we got a valid index-position, use it to lookup the favorite-record's confirm-send flag
printf("	return ret;");										//return the confirmSend flag that we found (or -1 if no match was found)
printf("}\n");
printf("function rsRec_getActiveCopies_asRawString(objRS, favRecno){");				// Return the specified favorite's active-copies-recnos as a raw string
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgActiveCopies = objRS.getValuesByKey('active_copies');");			//get an array of favorite-active-copies strings from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgActiveCopies)){return ret;}");		//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrFavMsgActiveCopies[i];}");						//if we got a valid index-position, use it to lookup the favorite-record's string of active copy recno(s)
printf("	return ret;");										//return the string of active copy recno(s) that we found (or "" if no match was found)
printf("}\n");
printf("function rsRec_getActiveCopies_asArray(objRS, favRecno){");				// Return the specified favorite's active-copies-recnos as an array of strings
printf("	var ret = [];");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgActiveCopies = objRS.getValuesByKey('active_copies');");			//get an array of favorite-active-copies strings from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgActiveCopies)){return ret;}");		//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrFavMsgActiveCopies[i].split(',');}");					//if we got a valid index-position, use it to lookup the favorite-record's string of active copy recno(s) and split it into an array
printf("	for(var j=0; j<ret.length; j++){");							//clean up the array
printf("		if(ret[j].length==0){ret.splice(j,1);}");					//remove any empty array element
printf("	}");
printf("	return ret;");										//return an array of active copy recno(s) that we found
printf("}\n");
printf("function rsRec_removeActiveCopyRecno_forFav(objRS, favRecno, activeCopyRecno){");	// Update the specified favorite's active-copies-recnos with the provided array of active copies
printf("	favRecno = favRecno.toString();");
printf("	activeCopyRecno = activeCopyRecno.toString();");
printf("	activeCopyRecnoWithDelimiter = activeCopyRecno + \",\";");
printf("	if(typeof objRS === 'undefined') {");
printf("		FavScreen.log('info',\"rsRec_removeActiveCopyRecno_forFav(): The specified recordset does not exist (this may be alright, e.g. it's rsRecentDB but that hasn't been created yet). Aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	try {");
printf("		var arr = objRS.getValuesByKey();");	//no args gets the entire recordset as an array of objects
printf("	}");
printf("	catch(err) {");
printf("		FavScreen.log('warn','rsRec_removeActiveCopyRecno_forFav(): Caught '+err+'. Active copy may have expired at just the right time. Will udpate with empty array.',true);");
printf("		var arr = [];");
printf("	}");
printf("	for(var i=0; i<arr.length; i++) {");
printf("		if(arr[i].recno_fav === favRecno.toString()) {");	//if we found our record to update...
printf("			arr[i].active_copies = arr[i].active_copies.toString().replace(activeCopyRecnoWithDelimiter, \"\");");
printf("			break;");
printf("		}");
printf("	}");
printf("	objRS.update(arr);");
printf("}\n");
printf("function rsRec_updateActiveCopyRecnoString_forFav(objRS, favRecno, activeCopyRecnoString){");	// Update the specified favorite's active-copies-recnos with the provided array of active copies
printf("	favRecno = favRecno.toString();");
printf("	activeCopyRecnoString = activeCopyRecnoString.toString();");
printf("	if(typeof objRS === 'undefined') {");
printf("		FavScreen.log('info',\"rsRec_updateActiveCopyRecnoString_forFav(): The specified recordset does not exist (this may be alright, e.g. it's rsRecentDB but that hasn't been created yet). Aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	try {");
printf("		var arr = objRS.getValuesByKey();");	//no args gets the entire recordset as an array of objects
printf("	}");
printf("	catch(err) {");
printf("		FavScreen.log('warn','rsRec_updateActiveCopyRecnoString_forFav(): Caught '+err+'. Active copy may have expired at just the right time. Will udpate with empty array.',true);");
printf("		var arr = [];");
printf("	}");
printf("	for(var i=0; i<arr.length; i++) {");
printf("		if(arr[i].recno_fav === favRecno.toString()) {");	//if we found our record to update...
printf("			arr[i].active_copies = activeCopyRecnoString;");
printf("			break;");
printf("		}");
printf("	}");
printf("	objRS.update(arr);");
printf("}\n");
printf("function rsRec_updateToggleDurationString_forFav(objRS, favRecno, toggleDurationString){");	// Update the specified favorite's active-copies-recnos with the provided array of active copies
printf("	favRecno = favRecno.toString();");
printf("	toggleDurationString = toggleDurationString.toString();");
printf("	if(typeof objRS === 'undefined') {");
printf("		FavScreen.log('info',\"rsRec_updateToggleDurationString_forFav(): The specified recordset does not exist (this may be alright, e.g. it's rsRecentDB but that hasn't been created yet). Aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	try {");
printf("		var arr = objRS.getValuesByKey();");	//no args gets the entire recordset as an array of objects
printf("	}");
printf("	catch(err) {");
printf("		FavScreen.log('warn','rsRec_updateToggleDurationString_forFav(): Caught '+err+'. Will not update.',true);");
printf("		return false;");
printf("	}");
printf("	for(var i=0; i<arr.length; i++) {");
printf("		if(arr[i].recno_fav === favRecno.toString()) {");	//if we found our record to update...
printf("			arr[i].toggle_duration = toggleDurationString;");	//update the toggle_duration member
printf("			break;");//exit loop
printf("		}");
printf("	}");
printf("	objRS.update(arr);");
printf("}\n");
printf("function rsRec_updateToggleEndDtsecString_forFav(objRS, favRecno, toggleEndDtsecString){");	// Update the specified favorite's active-copies-recnos with the provided array of active copies
printf("	favRecno = favRecno.toString();");
printf("	toggleEndDtsecString = toggleEndDtsecString.toString();");
printf("	if(typeof objRS === 'undefined') {");
printf("		FavScreen.log('info',\"rsRec_updateToggleEndDtsecString_forFav(): The specified recordset does not exist (this may be alright, e.g. it's rsRecentDB but that hasn't been created yet). Aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	try {");
printf("		var arr = objRS.getValuesByKey();");	//no args gets the entire recordset as an array of objects
printf("	}");
printf("	catch(err) {");
printf("		FavScreen.log('warn','rsRec_updateToggleEndDtsecString_forFav(): Caught '+err+'. Will not update.',true);");
printf("		return false;");
printf("	}");
printf("	for(var i=0; i<arr.length; i++) {");
printf("		if(arr[i].recno_fav === favRecno.toString()) {");	//if we found our record to update...
printf("			arr[i].toggle_end_dtsec = toggleEndDtsecString;");	//update the toggle_end_dtsec member
printf("			break;");//exit loop
printf("		}");
printf("	}");
printf("	objRS.update(arr);");
printf("}\n");
printf("function rsRec_getToggleEndDtsec(objRS, favRecno){");					// Return the specified favorite's toggle_end_dtsec (specified whenever a launch is made of a toggle-able message)
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgToggleEndDtsec = objRS.getValuesByKey('toggle_end_dtsec');");		//get an array of toggle-end-dtsec strings from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgToggleEndDtsec)){return ret;}");		//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrFavMsgToggleEndDtsec[i];}");						//if we got a valid index-position, use it to lookup the favorite-record's string of active copy recno(s)
printf("	return ret;");										//return the string of active copy recno(s) that we found (or "" if no match was found)
printf("}\n");
printf("function rsRec_getToggleDuration(objRS, favRecno){");					// Return the specified favorite's msg-defined toggle_duration
printf("	var ret = \"\";");									//initialize a variable with a default value to return
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return ret;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");					//validate argument
printf("	var arrFavMsgRecnos = objRS.getValuesByKey('recno_fav');");				//get an array of favorite-message record numbers from the recordset
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return ret;}");			//validate that array
printf("	var arrFavMsgToggleDurations = objRS.getValuesByKey('toggle_duration');");		//get an array of toggle-durations from the recordset (for all favorite messages) -- they should perfectly correspond to the above array (we depend on it)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgToggleDurations)){return ret;}");		//validate that array
printf("	var i = rs_getIndexOfFavMsgRecord(arrFavMsgRecnos,favRecno);");				//figure out the index-position of the favRecno in the array (again, should correspond to the recordset, as stated a couple comments above)
printf("	if(i>-1){ret = arrFavMsgToggleDurations[i].toString();}");				//if we got a valid index-position, use it to lookup the favorite-record's string of active copy recno(s)
printf("	return ret;");										//return the string of active copy recno(s) that we found (or "" if no match was found)
printf("}\n");

printf("function padLeadingZeros(intValueToPad, intMaxTotalDigits){");				// Prepend an numerical digit with leading zeros
printf("	var s = intValueToPad+\"\";");
printf("	while(s.length<intMaxTotalDigits){");
printf("		s = \"0\"+s;");
printf("	}");
printf("	return s;");
printf("}\n");
/* DISCOVERED THIS WAS UNUSED 3/2/15
printf("function rsRec_updatePosition(objRS, favRecno, strTypeFlag, intLV, intGVX, intGVY, boolUpdateProvidedRS){");// Update the specified favorite's position in the recordset (not a database save at this point)... should also update any others that may be affected by this change??
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return false;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return false;}");				//validate argument
printf("	if(typeof strTypeFlag!==\"undefined\" && !rs_isValidArg_string(strTypeFlag,1)){return false;}");//if argument is provided, validate it with max length of 1 character
printf("	if(!rs_isValidArg_integer(intLV)){return false;}");					//validate argument
printf("	if(!rs_isValidArg_integer(intGVX)){return false;}");					//validate argument
printf("	if(!rs_isValidArg_integer(intGVY)){return false;}");					//validate argument
printf("	if(typeof boolUpdateProvidedRS!=\"boolean\"){FavScreen.log('error', \"rsRec_updatePosition(): boolUpdateProvidedRS arg invalid type (\"+typeof boolUpdateProvidedRS+\"). Returning false.\", true);return false;}");
printf("	var rsIndex = -1;");									//by default, don't just return false but show that some error happened
printf("	FavScreen.rsUpdated = objRS;");								//create a new global working-copy of the recordset (this will be what we actually update) -- this assignment syntax will work, whether it already exists or not
printf("	var arrFavMsgRecnos = FavScreen.rsUpdated.getValuesByKey('recno_fav');");		//get an array of favorite-message record numbers from the working-copy of the recordset (this is how we will figure out the native recordset index, since index is needed by the recordset's update method)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return false;}");		//validate that array
printf("	for(var i=0; i<arrFavMsgRecnos.length; i++){");					//go through the favorite record numbers to find the index/location of the specified favRecno
printf("		if(parseInt(arrFavMsgRecnos[i])==parseInt(favRecno)){");			//when we come across the record for the specified favRecno (provided as this function's argument)...
printf("			rsIndex = i;");								//save the corresponding recordset index number, so we can use it a bit laterfor the update operation
printf("			break;");								//we don't need to go through the loop anymore, since we found our record, so break out of looping and continue the function
printf("		}");//end if
printf("	}");//end for
printf("	if(rsIndex==-1){");									//if we didn't find a matching favRecno, error out (should never happen, just insurance)
printf("		FavScreen.log('error', \"rsRec_updatePosition(): FavScreen.rsUpdated does not contain a record corresponding to favRecno of '\"+favRecno+\"'. Record NOT updated. Returning false.\", true);");
printf("		return false;");
printf("	}else{");										//else we should be alright to go ahead and update the record...
printf("		var rec_position_old = objRS.item(i).getValue('position');");			//get the record's position value before we do an update
//printf("		var newValue = strTypeFlag+\"%s\"+intLV+\"%s\"+intGVX+\"%s\"+intGVY;", FAVS_POSITION_DELINEATE_TYPE, FAVS_POSITION_DELINEATE_COORD, FAVS_POSITION_DELINEATE_COORD);
printf("		var newValue = strTypeFlag+\"%s\"+padLeadingZeros(intLV,5)+\"%s\"+padLeadingZeros(intGVX,5)+\"%s\"+padLeadingZeros(intGVY,5);", FAVS_POSITION_DELINEATE_TYPE, FAVS_POSITION_DELINEATE_COORD, FAVS_POSITION_DELINEATE_COORD);
printf("		newValue = newValue.toString();");						//ensure that we update the field with a proper string version of the data
printf("		FavScreen.log('log', \"rsRec_updatePosition(): Updating favRecno #\"+favRecno+\" from '\"+rec_position_old+\"' to '\"+newValue+\"'.\", true);");
printf("		if(boolUpdateProvidedRS){objRS.update({position:newValue},rsIndex);}");		//if we were directed to update the source recordset, go ahead and do it
printf("		return FavScreen.rsUpdated.update({position:newValue},rsIndex);");		//perform the update operation to the record in the updated recordset (returns the old, overwritten data... in case you need it for some reason)
printf("	}");
printf("}\n");
*/
printf("function rsRec_updateFavName(objRS, favRecno, strNewName){");				// Update the specified favorite's name (label1) in the recordset (not a database save at this point)
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return false;}");				//validate argument
printf("	if(!rs_isValidArg_favRecno(favRecno)){return false;}");				//validate argument
printf("	if(!rs_isValidArg_string(strNewName)){return false;}");				//validate argument
printf("	var rsIndex = -1;");									//by default, don't just return false but show that some error happened
printf("	FavScreen.rsUpdated = objRS;");								//create a new global working-copy of the recordset (this will be what we actually update) -- this assignment syntax will work, whether it already exists or not
printf("	var arrFavMsgRecnos = FavScreen.rsUpdated.getValuesByKey('recno_fav');");		//get an array of favorite-message record numbers from the working-copy of the recordset (this is how we will figure out the native recordset index, since index is needed by the recordset's update method)
printf("	if(!rs_isValidResult_getValuesByKey(arrFavMsgRecnos)){return false;}");		//validate that array
printf("	for(var i=0; i<arrFavMsgRecnos.length; i++){");					//go through the favorite record numbers to find the index/location of the specified favRecno
printf("		if(parseInt(arrFavMsgRecnos[i])==parseInt(favRecno)){");			//when we come across the record for the specified favRecno (provided as this function's argument)...
printf("			rsIndex = i;");								//save the corresponding recordset index number, so we can use it a bit laterfor the update operation
printf("			break;");								//we don't need to go through the loop anymore, since we found our record, so break out of looping and continue the function
printf("		}");//end if
printf("	}");//end for
printf("	if(rsIndex==-1){");									//if we didn't find a matching favRecno, error out (should never happen, just insurance)
printf("		FavScreen.log('error', \"rsRec_updateFavName(): FavScreen.rsUpdated does not contain a record corresponding to favRecno of '\"+favRecno+\"'. Record NOT updated. Returning false.\", true);");
printf("		return false;");
printf("	}else{");
printf("		return FavScreen.rsUpdated.update({label1:strNewName},rsIndex);");		//perform the update operation to the record (returns the old, overwritten data... in case you need it for some reason)
printf("	}");
printf("}\n");//end function

/* Gets up-to-date favorites data from the database on the server, by making a request to smcgi using YUI IO
 * 	userPin		- (required str) User pin to get favorites for
 * 	boolRefreshOrig	- (required bool) Specifies whether to update THE main/original recordset or not... an example of when you might want to do this is during a page-wide refresh... an example of when you might NOT want to do this might be when you want to retain rsOrig data for some reason */
printf("function refreshRecordset(userPin, boolRefreshOrig, boolJumpToTop, boolObeyDelay, boolDoVersionCheck){");// Gets up-to-date favorites-data from the database, by making a request to CGI using YUI-IO, and refreshes the on-screen favorites-listing
printf("	FavScreen.log('verbose','refreshRecordset() CALL STACK: '+Error().stack,true);");
printf("	var ret = false;");
printf("	if(typeof FavScreen==='undefined'){");							//if our recordset isn't defined, then don't allow this function to continue
printf("		console.error(\"refreshRecordset(): FavScreen must be instantiated, first. Returning false.\");");
printf("		return ret;");
printf("	}");//end if
printf("	if(typeof iframeHandle!=='undefined'){");						//if an iframe is currently rendered, then don't allow this function to continue, since there's no point in refreshing messages that the user can't see
printf("		FavScreen.log('info',\"Calling the function refreshRecordset() wouldn't be meaningful since an iframe is currently rendered instead of the message sections. Aborting.\",true);");
printf("		return ret;");
printf("	}");//end if
printf("	if(typeof userPin==='undefined'){");							//validate required arguments for this function
printf("		FavScreen.log('error', \"refreshRecordset(): userPin arg required. Returning false.\", true);");
printf("		return ret;");
printf("	}");//end if
printf("	forceHideModalMask();");
printf("	if(typeof ConfirmLaunch!==\"undefined\"){");
printf("		if(ConfirmLaunch.initialized && ConfirmLaunch.isVisible()){");
printf("			ConfirmLaunch.hide();");
printf("		}");
printf("	}");
printf("	if(typeof ConfirmToggle!==\"undefined\"){");
printf("		if(ConfirmToggle.initialized && ConfirmToggle.isVisible()){");
printf("			ConfirmToggle.hide();");
printf("		}");
printf("	}");
//printf("	if( (document.getElementById(\"contentwrapper-sorted\")==null) && (document.getElementById(\"iframe_toResolveMsg\")!=null) ){");
printf("	if( (document.getElementById(\"contentwrapper-critical\")==null) && (document.getElementById(\"iframe_toResolveMsg\")!=null) ){");
printf("		FavScreen.log('info',\"refreshRecordset(): No data on screen to refresh, perhaps due to an iframe being loaded or something. Aborting.\",true);");
printf("		return ret;");
printf("	}");
printf("	if(typeof boolJumpToTop==='undefined'){");						//handle parameter boolJumpToTop... (default to true)
printf("		FavScreen.log('verbose', \"refreshRecordset(): boolJumpToTop not specified. Defaulting true.\", false);");
printf("		boolJumpToTop = true;");
printf("	}");
printf("	boolJumpToTop = Boolean(boolJumpToTop);");
printf("	if(typeof boolObeyDelay==='undefined'){");						//handle parameter boolObeyDelay... (default to true)
printf("		FavScreen.log('verbose', \"refreshRecordset(): boolObeyDelay not specified. Defaulting true.\", false);");
printf("		boolObeyDelay = true;");
printf("	}");
printf("	boolObeyDelay = Boolean(boolObeyDelay);");
printf("	if(boolObeyDelay){");
//printf("		var cfg_minTimeBetweenRefreshes = 3 *1000;");						//configure the minimum time required to have passed from the last refresh operation before this refresh operation (in milliseconds)
//DEV-NOTE: made time smaller to help patch toggle icon not showing with rapid-succession launches... make this more intelligent, later
//printf("		var cfg_minTimeBetweenRefreshes = 1 *1000;");						//configure the minimum time required to have passed from the last refresh operation before this refresh operation (in milliseconds)
printf("		var cfg_minTimeBetweenRefreshes = 2 *1000;");						//configure the minimum time required to have passed from the last refresh operation before this refresh operation (in milliseconds)
printf("	}else{");
printf("		var cfg_minTimeBetweenRefreshes = 0;");							//zero-out the minimum time to consider for this call, since it was specified to not obey any delay
printf("	}");
printf("	if(typeof boolDoVersionCheck==='undefined'){");							//if no argument provided, default to true
printf("		FavScreen.log('verbose', \"refreshRecordset(): boolDoVersionCheck not specified. Defaulting true.\", false);");
printf("		boolDoVersionCheck = true;");									//set flag true
printf("	}else{");											//else some argument was provided, so parse it to a Boolean value...
printf("		boolDoVersionCheck = Boolean(boolDoVersionCheck);");						//parse whatever provided (or not provided) to true/false
printf("	}");
printf("	FavScreen.log('verbose',\"refreshRecordset(): userPin='\"+userPin+\"' | boolRefreshOrig=\"+boolRefreshOrig+\" | boolJumpToTop=\"+boolJumpToTop+\" | boolObeyDelay=\"+boolObeyDelay+\" | boolDoVersionCheck=\"+boolDoVersionCheck+\".\",false);");
printf("	YUI().use('recordset-base', 'recordset-filter', 'recordset-sort', 'io', 'io-base', 'querystring-stringify-simple', function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");						//what should happen when the io txn starts
printf("			FavScreen.log('verbose', \"refreshRecordset(): YUI-IO: Starting txn to get %s from database. YUI-IO txn ID# will be: \"+ioId+\".\", true);", FAVS_NAME_PLURAL);
printf("			Spinner.showAfterDelay(200);");						//start the spinner (should be on a delay, in case we want to cancel it for certain refresh calls... e.g. native app focus)
printf("			};");
printf("		var handleSuccess = function(ioId, o){");					//response HTTP status resolves to 2xx
printf("			var rt = o.responseText;");
printf("			if(rt.indexOf(\"<P>Invalid form information was found.\")>-1){");	//catch server errors
printf("				FavScreen.log('error',\"refreshRecordset(): YUI-IO: Server says, 'Invalid form information was found.' for txn #\"+ioId+\".\",false);");
printf("			}else if(rt.indexOf(\"Unknown form load command. Please logout and login again.\")>-1){");
printf("				FavScreen.log('error',\"refreshRecordset(): YUI-IO Txn#\"+ioId+\": Server says, 'Unknown form load command. Please logout and login again.' (\"+rt+\").\",true);");
printf("			}else if(rt.indexOf(\"smcgi stopped\")>-1){");
printf("				FavScreen.log('error',\"refreshRecordset(): YUI-IO Txn#\"+ioId+\": Server says, 'smcgi stopped' (\"+rt+\").\",true);");
printf("			}else{");
printf("				FavScreen.log('log',\"refreshRecordset(): YUI-IO: Txn #\"+ioId+\" succeeded. Continuing to do whatever we need to do with the response... \",false);");
printf("				FavScreen.rsRecentDB = new Y.Recordset();");				//initialize a new recordset into our global object  (DEV-NOTE: will this overwrite an existing automatically? hope so!)
printf("				FavScreen.rsRecentDB.plug(Y.Plugin.RecordsetFilter);");			//plug-in the filter stuff (access its stuff from the .filter namespace)
printf("				FavScreen.rsRecentDB.plug(Y.Plugin.RecordsetSort);");			//plug-in the sort stuff (access its stuff from the .sort namespace)
printf("				FavScreen.rsRecentDB.after('init', function(){");			//subscribe an "after init" event listner to the recordset object (just so we are absolutely certain we attach the next event listener to a fully-initialized object)
printf("					FavScreen.rsRecentDB.after('add', function(){");		//subscribe an "after add" event listner to the recordset object to render the favorites list as soon as possible
printf("						if(boolJumpToTop){");//DEV-NOTE: move this up so it happens first?
printf("							if(jumpScrollTo(\"bodywrapperTopAnchor\", true, true)){");
printf("								FavScreen.set('attrJumpScrollToTopLastTimestamp',Date.now());");
printf("							}");//end if jump returns true
printf("						}");
printf("						FavScreen.log('log', \"refreshRecordset(): YUI-Recordset: Most recent set of \"+this.size()+\" %s from database added to 'rsRecentDB'. Extracting sub-recordsets and rendering on-screen...\", true);", FAVS_NAME_PLURAL);
printf("						rs_extractRecordsToRecordsets('FavScreen.rsRecentDB');");//generate related sub-recordsets
printf("						if(boolRefreshOrig==true){");				//if it was specified to refresh the data in rsOrig... (need to do this first, since renderMessageListSection function(s?) use rsOrig)
printf("							FavScreen.rsOrig.empty();");			//empty the main recordset --NOTE: sub-recordsets should have already been automatically recreated, as per the after-add event listener on this recordset
printf("							FavScreen.rsOrig.add(oData);");			//re-populate the main recordset with the data we got --NOTE: sub-recordsets should have already been automatically recreated, as per the after-add event listener on this recordset
//printf("							FavScreen.rsOrig.update(oData);");		//re-populate the main recordset with the data we got --NOTE: sub-recordsets should have already been automatically recreated, as per the after-add event listener on this recordset
printf("						}");
printf("						if(FavScreen.get('attrIsCurrentlyVisible_sorted')){");
printf("							MajorSection_critical.cfg.objYuiRS_messageData = FavScreen.rsRecentDB_sorted;");
printf("							MajorSection_critical.renderListInItsSection();");
//DEPRECATING THE FOLLOWING IN FAVOR OF CLASS METHOD...
//printf("							var node_ul_sorted = createMessageListNode(FavScreen.rsRecentDB_sorted, 'messagelist-sorted', '', 'sorted');");
//printf("							var numSortedFavsDisplayed = renderMessageListSection_sorted(node_ul_sorted, true);");//render the sorted favorites as a node, while returning the number of favorites that got rendered
//printf("							FavScreen.set('attrNumSortedFavsDisplaying', numSortedFavsDisplayed);");//inform the global attribute how many sorted favs should be showing on-screen (we'll check it next when we render un-sorted favs, to determine whether to show an unsorted here or not)
printf("							FavScreen.set('attrNumSortedFavsDisplaying', MajorSection_critical.numOfItemsPopulated);");//inform the global attribute how many sorted favs should be showing on-screen (we'll check it next when we render un-sorted favs, to determine whether to show an unsorted here or not)

printf("						}");//replace the existing UL node with an updated one that reflects the updated recordset
//printf("						if(FavScreen.get('attrIsCurrentlyVisible_unsorted')){");
printf("							MajorSection_dropbox.cfg.objYuiRS_messageData = FavScreen.rsRecentDB_unsorted;");
printf("							MajorSection_dropbox.renderListInItsSection();");
//DEPRECATING THE FOLLOWING IN FAVOR OF CLASS METHOD...
//printf("							var node_ul_unsorted = createMessageListNode(FavScreen.rsRecentDB_unsorted, 'messagelist-unsorted-1', '', 'unsorted');");
//printf("							renderMessageListSection_unsorted(node_ul_unsorted, true);");

//printf("						}");//replace the existing UL node with an updated one that reflects the udpated recordset
//printf("						if library msgs exist, test? {");
//printf("							refreshRecordset_library(FavScreen.rsRecentDB_libraries, false);"); //NOTE: this will do a database pull.. should work but is unnecessary // but also would do all libraries (which is probably desired here)
//DEV-NOTE: Disabled this with v0.39.3-beta to fix excess network loading times... seems to have been unnecessary in this function (perhaps a prototype leftover?)... seems alright so far, without it?
//printf("							loadLibsAndMsgs();");
//printf("							var node_ul_library = createMessageListNode_libraryMsgs(objLibraryRef.libUser, objLibraryRef.rsLibMsgs, \"messagelist-library-\"+objLibraryRef.libUser.user_recno, '', 'libmsg');");
//printf("							renderMessageListSection_library(node_ul, true);");
//printf("							var node_ul_libraries = createMessageListNode_subsectionsLibraries(FavScreen.objLibsMsgs, \"subsectionlist-libraries\");");
//printf("							renderMessageListSection_libraries(node_ul_libraries);");
//printf("						}");

printf("							MajorSection_personalLibs.cfg.objYuiRS_messageData = FavScreen.rsRecentDB_personalLibs;");
printf("							MajorSection_personalLibs.renderListInItsSection();");

//DEPRECATING THE FOLLOWING IN FAVOR OF CLASS METHOD...
//printf("						updateMessagecells();");									//update messagecells and contents for the interaction mode chosen (e.g. showing/hiding drag handles, etc.)

printf("						FavScreen.set('attrLastRefreshTimestamp',Date.now());");
printf("					});");//end add event listener subscription
printf("				});");//end init event listener subscription
printf("				var oData = eval(rt);");					//parse the responseText (a string which represents an object literal) into an object-literal  DEV-NOTE: eval might be the best (only?) way to do this... alternative is to send as JSON Mime Type?
printf("				if(!oData){");								//if no data returned
printf("					FavScreen.log('info',\"refreshRecordset(): No data available.\",true);");
printf("				}else if(oData[0].exclude_this_from_recordset==true){");		//else-if data returned contains a special first element (containing system/version info)
printf("					var excludedData = oData.splice(0,1);");				//extract the special element from the data and set aside (this removes it from the main data)
printf("					var objED = excludedData[0];");						//simplify by extracting out the only object in the array
printf("					if(objED.version!=FavScreen.get('attrVersion')){");
printf("						FavScreen.log('info', \"refreshRecordset(): Version of client software (\"+FavScreen.get('attrVersion')+\") is different than what's available on the server (\"+objED.version+\").\", true);");
printf("						if(boolDoVersionCheck){");
printf("							FavScreen.log('log', \"refreshRecordset(): User is being directed to close/reload %s to get the latest version. They can either cancel or close the window, next.\", false);", FAVS_NAME_FULL);
printf("							if(UpdateSoftware.initialized==true){UpdateSoftware.showFor(30000);}");	//show the alert prompt to update the software by reloading
printf("						}");
printf("					}");//end if version difference
printf("				}");
printf("				FavScreen.rsRecentDB.add(oData);");					//add our data to the recordset (which will fire the 'after add' stuff above, and actually render the results on the page)
printf("				FavScreen.rsRecentDB.detachAll();");					//detach those event listeners, so we can reattach other add actions later (like maybe for sorting, adding new, etc... we wouldn't want to call the same function for those)
printf("				forceCssRepaint();");
printf("				ret = true;");
printf("			}");
printf("			};");
printf("		var handleFailure = function(ioId, o){");					//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('error', \"refreshRecordset(): YUI-IO: Txn #\"+ioId+\" failed or timed-out (view 'log' console log for details).\", true);");
printf("			FavScreen.log('verbose', \"refreshRecordset(): YUI-IO: Txn #\"+ioId+\"'s responseText returned by server = '\"+rt+\"'\", true);");
//printf("			forceCssRepaint();");
printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("			};");
printf("		var handleEnd = function(ioId,o){");
printf("			Spinner.hide(FAVS_SPINNER_DELAY_HIDE);");
printf("			};");
printf("		var cfg ={");									//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");						//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");					//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");					//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");						//subscribe the above custom failure handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");							//method will default to GET unless we specify POST here
printf("			data:{");								//whatever fields/data that CGI gets to parse...
printf("				'getUserFavs':'true',");					//smcgi command flag
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP(),");
printf("				'userPin':userPin");
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
//DEV-NOTE: can't remember why I went with SYNC here... must have been some reason
printf("			sync:true,");								//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
//printf("			sync:false,");								//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:10000");							//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("			};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);						//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		var ts_lastRefresh = FavScreen.get('attrLastRefreshTimestamp');");		//get the last successful refresh timestamp (in milliseconds)
printf("		var ts_rightNow = Date.now();");						//get the current timestamp (in milliseconds)
printf("		var ts_difference = ts_rightNow - ts_lastRefresh;");				//calculate the difference (in milliseconds) between now and the last refresh
printf("		if(ts_difference >= cfg_minTimeBetweenRefreshes){");				//if enough time has passed, allow the refresh to happen
printf("			objResponse = Y.io(sUrl, cfg);");						//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("		}else{");
printf("			FavScreen.log('info',\"refreshRecordset(): This refresh was directed to obey a delay of \"+cfg_minTimeBetweenRefreshes+\"ms, but it's only been \"+ts_difference+\"ms since the last refresh. Aborting.\",true);");
printf("		}");
printf("	});");//end YUI.use
printf("	return ret;");
printf("}\n");//end function refreshRecordset()

printf("function refreshRecordset_inboxMsgs(userPin, boolObeyDelay, boolDoSpinner){");
printf("	if(typeof FavScreen==='undefined'){");							//if our recordset isn't defined (of course, as a member of FavScreen), then don't allow this function to continue
printf("		console.error(\"Calling the function refreshRecordset_inboxMsgs() requires that FavScreen be instantiated, first. Aborting.\");");
printf("		return false;");
printf("	}");//end if
printf("	if(typeof iframeHandle!=='undefined'){");						//if an iframe is currently rendered, then don't allow this function to continue, since there's no point in refreshing messages that the user can't see
printf("		FavScreen.log('info',\"Calling the function refreshRecordset_inboxMsgs() wouldn't be meaningful since an iframe is currently rendered instead of the inbox section. Aborting.\",true);");
printf("		return false;");
printf("	}");//end if
printf("	if(typeof userPin!=='string'){");							//validate required arguments for this function
printf("		FavScreen.log('info', \"refreshRecordset_inboxMsgs(): Calling this function typically expects that a userPin string be supplied as the 1st argument. Defaulting to CurrentUserPin, '%s'.\", true);", CurrentUserPin);
printf("		if(userPin.type == 'click') {");							//if a click event was passed into the 1st argument, then this function was called by a click event-listener (e.g. a refresh icon or something)
printf("			Spinner.show();");									//immediately show spinner to give the impression of responsiveness to the user
printf("		}");
printf("		userPin = \"%s\";", CurrentUserPin);							//since we're done with the 1st argument, reassign a default actual user-pin to it for the function to continue
printf("	}");//end if
printf("	if(typeof boolObeyDelay==='undefined'){");						//handle parameter boolObeyDelay... (default to true)
printf("		FavScreen.log('verbose', \"refreshRecordset_inboxMsgs(): boolObeyDelay not specified. Defaulting true.\", false);");
printf("		boolObeyDelay = true;");
printf("	}");
printf("	boolObeyDelay = Boolean(boolObeyDelay);");
printf("	FavScreen.log('verbose',\"refreshRecordset_inboxMsgs(): boolObeyDelay = '\"+boolObeyDelay+\"'.\",false);");
printf("	if(boolObeyDelay){");
printf("		var cfg_minTimeBetweenRefreshes = 3 *1000;");						//configure the minimum time required to have passed from the last refresh operation before this refresh operation (in milliseconds)
printf("	}else{");
printf("		var cfg_minTimeBetweenRefreshes = 0;");							//zero-out the minimum time to consider for this call, since it was specified to not obey any delay
printf("	}");
printf("	if(typeof boolDoSpinner==='undefined'){");							//if no argument provided, default to true
printf("		FavScreen.log('verbose', \"refreshRecordset_inboxMsgs(): boolDoSpinner not specified. Defaulting true.\", false);");
printf("		boolDoSpinner = true;");									//set flag true
printf("	}else{");											//else some argument was provided, so parse it to a Boolean value...
printf("		boolDoSpinner = Boolean(boolDoSpinner);");							//parse whatever provided (or not provided) to true/false
printf("	}");
printf("	YUI().use('recordset-base', 'recordset-filter', 'recordset-sort', 'io', 'io-base', 'querystring-stringify-simple', function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");						//what should happen when the io txn starts
printf("			FavScreen.log('verbose', \"refreshRecordset_inboxMsgs(): YUI-IO: Starting txn to get inbox msgs from database... YUI-IO txn ID# will be: \"+ioId+\".\", true);");
printf("			if(boolDoSpinner){");
printf("				Spinner.show();");								//start the spinner
//printf("				Spinner.showAfterDelay(200);");						//start the spinner
printf("			}");
printf("			};");//end handleStart method definition
printf("		var handleSuccess = function(ioId, o){");					//response HTTP status resolves to 2xx
printf("			var rt = o.responseText;");
printf("			if(rt.indexOf(\"<P>Invalid form information was found.\")>-1){");
printf("				FavScreen.log('error',\"refreshRecordset_inboxMsgs(): YUI-IO Txn#\"+ioId+\": Server says, 'Invalid form information was found.'\",true);");
printf("			}else if(rt.indexOf(\"Unknown form load command. Please logout and login again.\")>-1){");
printf("				FavScreen.log('error',\"refreshRecordset_inboxMsgs(): YUI-IO Txn#\"+ioId+\": Server says, 'Unknown form load command. Please logout and login again.' (\"+rt+\").\",true);");
printf("			}else if(rt.indexOf(\"smcgi stopped\")>-1){");
printf("				FavScreen.log('error',\"refreshRecordset_inboxMsgs(): YUI-IO Txn#\"+ioId+\": Server says, 'smcgi stopped' (\"+rt+\").\",true);");
printf("			}else if(rt.indexOf(\"%s\")>-1){", FAVS_RESPONSE_CODE_NONEFOUND_INBOXMSGS);
printf("				FavScreen.log('info',\"refreshRecordset_inboxMsgs(): YUI-IO Txn#\"+ioId+\": Server responds with '%s'. So, nothing to refresh/update.\",true);", FAVS_RESPONSE_CODE_NONEFOUND_INBOXMSGS);
printf("				FavScreen.rsInbox.empty();");							//empty the recordset, since there are no inbox messages
printf("			}else{");
printf("				FavScreen.log('log',\"refreshRecordset_inboxMsgs(): YUI-IO Txn#\"+ioId+\": Txn succeeded. Continuing to do whatever we need to do with the response... \",true);");
printf("				if(rt.indexOf(\"[{\")==-1){");							//if the server returned something that would screw up the expected object-literal format (this could happen, for example, if decodes or any CGI routines does printf stuff)
printf("					FavScreen.log('warn',\"refreshRecordset_inboxMsgs(): YUI-IO Txn#\"+ioId+\": Txn returned a data object polluted with non-expected data, attempting to clean it up before it gets eval'd.\",true);");
printf("					var indexOfFirstValidDataStart = rt.indexOf(\"{recno_inbox:\");");		//lookup where the first valid data starts (note: matches what is output in smcgi.c by the "getUserInboxMsgs=" branch)
printf("					rt = \"[\"+rt.slice(indexOfFirstValidDataStart);");				//slice out the offending sub-string, prepending-with/restoring the object-literal bracket that slice cuts out with it.
printf("				}");
printf("				var oData;");
printf("				try{");
printf("					oData = eval(rt);");							//parse the responseText (a string which represents an object literal) into an object-literal  DEV-NOTE: eval might be the best (only?) way to do this... alternative is to send as JSON Mime Type?
printf("				}catch(err){");
printf("					FavScreen.log('error',\"refreshRecordset_inboxMsgs(): Error doing eval operation on string-response from server...\",false);");
printf("					FavScreen.log('verbose',\"refreshRecordset_inboxMsgs(): Error details ( \"+err+\" ).\",false);");
printf("					FavScreen.log('verbose',\"refreshRecordset_inboxMsgs(): Data received ( \"+rt+\" ).\",false);");
printf("					oData = false;");
printf("				}");
printf("				if(!oData){");									//if no eval'able data returned
printf("					FavScreen.log('info',\"refreshRecordset_inboxMsgs(): YUI-IO Txn#\"+ioId+\": No valid data-object available.\",true);");
printf("					Spinner.hide();");	//hide immediately, so modal-notification won't be covered
printf("					ModalNotification_GeneralError.showFor(4000);");
printf("				}else{");
printf("					FavScreen.log('log',\"refreshRecordset_inboxMsgs(): YUI-IO Txn#\"+ioId+\": Valid data-object available.\",false);");
printf("					FavScreen.rsInbox_skipUpdateDOM_afterEmpty = true;");
printf("					FavScreen.rsInbox.empty();");						//empty the recordset (which will fire the 'after empty' stuff, and actually render the results)
printf("					FavScreen.rsInbox.add(oData);");					//update our data to the recordset (which will fire the 'after add' stuff, and actually render the results)
//printf("					FavScreen.rsInbox.update(oData);");					//update our data to the recordset (which will fire the 'after update' stuff, and actually render the results)
printf("					FavScreen.set('attrLastRefreshTimestamp_inboxMsgs',Date.now());");
printf("					FavScreen.rsInbox_skipUpdateDOM_afterEmpty = undefined;");		//reset flag, so future empty operations will be able to update the DOM
printf("				}");
printf("			}");//end else (successful response)
printf("			};");//end handleSuccess method definition
printf("		var handleFailure = function(ioId, o){");					//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('warn', \"refreshRecordset_inboxMsgs(): YUI-IO Txn#\"+ioId+\": Txn failed or timed-out (view 'verbose' or 'log' console log for details).\", true);");
printf("			FavScreen.log('verbose', \"refreshRecordset_inboxMsgs(): YUI-IO: Txn#\"+ioId+\": ResponseText returned by server = '\"+o.responseText+\"'\", true);");
printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("			};");//end handleFailure method definition
printf("		var handleEnd = function(ioId,o){");//NOTE: could this not be firing if timeout happens before it ends?
printf("			FavScreen.log('verbose', \"refreshRecordset_inboxMsgs(): YUI-IO Txn#\"+ioId+\": End of txn to get inbox msgs from database.\", false);");
printf("			if(boolDoSpinner){");
printf("				Spinner.hide(FAVS_SPINNER_DELAY_HIDE);");								//end the spinner after slight delay just to give the user impression that something has happened
printf("			}");
printf("			};");//end handleEnd method definition
printf("		var cfg ={");									//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");						//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");					//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");					//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");						//subscribe the above custom failure handler to IO's global end event (NOTE: is it possible this won't happen if timeout happens before actual end?)
printf("				},");
printf("			method:\"POST\", ");							//method will default to GET unless we specify POST here
printf("			data:{");								//whatever fields/data that CGI gets to parse...
printf("				'getUserInboxMsgs':'true',");					//smcgi command flag
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP(),");
printf("				'userPin':userPin");
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:false,");								//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete)
printf("			timeout:10000");							//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("			};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);						//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		var ts_lastRefresh = FavScreen.get('attrLastRefreshTimestamp_inboxMsgs');");	//get the last successful refresh timestamp (in milliseconds)
printf("		var ts_rightNow = Date.now();");						//get the current timestamp (in milliseconds)
printf("		var ts_difference = ts_rightNow - ts_lastRefresh;");				//calculate the difference (in milliseconds) between now and the last refresh
printf("		if(ts_difference >= cfg_minTimeBetweenRefreshes){");				//if enough time has passed, allow the refresh to happen
printf("			objResponse = Y.io(sUrl, cfg);");						//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("		}else{");
printf("			FavScreen.log('info',\"refreshRecordset_inboxMsgs(): This refresh was directed to obey a delay of \"+cfg_minTimeBetweenRefreshes+\"ms, but it's only been \"+ts_difference+\"ms since the last refresh. Aborting.\",true);");
printf("			Spinner.hide();");
printf("			return false;");
printf("		}");
printf("	});");//end YUI.use
printf("}\n");//end function refreshRecordset_inboxMsgs

/*
printf("function getContainerNodeForStdReplies() {");
printf("	var arrLibs = FavScreen.objLibsMsgs;");
printf("	for(var i=0; i<arrLibs.length; i++) {");
printf("		if(arrLibs[i].libUser.user_pin == '%s') {", FAVS_LIB_USER_STDREPLIES_PIN);
printf("			return document.getElementById(arrLibs[i].libUser.user_recno);");
printf("		}");
printf("	}");
printf("}\n");
*/

printf("function getUserRecnoForStdReplies() {");
printf("	var arrLibs = FavScreen.objLibsMsgs;");
printf("	for(var i=0; i<arrLibs.length; i++) {");
printf("		if(arrLibs[i].libUser.user_pin.trim() == '%s') {", FAVS_LIB_USER_STDREPLIES_PIN);
printf("			return arrLibs[i].libUser.user_recno;");
printf("		}");
printf("	}");
printf("}\n");

printf("function getObjLibRef_fromLibUserRecno(strLibUserRecno) {");
//TODO: validation
printf("	var arrLibs = FavScreen.objLibsMsgs;");
printf("	for(var i=0; i<arrLibs.length; i++) {");
printf("		if(arrLibs[i].libUser.user_recno == strLibUserRecno) {");
printf("			return arrLibs[i];");
printf("		}");
printf("	}");
printf("}\n");

/* takes an event and figures out how to call refreshRecordset_library, based on any usable data from that event and its target */
printf("function refreshRecordset_library_fromEvent(e) {");
//TODO: validation
printf("	var objNodeRef_lib_ul = e.target.parentNode.parentNode;");		//get a reference to the UL messagelist node that they clicked the refresh icon for
printf("	var objNodeRef_lib_container = objNodeRef_lib_ul.parentNode;");		//get a reference to the LI container node of that messagelist (it just has an easier to use LIB-user recno)
printf("	var libUserRecno = objNodeRef_lib_container.id;");			//get the LIB-user's recno (which is the ID value of the container node)
printf("	var objLibRef = getObjLibRef_fromLibUserRecno(libUserRecno);");
printf("	refreshRecordset_library(objLibRef);");
printf("}\n");

/* Gets up-to-date favorites data from the database on the server, by making a request to smcgi using YUI IO, and render the updated stuff on-screen
 * 	objLibraryRef	- (required str) Element in the libraries object (naturally, passed by reference) for the specific library to get fav msgs for */
printf("function refreshRecordset_library(objLibraryRef, boolJumpToTop, boolObeyDelay) {");	// Gets up-to-date favorites-data from the database, by making a request to CGI using YUI-IO, and refreshes the on-screen favorites-listing
printf("	if(typeof FavScreen==='undefined'){");							//if our recordset isn't defined, then don't allow this function to continue
printf("		console.error(\"refreshRecordset_library(): FavScreen must be instantiated, first. Returning false.\");");
printf("		return false;");
printf("	}");//end if
printf("	if(typeof iframeHandle!=='undefined'){");						//if an iframe is currently rendered, then don't allow this function to continue, since there's no point in refreshing messages that the user can't see
printf("		FavScreen.log('info',\"Calling the function refreshRecordset_library() wouldn't be meaningful since an iframe is currently rendered instead of the message sections. Aborting.\",true);");
printf("		return false;");
printf("	}");//end if
printf("	if(typeof objLibraryRef==='undefined'){");						//validate required arguments for this function
printf("		FavScreen.log('error', \"refreshRecordset_library(): objLibraryRef arg required. Aborting.\", true);");
printf("		return false;");
printf("	}");//end if
printf("	if(typeof objLibraryRef.libUser==='undefined'){");					//validate whether the required library ref arg contains a valid user-info member
printf("		FavScreen.log('error', \"refreshRecordset_library(): objLibraryRef arg must contain 'libUser' member. Aborting.\", true);");
printf("		return false;");
printf("	}");//end if
printf("	if(typeof objLibraryRef.libUser.user_pin==='undefined'){");				//validate whether the required library ref arg contains a valid user-info member
printf("		FavScreen.log('error', \"refreshRecordset_library(): objLibraryRef arg's 'libUser' member must contain 'user_pin' member. Aborting.\", true);");
printf("		return false;");
printf("	}");//end if
printf("	forceHideModalMask();");
printf("	if(typeof ConfirmLaunch!==\"undefined\"){");
printf("		if(ConfirmLaunch.initialized && ConfirmLaunch.isVisible()){");
printf("			ConfirmLaunch.hide();");
printf("		}");
printf("	}");
printf("	if(typeof ConfirmToggle!==\"undefined\"){");
printf("		if(ConfirmToggle.initialized && ConfirmToggle.isVisible()){");
printf("			ConfirmToggle.hide();");
printf("		}");
printf("	}");
//printf("	if( (document.getElementById(\"contentwrapper-sorted\")===null) && (document.getElementById(\"iframe_toResolveMsg\")!==null) ){");	//just use the main sorted section as a clue to what's on the screen
printf("	if( (document.getElementById(\"contentwrapper-critical\")===null) && (document.getElementById(\"iframe_toResolveMsg\")!==null) ){");	//just use the main sorted section as a clue to what's on the screen
printf("		FavScreen.log('info',\"refreshRecordset_library(): No data on screen to refresh, perhaps due to an iframe being loaded or something. Aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	Spinner.show();");							//immediately show spinner to give the impression of responsiveness to the user
printf("	if(typeof boolJumpToTop==='undefined'){");						//handle parameter boolJumpToTop... (default to true)
printf("		FavScreen.log('verbose', \"refreshRecordset_library(): boolJumpToTop not specified. Defaulting true.\", false);");
printf("		boolJumpToTop = true;");
printf("	}");
printf("	boolJumpToTop = Boolean(boolJumpToTop);");
printf("	if(typeof boolObeyDelay==='undefined'){");						//handle parameter boolObeyDelay... (default to true)
printf("		FavScreen.log('verbose', \"refreshRecordset_library(): boolObeyDelay not specified. Defaulting true.\", false);");
printf("		boolObeyDelay = true;");
printf("	}");
printf("	boolObeyDelay = Boolean(boolObeyDelay);");
//printf("	if(boolObeyDelay){");
//printf("		var cfg_minTimeBetweenRefreshes = 5 *1000;");						//configure the minimum time required to have passed from the last refresh operation before this refresh operation (in milliseconds)
//printf("	}else{");
//printf("		var cfg_minTimeBetweenRefreshes = 0;");							//zero-out the minimum time to consider for this call, since it was specified to not obey any delay
//printf("	}");
//printf("	FavScreen.log('log',\"refreshRecordset_library(): boolJumpToTop=\"+boolJumpToTop+\" | boolObeyDelay=\"+boolObeyDelay+\".\",false);");
printf("	var rsMsgs = getMsgsRecordsetForLibrary(objLibraryRef.libUser.user_pin);");		//get an updated library-messages recordset object
printf("	if(typeof rsMsgs === 'object') {");
printf("		if(typeof rsMsgs.size === 'function') {");
printf("			FavScreen.log('log', \"refreshRecordset_library(): The recordset returned contains \"+rsMsgs.size()+\" messages. Saving to the global object for this library...\", true);");
printf("			objLibraryRef.rsLibMsgs = rsMsgs;");						//note: this may circumvent any event listeners for adding/emptying/etc.?
printf("			var node_ul = createMessageListNode_libraryMsgs(objLibraryRef.libUser, objLibraryRef.rsLibMsgs, \"messagelist-library-\"+objLibraryRef.libUser.user_recno, '', 'libmsg');");
printf("			renderMessageListSection_library(node_ul, true);");
printf("		}else{");
printf("			FavScreen.log('warn', \"refreshRecordset_library(): The object returned contains no '.size()' method. It may not be a valid YUI-RecordSet object. Aborting.\", true);");
printf("			return false;");
printf("		}");
printf("	}else{");
printf("		FavScreen.log('warn', \"refreshRecordset_library(): No valid library-messages recordset was returned. Aborting.\", true);");
printf("		return false;");
printf("	}");
/*
//printf("		var ts_lastRefresh = FavScreen.get('attrLastRefreshTimestamp');");		//get the last successful refresh timestamp (in milliseconds)
//printf("		var ts_rightNow = Date.now();");						//get the current timestamp (in milliseconds)
//printf("		var ts_difference = ts_rightNow - ts_lastRefresh;");				//calculate the difference (in milliseconds) between now and the last refresh
//printf("		if(ts_difference >= cfg_minTimeBetweenRefreshes){");				//if enough time has passed, allow the refresh to happen
printf("			objResponse = Y.io(sUrl, cfg);");						//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
//printf("		}else{");
//printf("			FavScreen.log('info',\"refreshRecordset_library(): This refresh was directed to obey a delay of \"+cfg_minTimeBetweenRefreshes+\"ms, but it's only been \"+ts_difference+\"ms since the last refresh. Aborting.\",true);");
//printf("			return false;");
//printf("		}");
*/
printf("}\n");//end function refreshRecordset_library()

/* For the specified library (LIB user pin), return a YUI-Recordset object of its 'FV' type messages */
printf("function getMsgsRecordsetForLibrary(strLibUserPin) {");
printf("	var result = undefined;");
printf("	YUI().use('recordset-base', 'recordset-filter', 'recordset-sort', 'io', 'io-base', 'querystring-stringify-simple', function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");						//what should happen when the io txn starts
printf("			FavScreen.log('verbose', \"getMsgsRecordsetForLibrary(): YUI-IO: Starting txn to get %s from database. YUI-IO txn ID# will be: \"+ioId+\".\", false);", FAVS_NAME_PLURAL);
printf("			Spinner.show();");
printf("			};");
printf("		var handleSuccess = function(ioId, o){");					//response HTTP status resolves to 2xx
printf("			var rt = o.responseText;");
printf("			if(rt.indexOf(\"<P>Invalid form information was found.\")>-1){");	//catch server errors
printf("				FavScreen.log('error',\"getMsgsRecordsetForLibrary(): YUI-IO: Server says, 'Invalid form information was found.' for txn #\"+ioId+\".\",false);");
printf("			}else if(rt.indexOf(\"Unknown form load command. Please logout and login again.\")>-1){");
printf("				FavScreen.log('error',\"getMsgsRecordsetForLibrary(): YUI-IO Txn#\"+ioId+\": Server says, 'Unknown form load command. Please logout and login again.' (\"+rt+\").\",true);");
printf("			}else if(rt.indexOf(\"smcgi stopped\")>-1){");
printf("				FavScreen.log('error',\"getMsgsRecordsetForLibrary(): YUI-IO Txn#\"+ioId+\": Server says, 'smcgi stopped' (\"+rt+\").\",true);");
printf("			}else{");
printf("				FavScreen.log('log',\"getMsgsRecordsetForLibrary(): YUI-IO: Txn #\"+ioId+\" succeeded. Continuing to do whatever we need to do with the response... \",false);");
printf("				var objRS = new Y.Recordset();");					//initialize a new recordset into our global object  (DEV-NOTE: will this overwrite an existing automatically? hope so!)
//printf("				objRS.plug(Y.Plugin.RecordsetFilter);");				//plug-in the filter stuff (access its stuff from the .filter namespace)
//printf("				objRS.plug(Y.Plugin.RecordsetSort);");					//plug-in the sort stuff (access its stuff from the .sort namespace)
printf("				objRS.after('init', function(){");					//subscribe an "after init" event listner to the recordset object (just so we are absolutely certain we attach the next event listener to a fully-initialized object)
printf("					objRS.after('add', function(){");					//subscribe an "after add" event listner to the recordset object to render the favorites list as soon as possible
printf("						result = this;");							//return or save the recordset that has had any record(s) added to it
printf("					});");//end add event listener subscription
printf("				});");//end init event listener subscription
printf("				try{");
printf("					var oData = eval(rt);");						//parse the responseText (a string which represents an object literal) into an object-literal  DEV-NOTE: eval might be the best (only?) way to do this... alternative is to send as JSON Mime Type?
printf("				}catch(err){");
printf("					FavScreen.log('error',\"getMsgsRecordsetForLibrary(): Error doing eval operation on string-response from server...\",false);");
printf("					FavScreen.log('verbose',\"getMsgsRecordsetForLibrary(): Error details ( \"+err+\" ).\",false);");
printf("					var oData = false;");
printf("				}");
printf("				if(!oData){");								//if no data returned
printf("					FavScreen.log('info',\"getMsgsRecordsetForLibrary(): No data available.\",true);");
printf("				}else if(oData[0].exclude_this_from_recordset==true){");		//else-if data returned contains a special first element (containing system/version info)
printf("					var excludedData = oData.splice(0,1);");				//extract the special element from the data and set aside (this removes it from the main data)
printf("				}");
printf("				objRS.add(oData);");							//add our data to the recordset (which will fire the 'after add' stuff above, and actually render the results on the page)
printf("				FavScreen.log('info','CALLED .add()',false);");
printf("				objRS.detachAll();");							//detach those event listeners, so we can reattach other add actions later (like maybe for sorting, adding new, etc... we wouldn't want to call the same function for those)
printf("			}");//end else
printf("			};");
printf("		var handleFailure = function(ioId, o){");					//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			var rt = o.responseText;");
printf("			FavScreen.log('error', \"getMsgsRecordsetForLibrary(): YUI-IO: Txn #\"+ioId+\" failed or timed-out (view 'log' console log for details).\", true);");
printf("			FavScreen.log('verbose', \"getMsgsRecordsetForLibrary(): YUI-IO: Txn #\"+ioId+\"'s responseText returned by server = '\"+rt+\"'\", true);");
printf("			result = rt;");
printf("			};");
printf("		var handleEnd = function(ioId,o){");
printf("			Spinner.hide(FAVS_SPINNER_DELAY_HIDE);");
printf("			};");
printf("		var cfg ={");									//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");						//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");					//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");					//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");						//subscribe the above custom failure handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");							//method will default to GET unless we specify POST here
printf("			data:{");								//whatever fields/data that CGI gets to parse...
printf("				'getSpecifiedUserFavs':'true',");						//smcgi command flag
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));	//authentication of the current user
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP(),");		//ignore any IP-changes, so authentication doesn't break (on mobile networks/devices where IP can change frequently)
printf("				'userPin':strLibUserPin");							//which LIB-user to get messages for
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:true,");								//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:10000");							//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("			};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);						//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		FavScreen.log('info','STARTING',false);");
printf("		objResponse = Y.io(sUrl, cfg);");						//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("		FavScreen.log('info','ENDING - objResponse = '+JSON.stringify(objResponse),false);");
printf("	});");//end YUI.use
//printf("	FavScreen.log('info','EXITING',false);");
printf("	return result;");
printf("}\n");//end function getMsgsRecordsetForLibrary
/* For the specified library (LIB user pin), populate a YUI-Recordset object of its 'FV' type messages (returning wasn't working due to the recordset operation not blocking execution flow, causing this to return undefined */
printf("function populateMsgsRecordsetForLibrary(strLibUserPin, i) {");
printf("	YUI().use('recordset-base', 'recordset-filter', 'recordset-sort', 'io', 'io-base', 'querystring-stringify-simple', function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");						//what should happen when the io txn starts
printf("			FavScreen.log('verbose', \"populateMsgsRecordsetForLibrary(): YUI-IO: Starting txn to get %s from database. YUI-IO txn ID# will be: \"+ioId+\".\", false);", FAVS_NAME_PLURAL);
//printf("			Spinner.show();");
printf("			Spinner.showAfterDelay(200);");						//start the spinner
printf("			};");
printf("		var handleSuccess = function(ioId, o){");					//response HTTP status resolves to 2xx
printf("			var rt = o.responseText;");
printf("			if(rt.indexOf(\"<P>Invalid form information was found.\")>-1){");	//catch server errors
printf("				FavScreen.log('error',\"populateMsgsRecordsetForLibrary(): YUI-IO: Server says, 'Invalid form information was found.' for txn #\"+ioId+\".\",false);");
printf("			}else if(rt.indexOf(\"Unknown form load command. Please logout and login again.\")>-1){");
printf("				FavScreen.log('error',\"populateMsgsRecordsetForLibrary(): YUI-IO Txn#\"+ioId+\": Server says, 'Unknown form load command. Please logout and login again.' (\"+rt+\").\",true);");
printf("			}else if(rt.indexOf(\"smcgi stopped\")>-1){");
printf("				FavScreen.log('error',\"populateMsgsRecordsetForLibrary(): YUI-IO Txn#\"+ioId+\": Server says, 'smcgi stopped' (\"+rt+\").\",true);");
printf("			}else{");
printf("				FavScreen.log('log',\"populateMsgsRecordsetForLibrary(): YUI-IO: Txn #\"+ioId+\" succeeded. Continuing to do whatever we need to do with the response... \",false);");
printf("				var objRS = new Y.Recordset();");					//initialize a new recordset into our global object  (DEV-NOTE: will this overwrite an existing automatically? hope so!)
printf("				objRS.after('init', function(){");					//subscribe an "after init" event listner to the recordset object (just so we are absolutely certain we attach the next event listener to a fully-initialized object)
printf("					objRS.after('add', function(){");					//subscribe an "after add" event listner to the recordset object to render the favorites list as soon as possible
printf("						var numOfMsgs = this.size();");
printf("						FavScreen.log('log',\"populateMsgsRecordsetForLibrary(): YUI-RS after-add event handler detected addition of \"+numOfMsgs+\" msgs for LIB-user, '\"+strLibUserPin+\"'. Copying to FavScreen.objLibsMsgs object.\",true);");
printf("						var currNumMsgSetsReadIn = FavScreen.get('attrNumOfLibrariesMsgSetsReadIn') + 1;");
printf("						FavScreen.set('attrNumOfLibrariesMsgSetsReadIn', currNumMsgSetsReadIn);");
printf("						if(typeof FavScreen.objLibsMsgs === 'object') {");
printf("							FavScreen.objLibsMsgs[i].rsLibMsgs = objRS;");			//copy this newly created (and populated) recordset to the main global one, in the proper library
printf("							if(FavScreen.get('attrNumOfLibrariesMsgSetsReadIn') >= FavScreen.get('attrNumOfLibrariesAvailable')) {"); //if we're apparently finished reading in all lib-msg-sets, trigger a render operation of the libraries section
printf("								FavScreen.log('log',\"populateMsgsRecordsetForLibrary(): YUI-RS after-add event handler now sees \"+FavScreen.get('attrNumOfLibrariesMsgSetsReadIn')+\" of \"+FavScreen.get('attrNumOfLibrariesAvailable')+\" libraries msgs-sets loaded. Rendering libraries section.\",true);");
printf("								renderMessageListSection_libraries(createMessageListNode_subsectionsLibraries(FavScreen.objLibsMsgs, \"subsectionlist-libraries\"));");//PROTOTYPING
printf("							}else{");
printf("								FavScreen.log('log',\"populateMsgsRecordsetForLibrary(): YUI-RS after-add event handler now sees \"+FavScreen.get('attrNumOfLibrariesMsgSetsReadIn')+\" of \"+FavScreen.get('attrNumOfLibrariesAvailable')+\" libraries msgs-sets loaded. Not yet ready to render libraries section.\",true);");
printf("							}");
printf("						}else{");
printf("							FavScreen.log('error',\"populateMsgsRecordsetForLibrary(): YUI-RS after-add event handler failed due to no FavScreen.objLibsMsgs object existing.\",true);");
printf("						}");
printf("					});");//end add event listener subscription
printf("				});");//end init event listener subscription
printf("				try{");
printf("					var oData = eval(rt);");						//parse the responseText (a string which represents an object literal) into an object-literal  DEV-NOTE: eval might be the best (only?) way to do this... alternative is to send as JSON Mime Type?
printf("				}catch(err){");
printf("					FavScreen.log('error',\"populateMsgsRecordsetForLibrary(): Error doing eval operation on string-response from server...\",true);");
printf("					FavScreen.log('verbose',\"populateMsgsRecordsetForLibrary(): Error details ( \"+err+\" ).\",false);");
printf("					var oData = false;");
printf("				}");
printf("				if(!oData){");								//if no data returned
printf("					FavScreen.log('info',\"populateMsgsRecordsetForLibrary(): No data available.\",true);");
printf("				}else if(oData[0].exclude_this_from_recordset==true){");		//else-if data returned contains a special first element (containing system/version info)
printf("					var excludedData = oData.splice(0,1);");				//extract the special element from the data and set aside (this removes it from the main data)
printf("				}");
printf("				objRS.add(oData);");							//add our data to the recordset (which will fire the 'after add' stuff above, and actually render the results on the page)
printf("				objRS.detachAll();");							//detach those event listeners, so we can reattach other add actions later (like maybe for sorting, adding new, etc... we wouldn't want to call the same function for those)
printf("			}");//end else
printf("			};");
printf("		var handleFailure = function(ioId, o){");					//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			var rt = o.responseText;");
printf("			FavScreen.log('error', \"populateMsgsRecordsetForLibrary(): YUI-IO: Txn #\"+ioId+\" failed or timed-out (view 'log' console log for details).\", true);");
printf("			FavScreen.log('verbose', \"populateMsgsRecordsetForLibrary(): YUI-IO: Txn #\"+ioId+\"'s responseText returned by server = '\"+rt+\"'\", false);");
printf("			result = rt;");
printf("			};");
printf("		var handleEnd = function(ioId,o){");
printf("			Spinner.hide(FAVS_SPINNER_DELAY_HIDE);");
printf("			};");
printf("		var cfg ={");									//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");						//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");					//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");					//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");						//subscribe the above custom failure handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");							//method will default to GET unless we specify POST here
printf("			data:{");								//whatever fields/data that CGI gets to parse...
printf("				'getSpecifiedUserFavs':'true',");						//smcgi command flag
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));	//authentication of the current user
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP(),");		//ignore any IP-changes, so authentication doesn't break (on mobile networks/devices where IP can change frequently)
printf("				'userPin':strLibUserPin");							//which LIB-user to get messages for
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:true,");								//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:10000");							//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("			};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);						//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");						//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("	});");//end YUI.use
printf("}\n");//end function 

/* Returns an array of libraries in the required sort order (i.e. standard libraries are first)
 * Note: requires cooperation from smcgi, by providing us with the proper 'sort_order' value. */
printf("function sortedLibrariesArray(arr) {");
printf("	var ret;");
printf("	var arrSortedStdLib = [];");				//initialize a new array for standard libraries
printf("	var arrSortedOthers = [];");				//initialize a new array for anything other than standard libraries
printf("	var arrLength = arr.length;");
printf("	for(var i=0; i<arrLength; i++) {");
printf("		if(arr[i].libUser.sort_order == -1) {");	//if this library has no specified sort order (other than inherently alphabetical which the DB naturally gives us)
printf("			arrSortedOthers.push(arr[i]);");
printf("		}else{");					//else this library is a standard library (it has a server-specified sort order... see smcgi getAllLibUsers= routine)
printf("			arrSortedStdLib.push(arr[i]);");
printf("		}");
printf("	}");
printf("	ret = arrSortedStdLib.concat(arrSortedOthers);");	//concatenate the regular libraries array to the end of the standard libraries array
printf("	return ret;");
printf("}\n");//end function 

/* Get server data for all available library users and save in global space as FavScreen.libraries
 * (makes a syncronous asynchronous request from server for all available LIB-classed users and returns it as the object presented by the sever) */
printf("function getAllLibUsers() {");
//printf("	var result = FavScreen.libraries || undefined;");
printf("	var result;");
printf("	YUI().use(\"io\", \"io-base\", function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("			FavScreen.log('verbose',\"getAllLibUsers(): YUI-IO Txn ID#\"+ioId+\" starting.\",false);");
printf("		};");
printf("		var handleSuccess = function(ioId, o){");						//what should happen when response HTTP status resolves to 2xx
printf("			FavScreen.log('log',\"getAllLibUsers(): YUI-IO Txn ID#\"+ioId+\" succeeded.\",false);");
printf("			var rt = o.responseText;");
printf("			try{");
printf("				var oData = eval(rt);");
printf("			}catch(err){");
printf("				FavScreen.log('error',\"getAllLibUsers(): Error doing eval operation on string-response from server...\",false);");
printf("				FavScreen.log('verbose',\"getAllLibUsers(): Error details ( \"+err+\" ).\",false);");
printf("				var oData = false;");
printf("			}");
printf("			if(!oData){");										//if no valid data was returned
printf("				FavScreen.log('warn',\"getAllLibUsers(): No valid data to parse from server response (raw = '\"+rt+\"').\",true);");
printf("			}");
printf("			result = oData;");
printf("		};");
printf("		var handleFailure = function(ioId, o){");						//what should happen when response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('warn',\"getAllLibUsers(): YUI-IO Txn ID#\"+ioId+\" failed or timed-out.\",false);");
printf("			FavScreen.log('verbose',\"Txn ID#\"+ioId+\"'s responseText returned by server = '\"+o.responseText+\"'\",false);");
printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("			result = o.responseText;");
printf("		};");
printf("		var handleEnd = function(ioId, o){");							//what should happen when YUI-IO transaction is finished
printf("			FavScreen.log('verbose',\"getAllLibUsers(): YUI-IO Txn ID#\"+ioId+\" finished.\",false);");
printf("		};");
printf("		var cfg ={");										//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");							//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");								//subscribe the above custom end handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
printf("				'getAllLibUsers':'true',");							//smcgi command flag
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP()");
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:true,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete)
printf("			timeout:20000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("		};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");								//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("	});");
//printf("	return result;");
printf("	return sortedLibrariesArray(result);");
printf("}\n");//end function getAllLibUsers()

/* Take care of loading all libraries and their messages into memory... Returns an object containing all libraries and their messages. */
printf("function loadLibsAndMsgs(boolSkipInboxRefresh) {");
printf("	FavScreen.log('verbose',\"loadLibsAndMsgs(): Called.\",true);");
printf("	Spinner.show();");
printf("	var skipInboxRefresh = Boolean(boolSkipInboxRefresh);");
printf("	if(typeof boolSkipInboxRefresh === 'object') {");		//if an object (click event object) was passed, then they clicked a manual refresh
printf("		boolSkipInboxRefresh = true;");					//skip inbox refresh
printf("	} else if(typeof boolSkipInboxRefresh === 'undefined') {");	//if nothing was passed
printf("		boolSkipInboxRefresh = false;");				//default the skip flag to false (don't skip inbox refresh)
printf("	}");
printf("	FavScreen.objLibsMsgs = getAllLibUsers();");							//get all LIB users from the server (it's a synchronous async call, so execution should always wait here until something is returned)
printf("	if(typeof FavScreen.objLibsMsgs !== 'object') {");
printf("		FavScreen.log('error',\"loadLibsAndMsgs(): Could not retrieve LIB-users from server. Aborting load.\",true);");
//printf("		Spinner.hide();");
printf("		Spinner.hide(FAVS_SPINNER_DELAY_HIDE);");
printf("		return false;");
printf("	}else{");
printf("		var numOfLibs = FavScreen.objLibsMsgs.length;");
printf("		FavScreen.set('attrNumOfLibrariesAvailable', numOfLibs);");				//save how ever many libraries the system is making available
printf("		FavScreen.set('attrNumOfLibrariesMsgSetsReadIn', 0);");					//reinitialize, since we're apparently loading a fresh set of data (populateMsgsRecordsetForLibrary >> after-add will depend on a correct value to know when to render stuff)
printf("		FavScreen.log('log',\"loadLibsAndMsgs(): Retrieved \"+numOfLibs+\" libraries from server. Now attempting to load messages-recordsets for each one...\",true);");
printf("		for(var i=0; i<numOfLibs; i++) {");
printf("			strLibUserPin = FavScreen.objLibsMsgs[i].libUser.user_pin;");
printf("			strLibTitle = FavScreen.objLibsMsgs[i].libUser.user_title || FavScreen.objLibsMsgs[i].libUser.user_fname || strLibUserPin;");
printf("			FavScreen.log('log',\"loadLibsAndMsgs(): Library #\"+(i+1)+\" (\"+strLibTitle+\"). Loading messages from server...\",true);");
printf("			populateMsgsRecordsetForLibrary(strLibUserPin, i);");
printf("		}");//end for
printf("		if(boolSkipInboxRefresh == false) {");
printf("			refreshRecordset_inboxMsgs(CURRENT_USER_PIN, false, false);");				//refresh the inbox, so it can now have latest icons, if necessary (e.g. an inbox msg needs to show a latest response icon)
				// WARNING: if you change the boolObeyDelay  ^^^^^  to true, inbox icons won't load right automatically
printf("		}");
//printf("		Spinner.hide();");
printf("		Spinner.hide(FAVS_SPINNER_DELAY_HIDE);");
printf("		expandContainer('contentwrapper-libraries');");							//ensure the library section is expanded
printf("		return FavScreen.objLibsMsgs;");
printf("	}");//end if/else
printf("}\n");//end function loadLibsAndMsgs()

printf("function rs_getRawDataObjectFor_favRecno(objRS, strFavRecno){");
printf("	for(var i=0; i<objRS.size(); i++){");							//go through all records in the recordset...
printf("		if(parseInt(objRS.item(i).getValue('recno_fav'))==parseInt(strFavRecno)){");	//if we find the record that was specified...
printf("			return objRS.item(i).get('data');");					//return its complete dataset object
printf("		}");
printf("	}");
printf("}");

/* Create a recordset from an array (nodelist?) of messagecell nodes */
printf("function rs_createRecordsetFromMessageCells(arrDropListItemNodes, boolUpdatePosition){");
printf("	if(typeof arrDropListItemNodes===\"undefined\"){");
printf("		FavScreen.log('error', \"Calling the function rs_createRecordsetFromMessageCells() requires an array of DOM messagecell nodes to be supplied.\", true);");
printf("		return false;");
printf("	}");
printf("	if(arrDropListItemNodes.length <= 0){");
printf("		FavScreen.log('error', \"Calling the function rs_createRecordsetFromMessageCells() requires an valid array of DOM messagecell nodes (at least one) to be supplied.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof boolUpdatePosition===\"undefined\"){");
printf("		boolUpdatePosition = false;");
printf("	}");
printf("	var rs;");
printf("	YUI().use('recordset-base', function(Y){");
printf("		rs = new Y.Recordset();");									//initialize a new recordset
printf("		rs.after('init', function(){");								//subscribe an "after init" event listner to the recordset object (just so we are absolutely certain we attach the next event listener to a fully-initialized object)
printf("			FavScreen.log('verbose', \"rs_createRecordsetFromMessageCells(): YUI-Recordset: Initialized. Waiting for the addition of the most recent set of %s-data from arrDropListItemNodes...\", true);", FAVS_NAME_SINGULAR);
printf("			rs.after('add', function(){");								//subscribe an "after add" event listner to the recordset object to ___________ as soon as possible
printf("				FavScreen.log('log', \"rs_createRecordsetFromMessageCells(): YUI-Recordset: Most recent set of \"+this.size()+\" %s from arrDropListItemNodes added to new recordset.\", true);", FAVS_NAME_PLURAL);
printf("			});");//end add event listener subscription
printf("		});");//end init event listener subscription
printf("		rs.detachAll();");										//detach those event listeners, so we can reattach other add actions later (like maybe for sorting, adding new, etc... we wouldn't want to call the same function for those)
printf("	});");//end YUI.use
printf("	var objData;");
printf("	var i_actualMessagecells_total = 0;");
printf("	var i_actualMessagecells_messages = 0;");
printf("	var i_actualMessagecells_subheaders = 0;");
printf("	var position_fullValue = \"\";");
printf("	for(var i=0; i<arrDropListItemNodes.length; i++){");							//for each LI node in the array given to us...
printf("		if(arrDropListItemNodes[i].getAttribute('class').indexOf(\"messagecell\") === -1) {");			//if this isn't a message cell (might be a header or something), skip it
printf("			if(arrDropListItemNodes[i].getAttribute('class').indexOf(\"subsectionheader\") === -1) {");		//except for subsectionheader items, which should be treated as special kinds of messagecell (e.g. for personal-libs) -- in other words, don't want to execute continue if this is a subsectionheader!
printf("				continue;"); //skip to next iteration
printf("			}");
printf("		}");
printf("		if((arrDropListItemNodes[i].parentNode.getAttribute('id')===null) || (arrDropListItemNodes[i].getAttribute('class')===null)) {");//if this isn't a valid sortable item (implied by no id or class values for it or its parent), skip it
printf("			continue;"); //skip to next iteration
printf("		}");
printf("		if((arrDropListItemNodes[i].parentNode.getAttribute('id').indexOf(\"library\")>-1) && (arrDropListItemNodes[i].getAttribute('class').indexOf(\"libmsg\")==-1)) {");//if this is dropped in library AND isn't actually a real messagecell (could be a title or something), skip it
printf("			continue;"); //skip to next iteration
printf("		}");
printf("		if(arrDropListItemNodes[i].getAttribute('class').indexOf(\"nomessages\") > -1) {");			//if this is the special-case 'nomessages' item, skip it
printf("			continue;"); //skip to next iteration
printf("		}");
printf("		i_actualMessagecells_total++;");									//since we've gotten to an actual messagecell, go ahead and increment the counter in preparation for its record (need a separate counter since the above text may exclude some nodes)
printf("		favRecno = arrDropListItemNodes[i].getAttribute(\"id\");");						//get the recno value from the DOM
printf("		objData = rs_getRawDataObjectFor_favRecno(FavScreen.rsOrig, favRecno) || {};");				//get the rest of the corresponding data for this record, as a record object
printf("		if(objData.position === undefined) {");
printf("			if(arrDropListItemNodes[i].parentNode.getAttribute('id').indexOf(MajorSection_personalLibs.cfg.str_sectionDomID) >= 0) {");
printf("				objData.position = \"P:00000,00000,00000\";");
printf("			}");
printf("		}");
printf("		if(boolUpdatePosition){");										//if we're supposed to update the position field value, figure that out (note: this is based on the present order given in the nodelist arg)...
printf("			var positionPart_typeFlag = objData.position.split(\"%s\")[0];", FAVS_POSITION_DELINEATE_TYPE);		//figure out the letter code
printf("			var positionPart_A = parseInt( objData.position.split(\"%s\")[1].split(\"%s\")[0] );", FAVS_POSITION_DELINEATE_TYPE, FAVS_POSITION_DELINEATE_COORD);//figure out the first coord
printf("			var positionPart_B = parseInt( objData.position.split(\"%s\")[1].split(\"%s\")[1] );", FAVS_POSITION_DELINEATE_TYPE, FAVS_POSITION_DELINEATE_COORD);//figure out the second coord
printf("			var positionPart_C = parseInt( objData.position.split(\"%s\")[1].split(\"%s\")[2] );", FAVS_POSITION_DELINEATE_TYPE, FAVS_POSITION_DELINEATE_COORD);//figure out the third coord
printf("			var droppedInSorted = droppedInUnsorted = droppedInSharedLib = droppedInPersonalLib = false;");		//initialize some statics
printf("			var listNodeId = arrDropListItemNodes[i].parentNode.getAttribute('id');");				//get the id-attribute value of the UL node that the favorite is an item of
printf("			if(listNodeId.indexOf(\"critical\")>-1 && listNodeId.indexOf(\"dropbox\")==-1){");			//if the string "critical" (formerly "sorted") is found in the node's id-attribute value AND "dropbox" (formerly "unsorted") was not found, then this must be dropped on the critical UL node
printf("				droppedInSorted = true;");
printf("			}else if(listNodeId.indexOf(\"dropbox\")>-1){");							//else-if the string "dropbox" (formerly "unsorted") is found in the node's id-attribute value, then this must be dropped on the dropbox UL node
printf("				droppedInUnsorted = true;");
printf("			}else if(listNodeId.indexOf(\"library\")>-1){");							//else-if the string "library" is found in the node's id-attribute value, then this must be dropped on a library UL node
printf("				droppedInSharedLib = true;");
printf("			}else if(listNodeId.indexOf(window.objConfig_MajorSection_personalLibs.str_sectionDomID)>-1){");	//else-if the string "personallibraries" is found in the node's id-attribute value, then this must be dropped on a library UL node
printf("				droppedInPersonalLib = true;");
printf("			}");
				//DEV-NOTE: the following will assign "sorted" (etc.) to EVERY node in this list... is that desired?   <--- WHAT was I talking about here??!
printf("			if(droppedInSorted){");									//if this is in the sorted section...
printf("				positionPart_typeFlag = \"%s\";", FAVS_SORTED_FLAG);					//update the position type flag to "sorted"
printf("				positionPart_A = i_actualMessagecells_total;");						//update the sort-order value with this iteration's messagecell-count (which should correspond to the order in which the messagecells are rendered)
printf("				position_fullValue = positionPart_typeFlag+\"%s\"+padLeadingZeros(positionPart_A,5)+\"%s\"+padLeadingZeros(positionPart_B,5)+\"%s\"+padLeadingZeros(positionPart_C,5);", FAVS_POSITION_DELINEATE_TYPE, FAVS_POSITION_DELINEATE_COORD, FAVS_POSITION_DELINEATE_COORD);
printf("				objData.position = position_fullValue.toString();");
printf("				rs.add(objData);");									//add this record to the recordset
printf("			}else if(droppedInSharedLib){");							//if this is in a library section...
printf("				positionPart_typeFlag = \"%s\";", FAVS_LIBRARY_FLAG);					//update the position type flag to "library"
printf("				positionPart_A = i_actualMessagecells_total;");						//update the sort-order value with this iteration's messagecell-count (which should correspond to the order in which the messagecells are rendered)
printf("				position_fullValue = positionPart_typeFlag+\"%s\"+padLeadingZeros(positionPart_A,5)+\"%s\"+padLeadingZeros(positionPart_B,5)+\"%s\"+padLeadingZeros(positionPart_C,5);", FAVS_POSITION_DELINEATE_TYPE, FAVS_POSITION_DELINEATE_COORD, FAVS_POSITION_DELINEATE_COORD);
printf("				objData.position = position_fullValue.toString();");
printf("				rs.add(objData);");									//add this record to the recordset
printf("			}else if(droppedInPersonalLib){");							//if this is in a personal-library section... there could be nested dimensions, so need to update accordingly
					//NOTE: migrated over to major-class export routine
printf("			}");//end else personal-lib

printf("		}");//end if boolUpdatePosition
printf("	}");//end for
printf("	return rs;");
printf("}\n");//end function rs_createRecordsetFromMessageCells

printf("function rs_getEncodedStringOf(objRS, strFieldName, delimitChar){");						// Return a string encoded with whatever values requested and delimited by whatever is specified (used for sending a single string to the server via HTTP)
printf("	if(!rs_isValidArg_yuiRecordsetObject(objRS)){return false;}");							//we require a valid recordset object
printf("	if(typeof strFieldName===\"undefined\" || typeof delimitChar===\"undefined\"){");				//if arguments weren't supplied, then don't allow this function to continue
printf("		FavScreen.log('error', \"Calling the function rs_getEncodedStringOf() requires all arguments to be supplied (strFieldName = '\"+strFieldName+\"', delimitChar = '\"+delimitChar+\"').\", true);");
printf("		return false;");
printf("	}");//end if
printf("	var strRet = \"\";");
printf("	if(objRS.size()>0){");								
printf("		var arrValues = objRS.getValuesByKey(strFieldName);");
printf("		for(var i=0; i<arrValues.length; i++){");
printf("			if(i>0){strRet+=delimitChar;}");
printf("			if(typeof arrValues[i]===\"undefined\"){");
printf("				FavScreen.log('error', \"Calling the function rs_getEncodedStringOf() seems to result in a problem with the recordset, aborting.\", true);");
printf("				return false;");
printf("			}");
printf("			strRet += arrValues[i];");
printf("		}");
printf("	}");
printf("	else{");
printf("		FavScreen.log('warn', \"Calling the function rs_getEncodedStringOf() should include a valid recordset. Returning empty string.\", true);");
printf("	}");
printf("	return strRet;");
printf("}\n");//end function

//printf("function removeRecordFromRecordset()");						// Remove a record from the recordset
//printf("	}\n");//end function

//printf("function modifyRecord_position()");							// Modify a favorite's position in the list/grid/etc.
//printf("	}\n");//end function

// etc...?
printf("</script>\n");
}


/***********************************************************************
* void add_favSupport_listFormat(void)
*
* 	Supporting JavaScript functions to read/manage the YUI favorites  
* 	recordset and display it to the user in a list format.
*
* 	NOTE: remember that none of this will work until after the page finishes loading (because that's when YUI takes effect)
*
***********************************************************************/
void add_favSupport_listFormat(void)
{
printf("<script type=\"text/javascript\">\n");

//WILL DEPRECATE? (because of instead using ClassMajorSection stuff)
printf("function renderMessageListSection_sorted(objNode_ul, boolReplaceContents){");			// Render a list of favorites on-screen in the 'sorted' section... returns the actual number of sorted favorites should be showing on-screen
printf("	if(typeof objNode_ul==='undefined'){");
printf("		FavScreen.log('error', \"Calling renderMessageListSection_sorted() requires a list node object argument to be supplied.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof boolReplaceContents==='undefined'){");
printf("		boolReplaceContents = true;");								//default to replace contents (might seem less buggy to the user that way?)
printf("		FavScreen.log('verbose', \"renderMessageListSection_sorted() was called without providing a value for boolReplaceContents... defaulting boolReplaceContents to: \"+boolReplaceContents+\".\", false);");
printf("	}");
printf("	var ret = 0;");
printf("	var node_contentwrapper = document.getElementById(\"contentwrapper-sorted\");");		//get a handle for the sorted container node
printf("	if(node_contentwrapper != null){");
printf("		if(objNode_ul.childNodes.length==1 && objNode_ul.children[0].innerHTML.toString().indexOf('%s')>-1){", FAVS_DEFAULT_NOFAVSTODISPLAYHTML);//if it looks like there are no sorted favorites, set the return value to 0
printf("			ret = 0;");
printf("		}else{");
printf("			ret = objNode_ul.childNodes.length;");
printf("		}");
printf("		if(boolReplaceContents && node_contentwrapper.childNodes.length>0){");
printf("			node_contentwrapper.removeChild(node_contentwrapper.childNodes[0]);");			//remove any existing list node (should be 0 if the only one) from the sorted content wrapper (should just be the FAVS_DEFAULT_NOFAVSTODISPLAYHTML text)
printf("		}");
printf("		node_contentwrapper.appendChild(objNode_ul);");							//render supplied list node (sorted favs) onto page inside the main sorted section
printf("		node_contentwrapper.style.visibility = \"visible\";");
printf("		FavScreen.set('attrIsCurrentlyVisible_sorted', true);");					//set our attribute flag that indicates that the sorted favs are currently rendered on the screen
printf("		updateMessagecells();");
printf("		attachActionListenersToMessageCells(\"ul#messagelist-sorted\");");				//now that favorites are visible on-screen, attach event listeners to them
//printf("		hideNativeSpinner();");										//handle hiding any native spinner that may be showing (function handles platform/version validation)
printf("		return ret;");
printf("	}else{");
printf("		FavScreen.log('info',\"renderMessageListSection_sorted(): node_contentwrapper is null. Aborting.\",false);");
printf("		return ret;");
printf("	}");
printf("}\n");
//WILL DEPRECATE? (because of instead using ClassMajorSection stuff)
printf("function checkForUnsortedAndManageAuxVisibility(){");						// Check if any unsorted favorites are visible and show/hide that entire aux-1 section depending on the result
printf("	try {");
//printf("		var w1=document.getElementById(\"aux1headingdiv\");");						//get a reference to the unsorted section's heading (the 'unsorted favs' text and up 'drag-to-sort' arrows)
//printf("		var w2=document.getElementById(\"contentwrapper-aux1\");");					//get a reference to the unsorted list's wrapper
printf("		var w2=document.getElementById(\"contentwrapper-dropbox\");");					//get a reference to the unsorted list's wrapper
printf("		var n=document.getElementById(\"messagelist-unsorted-1\");");					//get a reference to the unsorted list node
printf("		if(n===null || n.childNodes.length==0){");							//if no list item nodes were rendered, don't display the aux section...
//printf("			w1.style.visibility=\"hidden\";");
printf("			w2.style.visibility=\"hidden\";");
printf("		}");
printf("		else if(n.childNodes.length==1 && n.childNodes[0].innerHTML.indexOf(\"%s\")>-1){", FAVS_DEFAULT_NOFAVSTODISPLAYHTML);//if no list item nodes were rendered, don't display the aux section...
//printf("			w1.style.visibility=\"hidden\";");
printf("			w2.style.visibility=\"hidden\";");
printf("		}");
printf("		else{");											//else show the aux section...
//printf("			w1.style.visibility=\"visible\";");
printf("			w2.style.visibility=\"visible\";");
printf("		}");
printf("	} catch(err) {");
printf("		FavScreen.log('info',\"checkForUnsortedAndManageAuxVisibility(): Caught error (\"+err.message+\"). Probably okay, since this will be deprecated.\",true);");
printf("	}");
printf("}\n");
//WILL DEPRECATE? (because of instead using ClassMajorSection stuff)
printf("function renderMessageListSection_unsorted(objNode_ul, boolReplaceContents){");			// Render a list of unsorted favorites on-screen in the 'aux' section (also handles other things if needed - e.g. showing an unsorted in a blank sorted section)
printf("	if(typeof objNode_ul==='undefined'){");
printf("		FavScreen.log('error', \"Calling renderMessageListSection_unsorted() requires a list node object argument to be supplied.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof boolReplaceContents==='undefined'){");
printf("		boolReplaceContents = true;");									//default to replace contents (might seem less buggy to the user that way?)
printf("		FavScreen.log('verbose', \"renderMessageListSection_unsorted() was called without providing a value for boolReplaceContents... defaulting boolReplaceContents to: \"+boolReplaceContents+\".\", false);");
printf("	}");
printf("	function doUnsortedAux1() {");
printf("		node_contentwrapper = document.getElementById(\"contentwrapper-aux1\");");			//get a handle for our aux container node
printf("		if(boolReplaceContents && node_contentwrapper.childNodes.length>0){");				//if we are to replace contents and there are actually contents to replace, then...
printf("			node_contentwrapper.removeChild(node_contentwrapper.childNodes[0]);");			//remove any existing list node (should be 0 if the only one) from the aux content wrapper (should just be old unsorted favs list)
printf("		}");	
printf("		node_contentwrapper.appendChild(objNode_ul);");							//render list node (non-sorted favs) onto page in the auxilliary section
printf("		FavScreen.set('attrIsCurrentlyVisible_unsorted', true);");					//set our attribute flag that indicates that the unsorted favs are currently rendered on the screen
printf("	}");
printf("	function addSectionHeader() {");								//kinda a temporary patch to get dropbox header right until you finish making the proper section class
printf("		var objNode_sectionHeader = document.createElement('li');");					//create an LI node for the section header we're going to create
printf("		    objNode_sectionHeader.className = \"messagecell sublistheader roundedtopcorners8\";");	//assign CLASS attribute/values
printf("		    objNode_sectionHeader.innerHTML = \"%s\";", FAVS_SECTION_TITLE_DROPBOX);			//give the DropBox its text
printf("		objNode_ul.insertBefore(objNode_sectionHeader, objNode_ul.childNodes[0])");			//insert the new header at the beginning of the list (before the first child)
printf("	}");
printf("	if((document.getElementById(\"contentwrapper-sorted\")!=null) && (document.getElementById(\"contentwrapper-aux1\")!=null) ){");
printf("		var node_contentwrapper;");									//initialize a handle
			//if no sorted favs appear to be showing (either by checking the attribute, which we hope is right, or by examining the list node itself to be safe), then we need to see if there are any unsorted to show in the sorted area and show one if so...
printf("		if(FavScreen.get('attrNumSortedFavsDisplaying')==0 ");
printf("		   || document.getElementById('messagelist-sorted').childNodes[0].innerHTML.toString().indexOf('%s')>-1){", FAVS_DEFAULT_NOFAVSTODISPLAYHTML);
printf("			FavScreen.log('info', \"No sorted %s were apparently rendered on-screen, so rendering an unsorted %s in the sorted section, while rendering any remaining others in the unsorted section.\", true);", FAVS_NAME_PLURAL, FAVS_NAME_SINGULAR);
				//DEV-NOTE: consider not using a hard-coded rsOrig_unsorted below?
printf("			var node_ulForSrt = createMessageListNode(FavScreen.rsOrig_unsorted, \"messagelist-sorted\", \"\", \"sorted\");");//get a temporary list node for unsorted favs (we'll only keep the first child LI in it, and then put this list in the sorted section)
printf("			for(var i=node_ulForSrt.childNodes.length-1; i>0; i--){");				//loop through all LI nodes in the UL node, beginning with the last one and working toward the first one, till we only get the first one
printf("				node_ulForSrt.removeChild(node_ulForSrt.childNodes[i]);");			//delete the LI node (shouldn't be the first node, as per our for-loop constraints)
printf("			}");
printf("			node_contentwrapper = document.getElementById(\"contentwrapper-sorted\");");		//get a handle for our sorted contentwrapper node
printf("			if(boolReplaceContents && node_contentwrapper.childNodes.length>0){");			//if we are to replace contents and there are actually contents to replace, then...
printf("				node_contentwrapper.removeChild(node_contentwrapper.childNodes[0]);");		//remove any existing list node from the sorted content wrapper (should just be the FAVS_DEFAULT_NOFAVSTODISPLAYHTML text)
printf("			}");
printf("			node_contentwrapper.appendChild(node_ulForSrt);");					//render list node (with the single unsorted fav, which we want to show as sorted) onto page in the main sorted section
printf("			FavScreen.set('attrIsCurrentlyVisible_sorted', true);");				//set our attribute flag that indicates that a "sorted" favs list is currently rendered on the screen
printf("			attachActionListenersToMessageCells(\"ul#messagelist-sorted\");");			//attach event listeners to the unsorted message that's now in the sorted section
printf("			if(objNode_ul.childNodes.length>1){");							//if there was more than just that one unsorted message, let's render them next (don't need to render an unsorted section for just one fav since the message will be rendered in the sorted section)
printf("				objNode_ul.removeChild(objNode_ul.childNodes[0]);");				//remove the first unsorted fav from this node, since it should now be in the other node rendered as sorted (since it's just one, we can get away with hard-coding a 0 for the index)
printf("				doUnsortedAux1();");
printf("			}");
printf("		}");
printf("		else{");										//else there apparently are actual sorted favorites in the sorted section, so don't do anything with it (just work with unsorted section...)
printf("			doUnsortedAux1();");
printf("		}");
printf("		addSectionHeader();");
printf("		checkForUnsortedAndManageAuxVisibility();");
printf("		updateMessagecells();");
//printf("		if(objNode_ul.childNodes.length!=1 && objNode_ul.childNodes[0].indexOf('%s')<=-1) {", FAVS_DEFAULT_NOFAVSTODISPLAYHTML);
printf("		attachActionListenersToMessageCells(\"ul#messagelist-unsorted-1\");");
//printf("		}");
printf("	}else{");
printf("		FavScreen.log('info',\"renderMessageListSection_unsorted(): node_contentwrapper is null. Aborting.\",false);");
printf("	}");
printf("}\n");
/*
printf("function renderMessageListSection_inboxMsgs(objNode_ul, boolReplaceContents){");			// Render a list of messages on-screen in the 'inbox' section... returns the actual number of list items that should be showing on-screen
printf("	if(typeof objNode_ul==='undefined'){");
printf("		FavScreen.log('error', \"renderMessageListSection_inboxMsgs(): Functin requires a unordered-list node object to be specified.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof boolReplaceContents==='undefined'){");
printf("		boolReplaceContents = true;");								//default to replace contents (might seem less buggy to the user that way?)
printf("		FavScreen.log('log', \"renderMessageListSection_inboxMsgs(): Function was called without providing a value for boolReplaceContents... defaulting boolReplaceContents to: \"+boolReplaceContents+\".\", false);");
printf("	}");
printf("	var ret = 0;");
printf("	var node_contentwrapper = document.getElementById(\"contentwrapper-inboxmsgs\");");		//get a handle for the inbox-messages container node
printf("	if(node_contentwrapper != null){");
printf("		if(objNode_ul.childNodes.length==1 && objNode_ul.children[0].innerHTML.toString().indexOf('%s')>-1){", FAVS_DEFAULT_NOFAVSTODISPLAYHTML);//if it looks like there are no sorted favorites, set the return value to 0
printf("			ret = 0;");
printf("		}else{");
printf("			ret = objNode_ul.childNodes.length;");
printf("		}");
printf("		if(boolReplaceContents && node_contentwrapper.childNodes.length>0){");
printf("			node_contentwrapper.removeChild(node_contentwrapper.childNodes[0]);");			//remove any existing list node (should be 0 if the only one) from the sorted content wrapper (should just be the FAVS_DEFAULT_NOFAVSTODISPLAYHTML text)
printf("		}");
printf("		node_contentwrapper.appendChild(objNode_ul);");							//render supplied list node (sorted favs) onto page inside the main sorted section
printf("		FavScreen.set('attrIsCurrentlyVisible_sorted', true);");					//set our attribute flag that indicates that the sorted favs are currently rendered on the screen
printf("		updateMessagecells();");
printf("		attachActionListenersToMessageCells(\"ul#messagelist-sorted\");");				//now that favorites are visible on-screen, attach event listeners to them
printf("		return ret;");
printf("	}else{");
printf("		FavScreen.log('info',\"renderMessageListSection_sorted(): node_contentwrapper is null. Aborting.\",false);");
printf("		return ret;");
printf("	}");
printf("}\n");
*/
printf("function renderMessageListSection_deleted(objNode_ul){");					// Render a list of deleted favorites on-screen in the 'aux' section (but the aux should be the only one showing)
printf("	if(typeof objNode_ul==='undefined'){");
printf("		FavScreen.log('error', \"Calling renderMessageListSection_deleted() requires a list node object argument to be supplied.\", true);");
printf("		return false;");
printf("	}");
printf("	var ret;");
printf("	if(objNode_ul.childNodes.length==1 && objNode_ul.children[0].innerHTML.toString().indexOf('%s')>-1){", FAVS_DEFAULT_NOFAVSTODISPLAYHTML);//if it looks like there are no sorted favorites, set the return value to 0
printf("		ret = 0;");
printf("	}");
printf("	else{");
printf("		ret = objNode_ul.childNodes.length;");
printf("	}");
printf("	document.getElementById(\"contentwrapper-aux1\").appendChild(objNode_ul);");			//render supplied list node (deleted favs) onto page in its own section
printf("	FavScreen.set('attrIsCurrentlyVisible_deleted', true);");						//set our attribute flag that indicates that the deleted favs are currently rendered on the screen
printf("	attachActionListenersToMessageCells(\"ul#messagelist-unsorted-1\");");
printf("	return ret;");
printf("}\n");
printf("function renderMessageListSection_libraries(objNode_ul, boolReplaceContents){");		// Render a list of favorites on-screen in the 'libraries' section... returns the actual number of library favorites should be showing on-screen
printf("	if(typeof objNode_ul==='undefined'){");
printf("		FavScreen.log('error', \"Calling renderMessageListSection_libraries() requires a list node object argument to be supplied.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof boolReplaceContents==='undefined'){");
printf("		boolReplaceContents = true;");								//default to replace contents (might seem less buggy to the user that way?)
printf("		FavScreen.log('verbose', \"renderMessageListSection_libraries() was called without providing a value for boolReplaceContents... defaulting boolReplaceContents to: \"+boolReplaceContents+\".\", false);");
printf("	}");
printf("	var ret = 0;");
printf("	var node_contentwrapper = document.getElementById(\"contentwrapper-libraries\");");		//get a handle for the libraries container node
printf("	if(node_contentwrapper != null){");
//printf("		if(objNode_ul.childNodes.length==1 && objNode_ul.children[0].innerHTML.toString().indexOf('%s')>-1){", FAVS_DEFAULT_NOFAVSTODISPLAYHTML);//if it looks like there are no sorted favorites, set the return value to 0
//printf("			ret = 0;");
//printf("		}else{");
//printf("			ret = objNode_ul.childNodes.length;");
//printf("		}");
printf("		if(boolReplaceContents && node_contentwrapper.childNodes.length>0){");
printf("			node_contentwrapper.removeChild(node_contentwrapper.childNodes[0]);");			//remove any existing list node (should be 0 if the only one) from the sorted content wrapper (should just be the FAVS_DEFAULT_NOFAVSTODISPLAYHTML text)
printf("		}");
printf("		node_contentwrapper.appendChild(objNode_ul);");							//render supplied list node (sorted favs) onto page inside the main sorted section
printf("		node_contentwrapper.style.visibility = \"visible\";");
//printf("		FavScreen.set('attrIsCurrentlyVisible_libraries', true);");					//set our attribute flag that indicates that the sorted favs are currently rendered on the screen
//printf("		updateMessagecells();");
//printf("		attachActionListenersToMessageCells(\"ul#messagelist-sorted\");");				//now that favorites are visible on-screen, attach event listeners to them
//printf("		hideNativeSpinner();");										//handle hiding any native spinner that may be showing (function handles platform/version validation)
printf("		return ret;");
printf("	}else{");
printf("		FavScreen.log('info',\"renderMessageListSection_libraries(): node_contentwrapper is null. Aborting.\",false);");
printf("		return ret;");
printf("	}");
printf("}\n");
printf("function renderMessageListSection_library(objNode_ul, boolReplaceContents){");			// Render a list of favorites on-screen in a specific library sub-section... returns the actual number of library favorites should be showing on-screen
printf("	if(typeof objNode_ul==='undefined'){");
printf("		FavScreen.log('error', \"Calling renderMessageListSection_library() requires a list node object argument (for a particular library sublist) to be supplied.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof boolReplaceContents==='undefined'){");
printf("		boolReplaceContents = true;");								//default to replace contents (might seem less buggy to the user that way?)
printf("		FavScreen.log('verbose', \"renderMessageListSection_library() was called without providing a value for boolReplaceContents... defaulting boolReplaceContents to: \"+boolReplaceContents+\".\", false);");
printf("	}");
printf("	var ret = 0;");
//get library from supplied node, if possible (otherwise, will need to supply it)
printf("	var nodeIdToReplace = objNode_ul.id;");								//get the ID attribute value string of the node-object passed to this function (it should hopefully match whatever may be in the document)
printf("	var objNodeToReplace = document.getElementById(nodeIdToReplace);");				//get a reference to the complementary DOM node in the document
printf("	var objNodeToReplace_parent = objNodeToReplace.parentNode;");					//get a reference to that node's parent (should be the LI/container node for the UL-list)
printf("	objNodeToReplace_parent.replaceChild(objNode_ul, objNodeToReplace);");
printf("}\n");

/* DEV-NOTE... PSEUDOCODE...
 * Need to "decouple" messagecell updating from the drag-drop events as best as possible.
 * At the very last drag-drop event, call a function to do the updating...
 * 	Update the dragged-dropped messagecell node's styles to be appropriate for wherever it's been dropped.
 * 	Update the dragged-dropped messagecell node's data-listpositionindex value to an appropriate value for its dropped-position.
 * 	Update all other messagecell nodes' data-listpositionindex values so that they're incremented by 1.
 * 	Check for any other styling that needs to be done (e.g. if no more unsorted messagecell nodes exist, hide that section, etc.)
 */
//printf("function handleMessageCellUpdates_afterDragAndDropEvent(e){");						// Basically, after a drag-drop completes, this updates messagecell nodes (particularly, sort-order) and generates an rsEdited recordset matching the new sort order --that could then be used to update DB, etc.
//printf("	var drag = e.target.get('node');");									//get a reference to the LI node that was being dragged
//printf("	var drop = e.drop.get('node');");									//get a reference to the UL node where the LI was being dropped
printf("function handleMessageCellUpdates_afterDragAndDropEvent(drag, drop){");					// Basically, after a drag-drop completes, this updates messagecell nodes (particularly, sort-order) and generates an rsEdited recordset matching the new sort order --that could then be used to update DB, etc.
printf("	var droppedInCritical = droppedInDropbox = droppedInSharedLib = droppedInPersonalLib = false;");	//initialize some static flags
printf("	var dropNodeId = drop.get('id');");									//get the id-attribute value of the UL node that they dropped the favorite onto
printf("	var listID_critical = window.objConfig_MajorSection_critical.str_sectionDomID;");			//get the DOM ID value we'd expect of the UL list in the critical section
printf("	var listID_personalLibs = window.objConfig_MajorSection_personalLibs.str_sectionDomID;");		//get the DOM ID value we'd expect of the UL list in the personal-libraries section
printf("	var listID_sharedLibs = \"library\";");									//DEV-NOTE: hard coded for now, since there are nested UL lists in this section
printf("	var listID_dropbox = window.objConfig_MajorSection_dropbox.str_sectionDomID;");				//get the DOM ID value we'd expect of the UL list in the dropbox section
printf("	if(dropNodeId.indexOf(listID_critical)>-1 && dropNodeId.indexOf(listID_dropbox)==-1){");		//if the string configured for the critical (formerly "sorted") section is found in the node's id-attribute value AND "dropbox" (formerly "unsorted") was not found, then this must be dropped on the critical UL node
printf("		droppedInCritical = true;");
printf("	}else if(dropNodeId.indexOf(listID_dropbox)>-1){");							//else-if the string configured for the dropbox (formerly "unsorted") section's ID is found in the node's id-attribute value, then this must be dropped on the dropbox UL node
printf("		droppedInDropbox = true;");
printf("	}else if(dropNodeId.indexOf(listID_sharedLibs)>-1){");							//else-if the string configured for a shared-lib is found in the UL-node's id-attribute value, then this must be dropped on a lib-user's library UL node
printf("		droppedInSharedLib = true;");
printf("	}else if(dropNodeId.indexOf(listID_personalLibs)>-1){");						//else-if the string configured for the personal-lib section's ID is found in the UL-node's id-attribute value, then this must be dropped on a user's personal libraries UL node
printf("		droppedInPersonalLib = true;");
printf("	}");
printf("	if(droppedInCritical){");										//if the above testing indicates that the favorite was dropped in the sorted section (need to make it appear like a sorted and rearrange list index numbers)
printf("		FavScreen.log('log', \"handleMessageCellUpdates_afterDragAndDropEvent() detects %s dropped into critical section.\", true);", FAVS_NAME_SINGULAR);
printf("		var arrDropListItems = drop.getElementsByTagName('li');");					//gets an array of YUI-ized LI objects
//printf("		var arrDropListItemsNodes = drop.getDOMNode().getElementsByClassName('messagecell');");		//gets an array of YUI-ized LI objects (new way since we don't want heading-LI nodes)
printf("		var arrDropListItemNodes = arrDropListItems.getDOMNodes();");
printf("		var arrDropListItemNodes_idValues = arrDropListItems.getAttribute('id');");			//get an array of the list's nodes' id-attribute values
			//RESTYLE DROPPED MESSAGECELLNODE
printf("		var drag_attribute_class = drag.getAttribute('class');");					//gets the value specified in the dragged node's class attribute	DEV-NOTE: looks like setting this will also set the dropped version... good?
printf("		drag_attribute_class = drag_attribute_class.replace(\"dropbox\", \"critical\");");		//change the "dropbox" (formerly "unsorted") class substring to "critical" (formerly "sorted") so we can put it back into the node to make it look like a regular critical favorite when the drag-drop is complete
printf("		drag.setAttribute('class', drag_attribute_class);");						//modify the class of the dragged node so it will look like a regular sorted favorite
			//UDPATE NODES
//printf("		var arrDropListItemNodes_length = arrDropListItemNodes.length;");
//printf("		var i_listPositionIndex;");
//printf("		var i_listPositionIndex_cached;");
//printf("		for(var i=0; i<arrDropListItemNodes_length; i++){");	//for each LI now in the sorted UL node (including the one we just dragged-and-dropped there)
//printf("			FavScreen.log('log', arrDropListItemNodes[i], true);");
//printf("			if(FavScreen.get('attrBrowserSupports_dataset')){");
//printf("				i_listPositionIndex = parseInt(arrDropListItemNodes[i].dataset.listpositionindex);");//get this favorite's listpositionindex value
//printf("			}else{");
//printf("				i_listPositionIndex = parseInt(arrDropListItemNodes[i].getAttribute(\"data-listpositionindex\"));");//get this favorite's listpositionindex value
//printf("			}");
//printf("			if(i+1==i_listPositionIndex){");							//if this iteration's index matches the favorite's listpositionindex (it means we're, so far, in proper order -nothing yet reordered by user), then go to next iteration w/out doing anything
//printf("				continue;");
//printf("			}");
//printf("			else{");										//else we've hit our first (and subsequent) sort-order change
//printf("			}");
//printf("		}");
			//UPDATE SORTED RECORDSET
//printf("		Spinner.show();");
printf("		Spinner.showAfterDelay();");
printf("		var newRS = rs_createRecordsetFromMessageCells(arrDropListItemNodes, true);");			//create a new recordset containing the now-sorted favorites, and update position (true)
//printf("		newRS.each(function(){");
//printf("			var objThisRecord = this.get('data');");
//printf("			var thisRecnoFav = objThisRecord.recno_fav;");
//DEV-NOTE: should have a "save-all" feature the user can click to do the following
//printf("			FavScreen.log('log', \"Sending updated data to server for favorite recno \"+thisRecnoFav+\".\", true);");
//printf("			sendUpdatedRecordToSMCGI(objThisRecord);");
//printf("		});");
printf("		FavScreen.rsEdited = newRS;");
printf("		Spinner.hide();");
printf("	}");
printf("	else if(droppedInDropbox){");										//else-if dropped in the unsorted section (probably don't want them to do this, anyway? no issue?)
printf("		FavScreen.log('info', \"handleMessageCellUpdates_afterDragAndDropEvent() detects %s dropped into dropbox section. Aborting function, since this isn't allowed.\", true);", FAVS_NAME_SINGULAR);
printf("		return false;");
printf("	}");
printf("	else if(droppedInSharedLib){");										//else-if dropped in a lib-user's library sub-section
printf("		var libList = drop.getDOMNode();");
printf("		var libList_containerLI = libList.parentNode;");
printf("		var li_data_userpin;");
printf("		if(FavScreen.get('attrBrowserSupports_dataset')){");							//acquire this library's userpin data attribute for testing authorization...
printf("			li_data_userpin = libList_containerLI.dataset.userpin;");
printf("		}else{");
printf("			li_data_userpin = libList_containerLI.getAttribute(\"data-userpin\");");
printf("		}");
printf("		if(li_data_userpin == CURRENT_USER_PIN) {");								//verify whether the current user is a LIB user, authorized to drop messagecells into this (their own) library's drop position
printf("			FavScreen.log('log',\"handleMessageCellUpdates_afterDragAndDropEvent() detects %s dropped into LIB-user's (\"+li_data_userpin+\") library sub-section.\",true);", FAVS_NAME_SINGULAR);
printf("			var arrDropListItems = drop.getElementsByTagName('li');");					//gets an array of YUI-ized LI objects
printf("			var arrDropListItemNodes = arrDropListItems.getDOMNodes();");
printf("			var arrDropListItemNodes_idValues = arrDropListItems.getAttribute('id');");			//get an array of the list's nodes' id-attribute values
				//RESTYLE DROPPED MESSAGECELLNODE
printf("			var drag_attribute_class = drag.getAttribute('class');");					//gets the value specified in the dragged node's class attribute	DEV-NOTE: looks like setting this will also set the dropped version... good?
printf("			drag_attribute_class = drag_attribute_class.replace(\"dropbox\", \"libmsg\");");		//change the potential "dropbox" (formerly "unsorted") class substring to "libmsg" so we can put it back into the node to make it look like a regular library favorite when the drag-drop is complete
printf("			drag_attribute_class = drag_attribute_class.replace(\"critical\", \"libmsg\");");		//change the potential "critical" (formerly "sorted") class substring to "libmsg" so we can put it back into the node to make it look like a regular library favorite when the drag-drop is complete
printf("			drag.setAttribute('class', drag_attribute_class);");						//modify the class of the dragged node so it will look like a regular sorted favorite
				//TODO if the "(no-messages)" LI exists, remove it	-- NO? refresh should take care of this? ---- not quite, also should remove it dynamically (before any DB update & refresh is performed).. but could we also "refresh" based on current recordset data (what would get posted)?
				//UPDATE SORTED RECORDSET
printf("			Spinner.showAfterDelay();");
printf("			var newRS = rs_createRecordsetFromMessageCells(arrDropListItemNodes, true);");			//create a new recordset containing the now-sorted favorites, and update position (true)
printf("			FavScreen.rsEdited = newRS;");
printf("			Spinner.hide();");

printf("		}else{");
printf("			FavScreen.log('warn',\"handleMessageCellUpdates_afterDragAndDropEvent() detects %s dropped into invalid LIB-user's (\"+li_data_userpin+\") library sub-section (current user is \"+CURRENT_USER_PIN+\"). This is a fail-safe situation (it'll be ugly to the user) but nothing will be saved.\",true);", FAVS_NAME_SINGULAR);
printf("		}");
printf("	}");
printf("	else if(droppedInPersonalLib) {");
printf("		FavScreen.log('log', \"handleMessageCellUpdates_afterDragAndDropEvent() detects %s dropped into personal-libs section.\", true);", FAVS_NAME_SINGULAR);
printf("		var arrDropListItems = drop.getElementsByTagName('li');");					//gets an array of YUI-ized LI objects
printf("		if(arrDropListItems._nodes[1].getAttribute('class') == 'nomessages') {");
printf("			arrDropListItems._nodes[1].remove();");								//remove the 'no-msgs' LI right away (and before any logic gets built on it)
printf("		}");
printf("		var arrDropListItemNodes = arrDropListItems.getDOMNodes();");
printf("		var arrDropListItemNodes_idValues = arrDropListItems.getAttribute('id');");			//get an array of the list's nodes' id-attribute values
			//RESTYLE DROPPED MESSAGECELLNODE
printf("		var drag_attribute_class = drag.getAttribute('class');");					//gets the value specified in the dragged node's class attribute	DEV-NOTE: looks like setting this will also set the dropped version... good?
printf("		drag_attribute_class = drag_attribute_class.replace(\"dropbox\", \"personallibs\");");		//change the "dropbox" (formerly "unsorted") class substring to "critical" (formerly "sorted") so we can put it back into the node to make it look like a regular critical favorite when the drag-drop is complete
printf("		drag_attribute_class = drag_attribute_class.replace(\"critical\", \"personallibs\");");		//change the "dropbox" (formerly "unsorted") class substring to "critical" (formerly "sorted") so we can put it back into the node to make it look like a regular critical favorite when the drag-drop is complete
printf("		drag.setAttribute('class', drag_attribute_class);");						//modify the class of the dragged node so it will look like a regular sorted favorite
			//UPDATE SORTED RECORDSET
printf("		Spinner.showAfterDelay();");
printf("		var newRS = MajorSection_personalLibs.exportListAsYuiRecordset();");
printf("		FavScreen.rsEdited = newRS;");
printf("		Spinner.hide();");
printf("	}");
printf("	else{");												//else some other unforseen case
printf("		FavScreen.log('warn', \"handleMessageCellUpdates_afterDragAndDropEvent() else case encountered. Aborting function.\", true);");
printf("		return false;");
printf("	}");
printf("}\n");//end function handleMessageCellUpdates_afterDragAndDropEvent()

//printf("arrFldsReqForResolved = [");
//printf("	{fldKey:'ldata_', fldDesc:'ldata', enabled:true, dataTypeReq:undefined, dataLenReq:-1}");
//printf("	];");
printf("function formContainsUnresolvedFields(data) {");							// Perform tests to determine whether we deem a form (i.e. message) to be "resolved" or not (returns: -1:undetermined, 0+:minimum number of unresolved flds)
printf("	if(typeof data === 'string') {");									//if we were given a string, assume it's responseText
printf("		var cfg_strSplitKey = '<input ';");								//specify the string to split on (will be made case-insensitive in regex below)
printf("		var cfg_strSplitKey2 = '<textarea ';");								//specify the string to split on (will be made case-insensitive in regex below)
//printf("		var regex = new RegExp('('+cfg_strSplitKey+')', 'gi');");
printf("		var regex = new RegExp('('+cfg_strSplitKey+'|'+cfg_strSplitKey2+')', 'gi');");	//DEV-NOTE: untested... just an idea, if you ever need to grab other field types
printf("		var arrInputFields = data.split(regex);");
printf("		if(arrInputFields.length > 1) {");	//our array will always have at least one element, even if nothing found (thanks to the way .split() works)... so we test for more than one
				//first, get an array of parsed fields...
printf("			var fldName, fldValue;");
printf("			var j = 0;");										//initialize a counter for populating the new array
printf("			var arrParsedFields = [];");
printf("			for(var i=1; i<arrInputFields.length; i++) {");						//for each field found, parse the name/value pair... and save into array if determined to be unresolved (start at 1, so as to skip the first one which is nothing we care about, thanks to split)
printf("				if( arrInputFields[i].toUpperCase() == cfg_strSplitKey.toUpperCase()");			//we don't care about the key we use to split (since we know it), so skip it to get to next element (which should contain the data we do care about)
printf("				 || arrInputFields[i].toUpperCase() == cfg_strSplitKey2.toUpperCase()");		//we don't care about the key we use to split (since we know it), so skip it to get to next element (which should contain the data we do care about)
printf("				 || arrInputFields[i].toLowerCase().indexOf('</input>\\\';') > -1");			//we also don't care about javascript-string fields   NOTE: if migrating this to JS file, be careful with escape sequence ~should be:  indexOf('type=\"button\"')
printf("				 || arrInputFields[i].toLowerCase().indexOf('type=\\\"button\\\"') > -1");		//we also don't care about button fields   NOTE: if migrating this to JS file, be careful with escape sequence ~should be:  indexOf('type=\"button\"')
printf("				 || arrInputFields[i].toLowerCase().indexOf('type=\\\"hidden\\\"') > -1 ) {");		//we also don't care about hidden fields   NOTE: if migrating this to JS file, be careful with escape sequence ~should be:  indexOf('type=\"hidden\"')
printf("					continue;");									//skip to next iteration
printf("				}");//end if test for skipping field iterations
printf("				try {");
						//DEV-NOTE: the following two parse operations will fail if not in the right order... consider using regular-expressions if there are problems!
printf("					fldName = arrInputFields[i].split('name=\\\"')[1].split('\\\" ')[0];");		//try to parse the field name   NOTE: if migrating this to JS file, be careful with escape sequence
printf("					fldValue = arrInputFields[i].split('value=\\\"')[1].split(/(\\\" |\\\">|\\\" >)/i)[0];");//try to parse the field value   NOTE: if migrating this to JS file, be careful with escape sequence
printf("				} catch(err) {");
printf("					fldName = undefined;");
printf("					fldValue = undefined;");
printf("					FavScreen.log('warn','formContainsUnresolvedFields(): Caught a problem parsing data to populate arrInputFields (err='+err+') (iter='+arrInputFields[i]+').',true);");
printf("				}");
printf("				arrParsedFields[j] = [];");
printf("				arrParsedFields[j][0] = arrInputFields[i];");						//save raw iteration data
printf("				arrParsedFields[j][1] = fldName;");							//save ascertained-above field name
printf("				arrParsedFields[j][2] = fldValue;");							//save ascertained-above field value
printf("				j++;");
printf("			}");
				//then, go through that array, testing for unresolved fields
printf("			var j = 0;");										//initialize a counter for how many unresolved fields are detected
printf("			var k = 0;");										//initialize a counter for how many undeterminable fields
printf("			for(var i=0; i<arrParsedFields.length; i++) {");					//for each parsed field, try to examine it to determine number of unresolved fields to return
printf("				try {");
printf("					if( (arrParsedFields[i][2].length == 0)");					//if value is blank, then the field may be unresolved... do && tests for other conditions
//printf("					 && (arrParsedFields[i][1].toLowerCase() != 'user_text')");			// and this isn't the 'user_text' field (which seems to be everywhere, and may be allowed to be blank)
printf("						){");//begin if...
printf("						j++;");										//increment counter
printf("					}");
printf("					else if( (arrParsedFields[i][1].toLowerCase().indexOf('wholemsg') > -1)");	//else-if this is the #wholemsg field, then we need to count it as being unresolved in all cases - for now (per Kevin, 3/17/15) ... in case updateable or something?
printf("						){");//begin if...
printf("						j++;");										//increment counter
printf("					}");
printf("				} catch(err) {");
printf("					FavScreen.log('warn','formContainsUnresolvedFields(): Caught a problem testing for unresolved field (err='+err+') (iter='+arrParsedFields[i][0]+'), continuing without incrementing counter.',true);");
printf("					k++;");
printf("					continue;");
printf("				}");
printf("			}");
printf("			FavScreen.log('log','formContainsUnresolvedFields(): Completed. Out of '+arrParsedFields.length+' total parsed fields: '+j+' unresolved and '+k+' undetermined (see warning log for details).',true);");
printf("			return j;");
printf("		} else {");
printf("			FavScreen.log('info',\"formContainsUnresolvedFields(): Data does not contain any '\"+cfg_strSplitKey+\"' fields.\",true);");
printf("			return -1;");
printf("		}");
printf("	}");
printf("	else {");
printf("		FavScreen.log('warn','formContainsUnresolvedFields(): Invalid argument, aborting with error.',true);");
printf("		return -1;");
printf("	}");
printf("}\n");//end function formContainsUnresolvedFields()

printf("function launchFavoritePreCheck(favRecno){");								// Do various pre-checking before possible launch. This basically just returns false to interrupt the launch, if necessary (and ONLY if necessary, otherwise returns true by default)
printf("	var ret = true;");											//configure a default return value of true
printf("	cfg_autoHideTimeout = 5 * 1000;");
printf("	var favConfirmSend = rsRec_getConfirmSend(FavScreen.rsOrig, favRecno);");				//get the favorite's confirmSend encoded flag
printf("	if(favConfirmSend>0){");										//if the favorite has some kind of confirmSend flag, see if it applies to this session...
printf("		if(FavScreen.get('attrDeviceType')==DEVICETYPE_PHONE && (favConfirmSend==%d || favConfirmSend==%d || favConfirmSend==%d || favConfirmSend==%d)){", FAVS_CONFIRMSEND_PHONE, FAVS_CONFIRMSEND_PHONETABLET, FAVS_CONFIRMSEND_PHONEPC, FAVS_CONFIRMSEND_ALL);
printf("			FavScreen.log('log', \"launchFavoritePreCheck(): User must confirm send for phone (attrDeviceType=\"+FavScreen.get('attrDeviceType')+\", favConfirmSend=\"+favConfirmSend+\").\", false);");
printf("			ConfirmLaunch.showFor(favRecno, cfg_autoHideTimeout);");					//it's now up to the custom dialog to restart the launch process, depending on the user's action there
printf("			return false;");										//return false, so the main launch process will abort
printf("		}");
printf("		else if(FavScreen.get('attrDeviceType')==DEVICETYPE_TABLET && (favConfirmSend==%d || favConfirmSend==%d || favConfirmSend==%d || favConfirmSend==%d)){", FAVS_CONFIRMSEND_TABLET, FAVS_CONFIRMSEND_PHONETABLET, FAVS_CONFIRMSEND_TABLETPC, FAVS_CONFIRMSEND_ALL);
printf("			FavScreen.log('log', \"launchFavoritePreCheck(): User must confirm send for tablet (attrDeviceType=\"+FavScreen.get('attrDeviceType')+\", favConfirmSend=\"+favConfirmSend+\").\", false);");
printf("			ConfirmLaunch.showFor(favRecno, cfg_autoHideTimeout);");					//it's now up to the custom dialog to restart the launch process, depending on the user's action there
printf("			return false;");										//return false, so the main launch process will abort
printf("		}");
printf("		else if(FavScreen.get('attrDeviceType')==DEVICETYPE_PC && (favConfirmSend==%d || favConfirmSend==%d || favConfirmSend==%d || favConfirmSend==%d)){", FAVS_CONFIRMSEND_PC, FAVS_CONFIRMSEND_PHONEPC, FAVS_CONFIRMSEND_TABLETPC, FAVS_CONFIRMSEND_ALL);
printf("			FavScreen.log('log', \"launchFavoritePreCheck(): User must confirm send for PC (attrDeviceType=\"+FavScreen.get('attrDeviceType')+\", favConfirmSend=\"+favConfirmSend+\").\", false);");
printf("			ConfirmLaunch.showFor(favRecno, cfg_autoHideTimeout);");					//it's now up to the custom dialog to restart the launch process, depending on the user's action there
printf("			return false;");										//return false, so the main launch process will abort
printf("		}");
printf("		else{");
printf("			FavScreen.log('log', \"launchFavoritePreCheck(): Configured confirmSend not required on this device (attrDeviceType=\"+FavScreen.get('attrDeviceType')+\", favConfirmSend=\"+favConfirmSend+\"). Continuing launch process...\", false);");
printf("			return true;");											//return true, so the main launch process will proceed
printf("		}");
printf("	}");//end if confirmSend
printf("	else {");
printf("		FavScreen.log('info', \"launchFavoritePreCheck(): Could not determine any confirmSend flag for favRecno='\"+favRecno+\"'. Msg may not exist in the 'rsOrig' recordset.\", false);");
			//DEV-NOTE: develop other checks, to be more detailed
printf("	}");
printf("	FavScreen.log('log', \"launchFavoritePreCheck(): No explicit results, so returning default value of '\"+ret+\"'.\", false);");
printf("	return ret;");												//if we've made it to here for some reason, just allow the launch process to continue by returning the default 'true' value set above
printf("}\n");//end function launchFavoritePreCheck()

//printf("var evtHandleClickMessageCells = false;\n");
//printf("var popupHandle;");	//if using popup method
printf("var iframeHandle;");	//if using iframe method
printf("var arrEventHandles = [];");
printf("var objEventHandles_forSorting = {};");
/* Initiate the "launch" process. Note, this may include a launch that's in-reply to something, as well! In which case, the favRecno arg will be the recno of what they're replying-to (e.g. inbox record)
 * 	Required:	favRecno
 *  	Optional:	skipPreCheck */
printf("function launchFavorite(favRecno,skipPreCheck){");							// Initiate the launch process (favRecno is required, skipPreCheck is optional and is ignored if no true-boolean provided)
printf("	if(typeof favRecno===\"undefined\"){");									//if required arg not present, then abort
printf("		FavScreen.log('error', \"launchFavorite(\"+favRecno+\"): Requires favRecno arg. Aborting.\", true);");
printf("		return false;");											//abort 
printf("	}");
printf("	if(skipPreCheck==true){");										//if directed to skip pre-check, then don't call it...
printf("		FavScreen.log('log', \"launchFavorite(\"+favRecno+\"): 'skipPreCheck'='\"+skipPreCheck+\"'. Skipping pre-check...\", true);");
printf("	}else{");												//else do the pre-check, by default
printf("		FavScreen.log('log', \"launchFavorite(\"+favRecno+\"): Running pre-check...\", true);");
printf("		if(launchFavoritePreCheck(favRecno)){");
printf("			FavScreen.log('verbose', \"launchFavorite(): Pre-check returned true. Launch process shall now proceed...\", true);");
printf("		}else{");
printf("			FavScreen.log('verbose', \"launchFavorite(): Pre-check returned false. Launch process interrupted. See details in 'launchFavoritePreCheck' log. Aborting.\", true);");
printf("			return false;");
printf("		}");
printf("	}");
printf("	var currInteractionMode = FavScreen.get('attrInteractionMode');");
printf("	if(currInteractionMode == MODE_LAUNCHABLE) {");								//if we're in launch-mode...
printf("		FavScreen.log('log',\"LaunchFavorite(): Current mode is '\"+FavScreen.get('attrInteractionMode')+\"', proceeding accordingly...\",true);");
printf("		var xLog = \"\";");
printf("		var msgTemplateRecno = rsRec_getMsgTemplateRecno(FavScreen.rsOrig, favRecno);");			//get the message template recno that this favorite message points to, by looking it up in the YUI recordset using this event's node's ID value --which is the fav-msg recno
printf("		var msgTemplateName = rsRec_getMsgTemplateName(FavScreen.rsOrig, favRecno);");				//get the message template name that this favorite message points to, by looking it up in the YUI recordset using this event's node's ID value --which is the fav-msg recno
printf("		var msgTemplateDir = rsRec_getMsgTemplateDir(FavScreen.rsOrig, favRecno);");				//get the message template's directory that this favorite message points to, by looking it up in the YUI recordset using this event's node's ID value --which is the fav-msg recno
printf("	}");
printf("	else if(currInteractionMode == MODE_REPLYING) {");							//if we're in reply-mode...
printf("		FavScreen.log('log',\"LaunchFavorite(): Current mode is '\"+FavScreen.get('attrInteractionMode')+\"', proceeding accordingly...\",true);");
printf("		var xLog = \"-in-reply-to-msg\";");
printf("		var msgTemplateRecno = favRecno;");									//just for logging (in this case, it won't get submitted to the server)
printf("		var msgTemplateName = '(n/a, replying)';");								//just for logging (in this case, it won't get submitted to the server)
printf("		var msgTemplateDir = '(n/a, replying)';");								//just for logging (in this case, it won't get submitted to the server)
printf("	}");
printf("	else {");												//else we're NOT in a valid mode to continue!
printf("		FavScreen.log('warn', \"launchFavorite(): Aborting... not in a valid mode (\"+FavScreen.get('attrInteractionMode')+\"). Perhaps a 'launch' or 'reply' on-click event listener may have failed to detach.\", true);");
printf("		return false;");
printf("	}");
//printf("	if(FavScreen.get('attrInteractionMode')==MODE_LAUNCHABLE ");						//just an insurance-policy.. make sure we don't launch messages if we aren't in launchable mode (can happen if an on-click event listener fails to detach or something)
//printf("	|| FavScreen.get('attrInteractionMode')==MODE_REPLYING){");
//DEV-NOTE: if launch use rsOrig... if reply use another (rsInbox or FavScreen.objMsgData_replyTo?)
printf("		var objServerResponse;");
printf("		YUI().use('io-base', function(Y){");
printf("			var handleStart = function(ioId, o){");							//what should happen when the io txn starts
//printf("				Spinner.show();");
printf("				Spinner.showAfterDelay(200);");						//start the spinner
printf("				FavScreen.log('verbose', \"launchFavorite(): YUI-IO: Starting txn to request msg launch\"+xLog+\" (msg template recno \"+msgTemplateRecno+\")... YUI-IO txn ID# will be: \"+ioId+\".\", true);");
printf("				};");
printf("			var handleSuccess = function(ioId, o){");						//response HTTP status resolves to 2xx
printf("				var rt = o.responseText;");
printf("				FavScreen.log('log', \"launchFavorite(): YUI-IO (txn#\"+ioId+\"):   Txn #\"+ioId+\" succeeded (\"+Date()+\"), checking server response...\", true);");
				      //check response for favorites-version info...
printf("				var strFavsVersionFlagToCatch = \"favoritesVersionOnServer_\";");			//mark the beginning of the string in the response that should contain the server's favorites-version info
printf("				var strFavsVersionFlagToCatchEND = \"_favoritesVersionOnServerEndflag\";");		//mark the end of the string in the response that should contain the server's favorites-version info
printf("				var favsVersionStringFound = rt.indexOf(strFavsVersionFlagToCatch);");	//scan responseText for the matching string... returns 0-based character location if found, otherwise returns -1.
printf("				var favsVersionSubstringBegins = favsVersionStringFound+strFavsVersionFlagToCatch.length;");//figure out the position at which the meat of the version info begins
printf("				var favsVersionSubstringEnds = rt.indexOf(strFavsVersionFlagToCatchEND);");	//figure out the position after which the meat of the version info ends
printf("				var favsVersion_server = rt.substring(favsVersionSubstringBegins,favsVersionSubstringEnds);");//extract out the meat of the version info substring
				      //check response for favorites-build info...
//printf("				var strFavsBuildFlagToCatch = \"favoritesBuildOnServer_\";");				//mark the beginning of the string in the response that should contain the server's favorites-build info
//printf("				var strFavsBuildFlagToCatchEND = \"_favoritesBuildOnServerEndflag\";");			//mark the end of the string in the response that should contain the server's favorites-build info
//printf("				var favsBuildStringFound = rt.indexOf(strFavsBuildFlagToCatch);");			//scan responseText for the matching string... returns 0-based character location if found, otherwise returns -1.
//printf("				var favsBuildSubstringBegins = favsBuildStringFound+strFavsBuildFlagToCatch.length;");	//figure out the position at which the meat of the build info begins
//printf("				var favsBuildSubstringEnds = rt.indexOf(strFavsBuildFlagToCatchEND);");			//figure out the position after which the meat of the build info ends
//printf("				var favsBuild_server = rt.substring(favsBuildSubstringBegins,favsBuildSubstringEnds);");//extract out the meat of the build info substring
				      //check response for favorites apple native app version info...
/*
printf("				var strFavsAppleAppVersionFlagToCatch = \"favoritesAppleAppVersionOnServer_\";");	//mark the beginning of the string in the response that should contain the server's favorites-version info
printf("				var strFavsAppleAppVersionFlagToCatchEND = \"_favoritesAppleAppVersionOnServerEndflag\";");//mark the end of the string in the response that should contain the server's favorites-version info
printf("				var favsAppleAppVersionStringFound = rt.indexOf(strFavsAppleAppVersionFlagToCatch);");	//scan responseText for the matching string... returns 0-based character location if found, otherwise returns -1.
printf("				var favsAppleAppVersionSubstringBegins = favsAppleAppVersionStringFound+strFavsAppleAppVersionFlagToCatch.length;");//figure out the position at which the meat of the version info begins
printf("				var favsAppleAppVersionSubstringEnds = rt.indexOf(strFavsAppleAppVersionFlagToCatchEND);");//figure out the position after which the meat of the version info ends
printf("				var favsAppleAppVersion_server = rt.substring(favsAppleAppVersionSubstringBegins,favsAppleAppVersionSubstringEnds);");//extract out the meat of the version info substring
*/
				      //check response for explicit acknowledgement...
printf("				var strStatusFlagToCatch = \"acknowledgestatus_\";");					//specify the acknowledgement flag that we should scan the response for (provided by smcgi.c:acknowledge())
printf("				var strStatusFlagToCatchEND= \"_endflag\";");						//specify the string that indicates the end of the acknowledgement flag
printf("				var ackStringFound = rt.indexOf(strStatusFlagToCatch);");				//scan responseText for the matching string... returns 0-based character location if found, otherwise returns -1.
printf("				if(ackStringFound==-1){");								//if no acknowledge/status flag (which comes explicitly from acknowledge()) was found in the response...
printf("					if(rt.indexOf(\"Invalid form information was found.\")>-1){");				//if smcgi is returning a bad authentication check
printf("						FavScreen.log('warn', \"launchFavorite(): YUI-IO (txn#\"+ioId+\"): Could not authenticate (server says 'Invalid form information was found').\", true);");
printf("						Spinner.hide();");									//go ahead and hide spinner now, so masks and stuff aren't messed up when the modal-notification shows next...
printf("						ModalNotification_LaunchFailure.showFor(2000);");
printf("					}");
printf("					else if(rt.indexOf(\"%s\")>-1){", FAVS_RESPONSE_CODE_ERROR_LAUNCH);			//else if smcgi is returning a problem creating a banner record (deleted msg-template or something)
printf("						FavScreen.log('warn', \"launchFavorite(): YUI-IO (txn#\"+ioId+\"): Banner record could be created, but doesn't match what favorites is sending.\", true);");
printf("						Spinner.hide();");									//go ahead and hide spinner now, so masks and stuff aren't messed up when the modal-notification shows next...
printf("						ModalNotification_MessageUnavailable.showFor(2500);");
printf("					}");
printf("					else if(rt.indexOf(\"%s\")>-1){", FAVS_RESPONSE_CODE_ERROR_LAUNCH_UNAVAILABLE);		//else if smcgi is returning a problem creating a banner record (deleted msg-template or something)
printf("						FavScreen.log('warn', \"launchFavorite(): YUI-IO (txn#\"+ioId+\"): Could not create banner record. Perhaps message was deleted.\", true);");
printf("						Spinner.hide();");									//go ahead and hide spinner now, so masks and stuff aren't messed up when the modal-notification shows next...
printf("						ModalNotification_MessageUnavailable.showFor(2500);");
printf("					}");
printf("					else if(rt.indexOf(\"Click to cancel sending this message.\")>-1){");			//else if smcgi is sending us a page that may be trying to get the user to resolve an unresolved message... we need to pop it
//printf("					else if((rt.indexOf(\"Click to cancel sending this message.\")>-1) || (rt.indexOf(\"Inbox Reply\")>-1)){");			//else if smcgi is sending us a page that may be trying to get the user to resolve an unresolved message... we need to pop it
printf("						if(currInteractionMode == MODE_REPLYING) {");						//if we're replying, then it's possible that we may have gotten here, even with a fully-resolved msg... so test for that
printf("							var unresolvedFields = formContainsUnresolvedFields(rt);");				//determine however many unresolved fields might exist in the response
printf("							if(unresolvedFields < 0) {");								//if number of unresolved fields was not able to be determined
printf("								FavScreen.log('info','launchFavorite(): Reply-with message has an undetermined number of unresolved fields (check formContainsUnresolvedFields log for details why).',true);");
printf("							}");
printf("							else if(unresolvedFields > 0) {");							//else-if some number of unresolved fields, then need to allow continuation of this branch to provide a popup/iframe with which to resolve the message-in-reply
printf("								FavScreen.log('log','launchFavorite(): Reply-with message seems to have '+unresolvedFields+' unresolved fields, so need to present user with iframe/popup.',true);");
printf("							}");
printf("							else {");										//else there seems to be no unresolved fields, so should just launch the message in-reply
printf("								if( FavScreen.get('attrCurrentResponseRule') === ENCODED_RESPONSE_RULE_2");		//but, if we're here and a reply-msg-name is defined, we should show them legacy iframe (even though it's resolved), because they could've got here directly from clicking the reply icon
printf("								 || FavScreen.get('attrCurrentResponseRule') === ENCODED_RESPONSE_RULE_3 ) {");
printf("									FavScreen.log('log','launchFavorite(): Should not directly launch reply, even though it is defined and resolved.',true);");
printf("								}");
printf("								else {");
printf("									FavScreen.log('log','launchFavorite(): Reply-with message seems to have NO unresolved fields, so need to just launch it in-reply.',true);");
printf("									sendReplyToMsg();");
printf("									return;");
printf("								}");
printf("							}");
printf("						}");
if(isLoadedOnMobileDevice()) 															//just using this method to save network traffic, only giving the client what it needs
	{ /* iframe method only... */
	printf("					iframeHandle = replaceDocumentContentsToResolveMsg(rt);");
	printf("					var iframeHandle_document = iframeHandle.contentWindow.document || iframeHandle.contentDocument;");
	printf("					if(rt.indexOf(\"SetFormIsLoaded\")>-1 && iframeHandle_document!=false){");		//if this function exists in the html, have the new window call it (since by using this method, the onbodyload event doesn't fire)
	printf("						iframeHandle.contentWindow.setTimeout(\"SetFormIsLoaded()\",1500);");
	printf("						setTimeout(hideNativeSpinner,1500);");							//handle hiding any native spinner that may be showing (function handles platform/version validation)
	printf("					}");
	printf("					overrideIframeWindowMethod_open(\"iframe_toResolveMsg\");");
	printf("					overrideIframeWindowMethod_close(\"iframe_toResolveMsg\");");
	printf("					iframeHandle.onload = function(){ iframeHandle.contentWindow.SetFormIsLoaded(); };");		//assign this in case the iframe's document changes (e.g. they hit 'save' in legacy note field or something)
	}
else
	{ /* try popup method first... if that doesn't work (e.g. blocked or something), fall back to the iframe method */
	printf("					FavScreen.log('log',\"launchFavorite(): YUI-IO (txn#\"+ioId+\"):   Trying to pop open a new window (since in a normal browser) to resolve the message before it can be launched\"+xLog+\".\",false);");
	printf("					popupHandle = popupNewWindowForSMCGI_resolveMsg(\"SMPersonalPage\", rt);");	//DEV-NOTE: to open resolve-msg in same window on PC, comment this out and it will fall back to iframe method
	printf("					if(typeof popupHandle===\"undefined\" || !popupHandle){");
	printf("						FavScreen.log('info',\"launchFavorite(): YUI-IO (txn#\"+ioId+\"):   Failed to pop open a new window to resolve the message before it can be launched\"+xLog+\". Falling back to iframe method.\",false);");
	printf("						iframeHandle = replaceDocumentContentsToResolveMsg(rt);");
	printf("						var iframeHandle_document = iframeHandle.contentWindow.document || iframeHandle.contentDocument;");
	printf("						if(rt.indexOf(\"SetFormIsLoaded\")>-1 && iframeHandle_document!=false){iframeHandle.contentWindow.setTimeout(\"SetFormIsLoaded()\",1500);}");//if this function exists in the html, have the new window call it (since by using this method, the onbodyload event doesn't fire)
	printf("						overrideIframeWindowMethod_open(\"iframe_toResolveMsg\");");
	printf("						overrideIframeWindowMethod_close(\"iframe_toResolveMsg\");");
	printf("						iframeHandle.onload = function(){ iframeHandle.contentWindow.SetFormIsLoaded(); };");		//assign this in case the iframe's document changes (e.g. they hit 'save' in legacy note field or something)
	printf("					}else{");
	printf("						if(rt.indexOf(\"SetFormIsLoaded\")>-1){popupHandle.setTimeout(\"SetFormIsLoaded()\",1500);}");//if this function exists in the html, have the new window call it (since by using this method, the onbodyload event doesn't fire)
	printf("					}");
	}
printf("					}");
printf("					else if(rt.indexOf(\"smcgi stopped\")>-1){");
printf("						FavScreen.log('error',\"launchFavorite(): YUI-IO (txn#\"+ioId+\"): Server says, 'smcgi stopped' (\"+rt+\").\",true);");
printf("						Spinner.hide();");									//go ahead and hide spinner now, so masks and stuff aren't messed up when the modal-notification shows next...
printf("						ModalNotification_LaunchFailure.showFor(2000);");
printf("					}");
printf("					else if(rt.indexOf(\"MessageNet Connections is presently:\")>-1){");
printf("						if(rt.indexOf(\"stopped or is restarting and has not completed\")>-1){");
printf("							FavScreen.log('error',\"launchFavorite(): YUI-IO (txn#\"+ioId+\"): Server says, 'MessageNet Connections is presently stopped or is restarting and has not completed' (\"+rt+\").\",true);");
printf("							Spinner.hide();");									//go ahead and hide spinner now, so masks and stuff aren't messed up when the modal-notification shows next...
printf("							ModalNotification_LaunchFailure.showFor(2000);");
printf("						}");
printf("					}");
printf("					else if(rt.indexOf(\"This message has already been responded to.\")>-1){");
printf("						FavScreen.log('warn',\"launchFavorite(): Server returns 'This message has already been responded to.'\",true);");
//printf("alert('msg already responded to');");
printf("					}");
printf("					else if(rt.indexOf(\"Inbox Reply\")>-1){");
printf("						FavScreen.log('error',\"launchFavorite(): Server returns 'Inbox Reply' which means the reply-with message didn't get understood by the server.\",true);");
printf("					}");
						//DEV-NOTE: add any more else-if cases in this area, as needed... e.g. jump-dir, etc.
printf("					else{");
printf("						FavScreen.log('error', \"launchFavorite(): YUI-IO (txn#\"+ioId+\"): Unrecognized server-response. Raw responseText returned by server... (next log entry)\", true);");
printf("						FavScreen.log('warn', rt, true);");
printf("						Spinner.hide();");									//go ahead and hide spinner now, so masks and stuff aren't messed up when the modal-notification shows next...
printf("						ModalNotification_GeneralError.showFor(2000);");
printf("					}");
printf("				}");
printf("				else{");										//else, the responseText DID contain an acknowledge/status flag (which comes explicitly from acknowledge())... so parse it and figure out the status
printf("					var iFlagBegins = ackStringFound+strStatusFlagToCatch.length;");			//figure out the character position of the actual flag value that we care about
printf("					var iFlagEnd = rt.indexOf(strStatusFlagToCatchEND);");					//figure out the character position of the end of the actual flag value that we care about
printf("					var strFlagValue = rt.substring(iFlagBegins,iFlagEnd);");				//extract what should be the flag value
printf("					var arrResponses = new Array();");							//an array of strings to configure with whatever strings we want to parse the server response for, along with descriptions for help debugging
//printf("					arrResponses[X] = new Array();");							//DEVELOPER! -- populate the array with whatever error strings you want to parse the server response for, like this (must include all sub-elements)
//printf("					arrResponses[X][0] = \"STRING TO SEARCH THE SERVER'S RESPONSETEXT FOR\";");
//printf("					arrResponses[X][1] = \"HELPFUL DESCRIPTION OF WHAT THE SERVER RESPONSE STRING MEANS\";");
//printf("					arrResponses[X][2] = \"CONSOLE LOG LEVEL [' error | warn | info | log ']\";");
printf("					arrResponses[0] = new Array();");
printf("					arrResponses[0][0] = \"delayed\";");
printf("					arrResponses[0][1] = \"the message will be sent later.\";");
printf("					arrResponses[0][2] = \"log\";");
printf("					arrResponses[1] = new Array();");
printf("					arrResponses[1][0] = \"delayedcancel\";");
printf("					arrResponses[1][1] = \"the delayed launch message was cancelled.\";");
printf("					arrResponses[1][2] = \"log\";");
printf("					arrResponses[2] = new Array();");
printf("					arrResponses[2][0] = \"sentlaunchtemplate\";");
printf("					arrResponses[2][1] = \"the message has been entered.\";");
printf("					arrResponses[2][2] = \"log\";");
printf("					arrResponses[3] = new Array();");
printf("					arrResponses[3][0] = \"sentfirstname\";");						//DEV-NOTE: this might get sent to us in many cases... add to the else-if above, if needed
printf("					arrResponses[3][1] = \"the message was sent.\";");
printf("					arrResponses[3][2] = \"log\";");
printf("					arrResponses[4] = new Array();");
printf("					arrResponses[4][0] = \"sentelse\";");							//DEV-NOTE: this should be the "normal" sent status?
printf("					arrResponses[4][1] = \"the message was sent.\";");
printf("					arrResponses[4][2] = \"log\";");
printf("					arrResponses[5] = new Array();");
printf("					arrResponses[5][0] = \"cancel\";");
printf("					arrResponses[5][1] = \"the message was stopped.\";");
printf("					arrResponses[5][2] = \"log\";");
printf("					arrResponses[6] = new Array();");
printf("					arrResponses[6][0] = \"closed\";");
printf("					arrResponses[6][1] = \"the message was closed.\";");
printf("					arrResponses[6][2] = \"log\";");
printf("					for(var i=0; i<arrResponses.length; i++){");						//go through the array of possible responses and see if any match what was returned by the server...
printf("						if(arrResponses[i][0]===strFlagValue){");					//if a match was found, then it seems as though the send was successful, so let the user know...
printf("							var thisActiveCopyRecno = 0;");

							//get relevant latest data from that piggybacked on the response...
							//first, toggle/active-copy data...
printf("							if(rt.indexOf('active_copies_for_fav') > -1) {");	//if server returned an up-to-date active-copies string, use that to definitively activate toggle if needed (or anything else) - note: if multiple, you should follow FIFO rule (e.g. newest at end?)
printf("								var activeCopiesStringFromServer = rt.split('active_copies_for_fav')[1].split('value=')[1].split('></input>')[0].split('\"')[1].toString();");
printf("								arrActiveCopyRecnosForFV = activeCopiesStringFromServer.split(',');");							//convert the string to an array, using its comma delimiter
printf("								arrActiveCopyRecnosForFV.splice(arrActiveCopyRecnosForFV.length-1, 1);");						//strip off last element in the array (which should be a useless comma since our comma delimiter is at the end)
printf("								thisActiveCopyRecno = arrActiveCopyRecnosForFV[arrActiveCopyRecnosForFV.length-1];");
printf("								rsRec_updateActiveCopyRecnoString_forFav(FavScreen.rsOrig, favRecno, activeCopiesStringFromServer);");
printf("							}");
printf("							if(rt.indexOf('toggle_duration') > -1) {");	//if server returned an up-to-date toggle_duration string, use that in case we need to know whether to activate toggle if still active (or anything else)
printf("								var toggleDurationStringFromServer = rt.split('toggle_duration')[1].split('value=')[1].split('></input>')[0].split('\"')[1].toString();");
printf("								rsRec_updateToggleDurationString_forFav(FavScreen.rsOrig, favRecno, toggleDurationStringFromServer);");
printf("								if(rt.indexOf('toggle_end_dtsec') > -1) {");	//if server returned an up-to-date toggle_end_dtsec string, use that in case we need to know whether to activate toggle if still active (or anything else)
printf("									var toggleEndDtsecStringFromServer = rt.split('toggle_end_dtsec')[1].split('value=')[1].split('></input>')[0].split('\"')[1].toString();");
printf("									if(toggleEndDtsecStringFromServer == \"NeedToCalculate\") {");
printf("										toggleEndDtsecStringFromServer = getCurrentDtsec_serverEstimate() + parseInt(toggleDurationStringFromServer, 10);");
printf("									}");
printf("									rsRec_updateToggleEndDtsecString_forFav(FavScreen.rsOrig, favRecno, toggleEndDtsecStringFromServer.toString());");
printf("								}");
printf("							}");

printf("							Spinner.hide();");							//go ahead and hide spinner now, so masks and stuff aren't messed up when the modal-notification shows next...
printf("							ModalNotification_OK.showFor(2000);");					//note: safari on iOS doesn't seem to be obeying setTimeout.. takes like 5 seconds no matter what value is here
printf("							FavScreen.log(arrResponses[i][2], \"launchFavorite(): YUI-IO (txn#\"+ioId+\"): Server response contains '\"+arrResponses[i][0]+\"', which means \"+arrResponses[i][1], true);");

							//respond to update client software if needed...
//printf("							if(favsBuild_server!=FavScreen.get('attrBuild')){");
//printf("								FavScreen.log('info', \"launchFavorite(): Build of client software (\"+FavScreen.get('attrBuild')+\") is different than what's available on the server (\"+favsBuild_server+\").\", true);");
//printf("							}");//end if
printf("							if(favsVersion_server!=FavScreen.get('attrVersion')){");
printf("								FavScreen.log('info', \"launchFavorite(): Version of client software (\"+FavScreen.get('attrVersion')+\") different than what's available on the server (\"+favsVersion_server+\").\", false);");
printf("								FavScreen.log('log', \"launchFavorite(): User informed to close/reload %s to get the latest version. They can either restart, cancel or close the window, next.\", false);", FAVS_NAME_FULL);
printf("								if(UpdateSoftware.initialized==true){UpdateSoftware.showFor(30000);}");//show the alert prompt to update the software by reloading
printf("							}");//end if
/*
if(isLoadedInMobileApp()) //DEV-NOTE: later, also distinguish between apple and android
	{
	printf("						if(parseFloat(favsAppleAppVersion_server)>parseFloat(parseAppVersionFromUA())){");
	printf("							FavScreen.log('info',\"launchFavorite(): Version of native app (\"+parseAppVersionFromUA()+\") is older than what's available in the Apple App-Store (\"+favsAppleAppVersion_server+\").\",false);");
	printf("							FavScreen.log('log',\"launchFavorite(): User is being informed to get the latest version from the App-Store.\",false);");
	printf("							if(UpdateSoftware_AppleApp.initialized==true){UpdateSoftware_AppleApp.showFor(30000);}");//show the alert prompt to update the software
	printf("						}");//end if
	}
*/

							//refresh to get latest up-to-date data from server (maybe deprecate this, if we can piggyback latest data on response?)
//printf("							refreshRecordset(\"%s\", true, false);", CurrentUserPin);		//just make sure we have the latest favorites to display (note: this was happening before banner could finish updating, sometimes)
//printf("							setTimeout(function(){refreshRecordset(\"%s\",true,false);},1000);", CurrentUserPin);		//just make sure we have the latest favorites to display (note: this would be the one to deprecate? - not inbox below?)
printf("							setTimeout(function(){refreshRecordset_inboxMsgs(\"%s\",false,false);},1500);", CurrentUserPin);//make sure we have the latest inbox data (but use a delay, to give server/banner time to actually update before reading its database)

printf("							setTimeout(function(){");
printf("								setOrUnsetToggleTimeoutFor(favRecno);");
//printf("								updateMessagecells();");
printf("								}, 300);");

printf("							setTimeout(function(){");
//printf("								setOrUnsetToggleTimeoutFor(favRecno);");
printf("								updateMessagecells();");
printf("								}, 600);");

printf("							return;");								//get out of this function(handleComplete)
printf("						}");//end if
printf("					}");//end for
printf("					FavScreen.log('error', \"launchFavorite() YUI-IO (txn#\"+ioId+\"): Unrecognized server-response. Raw responseText returned by server... (next log entry)\", true);");
printf("					FavScreen.log('warn', rt, true);");
printf("				}");//end else
printf("				};");//end handleSuccess
printf("			var handleFailure = function(ioId, o){");						//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("				FavScreen.log('error', \"launchFavorite(): YUI-IO:   Txn #\"+ioId+\" failed or timed-out (view 'log' console log for details).\", true);");
printf("				FavScreen.log('verbose', \"launchFavorite(): YUI-IO:   Txn #\"+ioId+\"'s responseText returned by server = '\"+rt+\"'\", true);");
printf("				Spinner.hide();");									//go ahead and hide spinner now, so masks and stuff aren't messed up when the modal-notification shows next...
printf("				ModalNotification_LaunchFailure.showFor(2000);");
printf("				};");
printf("			var handleEnd = function(ioId,o){");
printf("				Spinner.hide();");
printf("				};");
printf("			var geoAccu_js = FavScreen.get('attrGeoLocation_lastAccuracy');");			//temporarily get last-html-geo-accuracy value, to use for comparisons
printf("			var geoAccu_app = FavScreen.get('attrGeoLocation_native_lastAccuracyCoord');");		//temporarily get last-native-app-geo-accuracy value, to use for comparisons
printf("			var lastLat, lastLong, lastAlt, lastAccu, lastUpdated;");				//declare to-be-populated vals, set in branches below...
printf("			if(geoAccu_app != 0 && geoAccu_js != 0){");						//if we have valid values from both methods, then we should see which one is more accurate and use it
printf("				FavScreen.log('log',\"launchFavorite(): Geolocation data exists from both html/javascript and native-app....\",false);");
printf("				if(geoAccu_app <= geoAccu_js){");							//if native-app-acquired geolocation data is more accurate, use its data instead of javascript's
printf("					FavScreen.log('log',\"launchFavorite(): Using better geolocation data from native-app (native accuracy = \"+geoAccu_app+\" vs js accuracy = \"+geoAccu_js+\").\",false);");
printf("					if(geoAccu_app>%d){", FAVS_GEOLOCATION_ACCURACY_CRITICAL);
printf("						FavScreen.log('warn',\"launchFavorite():  Geolocation accuracy critical! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_CRITICAL);
printf("					}else if(geoAccu_app>%d){", FAVS_GEOLOCATION_ACCURACY_WARNING);
printf("						FavScreen.log('warn',\"launchFavorite():  Geolocation accuracy warning! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_WARNING);
printf("					}else if(geoAccu_app>%d){", FAVS_GEOLOCATION_ACCURACY_NOTICE);
printf("						FavScreen.log('info',\"launchFavorite():  Geolocation accuracy notice! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_NOTICE);
printf("					}");
printf("					lastLat = FavScreen.get('attrGeoLocation_native_lastLatitude');");			//get the last-known latitude attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("					lastLong = FavScreen.get('attrGeoLocation_native_lastLongitude');");			//get the last-known longitude attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("					lastAlt = FavScreen.get('attrGeoLocation_native_lastAltitude');");			//get the last-known altitude attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("					lastAccu = FavScreen.get('attrGeoLocation_native_lastAccuracyCoord');");		//get the last-known accuracy attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("					lastUpdated = FavScreen.get('attrGeoLocation_native_lastUpdated');");			//get the last-known updated (timestamp) attribute
printf("				}else{");										//else javascript-acquired data is more accurate, so use it instead of native-app's provided data
printf("					FavScreen.log('log',\"launchFavorite(): Using more accurate geolocation data from html/javascript (js accuracy = \"+geoAccu_js+\" vs native accuracy = \"+geoAccu_app+\").\",false);");
printf("					if(geoAccu_js>%d){", FAVS_GEOLOCATION_ACCURACY_CRITICAL);
printf("						FavScreen.log('warn',\"launchFavorite():  Geolocation accuracy critical! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_CRITICAL);
printf("					}else if(geoAccu_js>%d){", FAVS_GEOLOCATION_ACCURACY_WARNING);
printf("						FavScreen.log('warn',\"launchFavorite():  Geolocation accuracy warning! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_WARNING);
printf("					}else if(geoAccu_js>%d){", FAVS_GEOLOCATION_ACCURACY_NOTICE);
printf("						FavScreen.log('info',\"launchFavorite():  Geolocation accuracy notice! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_NOTICE);
printf("					}");
printf("					lastLat = FavScreen.get('attrGeoLocation_lastLatitude');");				//get the last-known latitude attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("					lastLong = FavScreen.get('attrGeoLocation_lastLongitude');");				//get the last-known longitude attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("					lastAlt = FavScreen.get('attrGeoLocation_lastAltitude');");				//get the last-known altitude attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("					lastAccu = FavScreen.get('attrGeoLocation_lastAccuracy');");				//get the last-known accuracy attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("					lastUpdated = FavScreen.get('attrGeoLocation_lastUpdated');");				//get the last-known updated (timestamp) attribute
printf("				}");
printf("			}");
printf("			else if(geoAccu_app == 0 && geoAccu_js != 0){");					//else-if we have invalid/no values from the native-app method (and valid value from javascript), so use the javascript-derived values
printf("				FavScreen.log('log',\"launchFavorite(): Using geolocation data from html/javascript (js accuracy = \"+geoAccu_js+\").\",false);");
printf("				if(geoAccu_js>%d){", FAVS_GEOLOCATION_ACCURACY_CRITICAL);
printf("					FavScreen.log('warn',\"launchFavorite():  Geolocation accuracy critical! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_CRITICAL);
printf("				}else if(geoAccu_js>%d){", FAVS_GEOLOCATION_ACCURACY_WARNING);
printf("					FavScreen.log('warn',\"launchFavorite():  Geolocation accuracy warning! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_WARNING);
printf("				}else if(geoAccu_js>%d){", FAVS_GEOLOCATION_ACCURACY_NOTICE);
printf("					FavScreen.log('info',\"launchFavorite():  Geolocation accuracy notice! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_NOTICE);
printf("				}");
printf("				lastLat = FavScreen.get('attrGeoLocation_lastLatitude');");				//get the last-known latitude attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("				lastLong = FavScreen.get('attrGeoLocation_lastLongitude');");				//get the last-known longitude attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("				lastAlt = FavScreen.get('attrGeoLocation_lastAltitude');");				//get the last-known altitude attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("				lastAccu = FavScreen.get('attrGeoLocation_lastAccuracy');");				//get the last-known accuracy attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("				lastUpdated = FavScreen.get('attrGeoLocation_lastUpdated');");				//get the last-known updated (timestamp) attribute
printf("			}");
printf("			else if(geoAccu_js == 0 && geoAccu_app != 0){");					//else-if we have invalid/no values from the javascript/html method (and valid value from native-app), so use the native-app-derived values
printf("				FavScreen.log('log',\"launchFavorite(): Using geolocation data from native-app (native accuracy = \"+geoAccu_app+\").\",false);");
printf("				if(geoAccu_app>%d){", FAVS_GEOLOCATION_ACCURACY_CRITICAL);
printf("					FavScreen.log('warn',\"launchFavorite():  Geolocation accuracy critical! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_CRITICAL);
printf("				}else if(geoAccu_app>%d){", FAVS_GEOLOCATION_ACCURACY_WARNING);
printf("					FavScreen.log('warn',\"launchFavorite():  Geolocation accuracy warning! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_WARNING);
printf("				}else if(geoAccu_app>%d){", FAVS_GEOLOCATION_ACCURACY_NOTICE);
printf("					FavScreen.log('info',\"launchFavorite():  Geolocation accuracy notice! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_NOTICE);
printf("				}");
printf("				lastLat = FavScreen.get('attrGeoLocation_native_lastLatitude');");			//get the last-known latitude attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("				lastLong = FavScreen.get('attrGeoLocation_native_lastLongitude');");			//get the last-known longitude attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("				lastAlt = FavScreen.get('attrGeoLocation_native_lastAltitude');");			//get the last-known altitude attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("				lastAccu = FavScreen.get('attrGeoLocation_native_lastAccuracyCoord');");		//get the last-known accuracy attribute (getting cached value rather than calling the geolocation method, so it's faster to launch the message)
printf("				lastUpdated = FavScreen.get('attrGeoLocation_native_lastUpdated');");			//get the last-known updated (timestamp) attribute
printf("			}");
printf("			else{");										//else no valid geolocation data is present (for either method)
printf("				FavScreen.log('warn',\"launchFavorite(): Could not acquire valid geolocation data (native accuracy = \"+geoAccu_app+\" vs js accuracy = \"+geoAccu_js+\"). Will send zeroed geolocation data.\",false);");
printf("				lastLat = 0;");
printf("				lastLong = 0;");
printf("				lastAlt = 0;");
printf("				lastAccu = 0;");
printf("				lastUpdated = 0;");
printf("			}");
printf("			if(parseInt(lastAccu,10) > %d) {", FAVS_GEOLOCATION_RANGETHRESHOLD_WIFI_HI);		//do one final check before launch... if final accuracy just isn't good enough, send zeroes, so the recipient client (hopefully msg defined w/Google Maps) will show large broad area
printf("				FavScreen.log('info',\"launchFavorite(): Geolocation may have been derived from IP and is not accurate enough to be useful. Will send zeroed geolocation data to hopefully cause recipient client to show broad geographical area.\",false);");
printf("				lastLat = 0;");
printf("				lastLong = 0;");
printf("				lastAlt = 0;");
printf("			}");
printf("			var cfg ={");										//setup a standard YUI configuration object for our transaction
printf("				on:{");
printf("					start:handleStart,");							//subscribe the above custom start handler to IO's global start event
printf("					success:handleSuccess,");						//subscribe the above custom success handler to IO's global success event
printf("					failure:handleFailure,");						//subscribe the above custom failure handler to IO's global failure event
printf("					end:handleEnd");							//subscribe the above custom failure handler to IO's global end event
printf("					},");
printf("				method:\"POST\", ");								//method will default to GET unless we specify POST here
printf("				data:{");									//whatever fields/data that CGI gets to parse... (NOTE: these should be common to both reply and launch)
printf("					'%s':'%s'", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));	//send the encoded brtype for authentication
printf("					,'disableCheckForIP_favorites':'%d'", TRUE);					//tell server not to check for IP changes to invalidate session (as, mobile device may necessarily change IP addresses, frequently)
//printf("					,'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP()");
printf("					,'launch_from_favorites':'%d'", TRUE);						//send flag to smcgi to let it know we are launching from favorites (which may require its own unique behavior if msg is unresolved, popup, etc.)
printf("					,'geolocation_latitude':lastLat");						//send last known latitude
printf("					,'geolocation_longitude':lastLong");						//send last known longitude
printf("					,'geolocation_altitude':lastAlt");						//send last known altitude
printf("					,'geolocation_accuracy':lastAccu");						//send last known accuracy
printf("					,'geolocation_lastUpdated':lastUpdated");					//send when geolocation was last updated
printf("					,'fav_recno':favRecno");							//send favorite record number (so server can know where to save any relevant data (e.g. active copy recno)
printf("					},");
printf("				headers:{");
printf("					'Content-Type':'application/x-www-form-urlencoded'");
printf("					},");
//printf("				sync:true,");									//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete (DEV-NOTE: this value affects Spinner behavior)
printf("				sync:false,");									//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("				timeout:10000");								//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("				};");//end cfg

printf("			if(FavScreen.get('attrInteractionMode')==MODE_LAUNCHABLE){");				//if we're launching straight, then we need to send the data appropriate for that (what smcgi expects in order to do a launch or resolve-to-launch)
printf("				cfg.data.form_state = '%d';", STATE_SEND_MESSAGES);					//send flag to let the server know to send a message (DEV-NOTE: but this sends a message no matter what - even unresolved messages)<--old note??
printf("				cfg.data.button_directory = '%d';", 1);
printf("				cfg.data.page_showlist = ''+msgTemplateRecno+'';");					//send message template recno of the message that should launch
printf("				cfg.data.page_showlist_dtsec = ''+FavScreen.get('attrDtsec')+'';");			//send approx dtsec of when the page was initially loaded (legacy smcgi support)
//printf("				cfg.data.loadPersonalPage = 'SYS ADMIN  ';");						//DEV-NOTE: unsure why/what this is... something to do with being able to launch a message via its name/dir key pair... seem to remember it breaking launch-process-related things, though
printf("				cfg.data.msg_name = ''+msgTemplateName+'';");						//send message template name
printf("				cfg.data.msg_dir = ''+msgTemplateDir+'';");						//send message template directory
printf("			}");
printf("			else if(FavScreen.get('attrInteractionMode')==MODE_REPLYING){");			//else-if we're replying, then we need to send the data appropriate for that (and to enable threading ~ using same data as sendReplyToMsg routine)<--??
				//first, modify any existing field values from normal launch...
printf("				cfg.data.form_state = '%d';", STATE_INBOX_MESSAGES);					//because we're mimicking clicking the 'reply' button from an inbox-msg view
printf("				cfg.data.page_showlist = '0';");
printf("				cfg.data.page_showlist_dtsec = '0';");
printf("				cfg.data.loadPersonalPage = ''+FavScreen.objMsgData_replyTo.replyToLaunchPin+'';");
				//then, add any fields unique to threaded-reply...
printf("				cfg.data.msg_name = ''+FavScreen.objMsgData_replyTo.replyToReplyMsgName+'';");		//get inbox record's reply-with msg-name (i.e. what's defined in that template's reply-msg field)
printf("				cfg.data.msg_dir = ''+FavScreen.objMsgData_replyTo.replyToReplyDirName+'';");		//get inbox record's reply-with dir-name (i.e. what's defined in that message template's reply-dir field)
printf("				cfg.data.to_pin = ''+FavScreen.objMsgData_replyTo.replyToLaunchPin+'';");		//get inbox record's launched-by pin (who it's from), so we can use that for who it needs to go back to (DEV-NOTE: make sure this works with auto-addr)
printf("				cfg.data.from_pin = ''+CURRENT_USER_PIN+'';");						//define who this reply will be coming from (the current user)
printf("				cfg.data.from_staff_list = '4';");							//DEV-NOTE: figure out what defined/dynamic value to put here instead of hard-coding a '4'
printf("				cfg.data.multi_user_page_list = '';");
printf("				cfg.data.call_mode = '0';");
printf("				cfg.data.personal_page_default_message = '0';");
printf("				cfg.data.personal_page_audio_group = '0';");
printf("				cfg.data.personal_page_stream_mode = '1';");
printf("				cfg.data.personal_page_stream_record = ''+FavScreen.objMsgData_replyTo.replyToBannRecno+'';");
printf("				cfg.data.personal_page_note_recno = ''+FavScreen.objMsgData_replyTo.replyToBannRecno+'';");
printf("				cfg.data.personal_page_stream_archive_number = '0';");
printf("				cfg.data.floor_plan_record_numbers = '';");
printf("				cfg.data.alt_directory_reply_mode = '0';");						//DEV-NOTE: this could change if alt-directory is defined in template?? -prob not, if we don't want to support this level of legacy in mobile?
printf("				cfg.data.alt_directory_reply_record = '0';");						//DEV-NOTE: this could change if alt-directory is defined in template?? -prob not, if we don't want to support this level of legacy in mobile?
printf("				cfg.data.prohibit_message_active_recno = ''+FavScreen.objMsgData_replyTo.replyToBannRecno+'';");
				//BUT.. one more possible step!
				//If we got here by them clicking a msg to reply with (and a reply-msg isn't defined), we'll need to instead pass data relevant to the msg they want to use
printf("				if(typeof FavScreen.objMsgData_replyWith === 'object') {");
printf("					if((FavScreen.objMsgData_replyWith.replyWithMsgTemplateName.length > 0) && (cfg.data.msg_name.length == 0)) {");
/* ORIGINAL BEFORE DEBUGGING REPLY-WITH-REG-MSG FAILURE... */
printf("						cfg.data.msg_dir = ''+FavScreen.objMsgData_replyWith.replyWithMsgTemplateDir+'';");
printf("						cfg.data.msg_name = ''+FavScreen.objMsgData_replyWith.replyWithMsgTemplateName+'';");
/* HERE'S EXAMPLE WHAT sendReplyToMsg SENDS...
 * DEBUG STEPS: 1)copy this form exactly; and if that still fails, 2)perhaps remove fields?
printf("	var replyTo_recno = FavScreen.objMsgData_replyTo.replyToBannRecno;");
printf("	var replyWith_recno = FavScreen.objMsgData_replyWith.replyWithFavRecno;");
printf("	var replyWith_msgTemplateName = FavScreen.objMsgData_replyWith.replyWithMsgTemplateName;");
printf("	var replyWith_msgTemplateRecno = FavScreen.objMsgData_replyWith.replyWithMsgTemplateRecno;");
printf("	var replyTo_userPin = FavScreen.objMsgData_replyTo.replyToLaunchPin;");
-------
printf("				,'form_state':'%d'", STATE_PERSONAL_PAGE_WITH_MSG);
	form_state: "12"
	ldata_203_auto_addr: "SYS ADMIN "
	ldata_234_0_wholemsg: ""
printf("				,'msg_name':replyWith_msgTemplateName");		//name (DB key) of the message template we're using to replying with
					msg_name: "DON'T KNOW                    "
printf("				,'page_showlist':replyWith_msgTemplateRecno");		//recno of the message template we're using to reply with
					page_showlist: "234"
printf("				,'page_showlist_dtsec':FavScreen.get('attrDtsec')");
					page_showlist_dtsec: "           1110731271"
printf("				,'personal_page_stream_record':replyTo_recno");		//recno of the banner message we're replying to
					personal_page_stream_record: "269"
printf("				,'reply_to_pin':replyTo_userPin");
					reply_to_pin: "SYS ADMIN "
*/
//printf("						cfg.data.form_state = '%d';", STATE_PERSONAL_PAGE_WITH_MSG);
//printf("						cfg.data.form_state = '%d';", STATE_INBOX_MESSAGES_SINGLE_REPLY);
//printf("						cfg.data.msg_dir = ''+FavScreen.objMsgData_replyWith.replyWithMsgTemplateDir+'';");		//directory of the message of the message template we're using to reply with
//printf("						cfg.data.msg_name = ''+FavScreen.objMsgData_replyWith.replyWithMsgTemplateName+'';");		//name of the message template we're using to reply with
//printf("						cfg.data.page_showlist = ''+FavScreen.objMsgData_replyWith.replyWithMsgTemplateRecno+'';");	//recno of the message template we're using to reply with
//printf("						cfg.data.page_showlist_dtsec = ''+FavScreen.get('attrDtsec')+'';");
//printf("						cfg.data.reply_to_pin = ''+FavScreen.objMsgData_replyTo.replyToLaunchPin+'';");
//DEBUG 2)REMOVE FIELDS... (just guesses now)
//printf("						cfg.data.loadPersonalPage = undefined;");
//printf("						cfg.data.personal_page_stream_record = undefined;");

printf("					}");
printf("				}");
printf("			}");//end if reply-mode
printf("			var sUrl = \"%s\";", cgi_server);							//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("			FavScreen.log('log',\"launchFavorite(): Now attempting to invoke YUI-IO txn for launch\"+xLog+\" of the following message and using the following POST data (next 2 entries)...\",true);");
printf("			FavScreen.log('log',\"launchFavorite():  Fav-name='\"+rsRec_getFavName(FavScreen.rsOrig,favRecno)+\"' | Msg-name='\"+msgTemplateName+\"' | Msg-dir='\"+msgTemplateDir+\"'\",false);");
printf("			FavScreen.log('verbose',\"launchFavorite():  \"+JSON.stringify(cfg.data), false);");
printf("			if(!checkSetIntegSec()) {");							//if integrity is alright, proceed with launch
printf("				objServerResponse = Y.io(sUrl, cfg);");						//do the actual POST operation to the server to initiate launching of the message
printf("			}");
printf("			});");//end YUI.use()
printf("		return objServerResponse;");
//printf("	}");//end if MODE_LAUNCHABLE double-check
//printf("	else if(FavScreen.get('attrInteractionMode')==MODE_REPLYING){");					//if we're responding, then we may need to pass along extra reply-with data
//printf("		");
//printf("	}");
//printf("	else{");
//printf("		FavScreen.log('warn', \"launchFavorite(): Apparently, a 'launch' on-click event listener has failed to detach\", true);");
//printf("		return false;");
//printf("	}");//end else
printf("}\n");//end function launchFavorite

printf("function closeMessagePreCheck(clickTargetId){");							// Do various pre-checking before closing an active msg. This basically just returns false to interrupt the close process, if necessary (and ONLY if necessary, otherwise returns true by default)
printf("	var ret = true;");											//configure a default return value of true
printf("	cfg_autoHideTimeout = 5 * 1000;");
printf("	if(typeof clickTargetId===\"undefined\"){");
printf("		FavScreen.log('error',\"closeMessagePreCheck(): Required argument is undefined, aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	var favRecno;");
printf("	if(isNaN(clickTargetId)) {");
printf("		favRecno = clickTargetId.toString().split(\"_\")[1];");
printf("	}else{");
printf("		favRecno = clickTargetId;");
printf("	}");
printf("	if(isNaN(favRecno)){");
printf("		FavScreen.log('error',\"closeMessagePreCheck(\"+clickTargetId+\"): Invalid argument, could not determine a valid favRecno (\"+favRecno+\"). Aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	var favConfirmSend = rsRec_getConfirmSend(FavScreen.rsOrig, favRecno);");				//get the favorite's confirmSend encoded flag (which is what we use to determine whether we also confirm toggle or not)
printf("	if(favConfirmSend>0){");										//if the favorite has some kind of confirmSend flag, see if it applies to this session...
printf("		if(FavScreen.get('attrDeviceType')==DEVICETYPE_PHONE && (favConfirmSend==%d || favConfirmSend==%d || favConfirmSend==%d || favConfirmSend==%d)){", FAVS_CONFIRMSEND_PHONE, FAVS_CONFIRMSEND_PHONETABLET, FAVS_CONFIRMSEND_PHONEPC, FAVS_CONFIRMSEND_ALL);
printf("			FavScreen.log('log', \"closeMessagePreCheck(): User must confirm close-msg for phone (attrDeviceType=\"+FavScreen.get('attrDeviceType')+\", favConfirmSend=\"+favConfirmSend+\").\", false);");
printf("			ConfirmCloseMsg.showFor(clickTargetId, cfg_autoHideTimeout);");					//it's now up to the custom dialog to restart the launch process, depending on the user's action there
printf("			return false;");										//return false, so the main launch process will abort
printf("		}");
printf("		else if(FavScreen.get('attrDeviceType')==DEVICETYPE_TABLET && (favConfirmSend==%d || favConfirmSend==%d || favConfirmSend==%d || favConfirmSend==%d)){", FAVS_CONFIRMSEND_TABLET, FAVS_CONFIRMSEND_PHONETABLET, FAVS_CONFIRMSEND_TABLETPC, FAVS_CONFIRMSEND_ALL);
printf("			FavScreen.log('log', \"closeMessagePreCheck(): User must confirm close-msg for tablet (attrDeviceType=\"+FavScreen.get('attrDeviceType')+\", favConfirmSend=\"+favConfirmSend+\").\", false);");
printf("			ConfirmCloseMsg.showFor(clickTargetId, cfg_autoHideTimeout);");					//it's now up to the custom dialog to restart the launch process, depending on the user's action there
printf("			return false;");										//return false, so the main launch process will abort
printf("		}");
printf("		else if(FavScreen.get('attrDeviceType')==DEVICETYPE_PC && (favConfirmSend==%d || favConfirmSend==%d || favConfirmSend==%d || favConfirmSend==%d)){", FAVS_CONFIRMSEND_PC, FAVS_CONFIRMSEND_PHONEPC, FAVS_CONFIRMSEND_TABLETPC, FAVS_CONFIRMSEND_ALL);
printf("			FavScreen.log('log', \"closeMessagePreCheck(): User must confirm close-msg for PC (attrDeviceType=\"+FavScreen.get('attrDeviceType')+\", favConfirmSend=\"+favConfirmSend+\").\", false);");
printf("			ConfirmCloseMsg.showFor(clickTargetId, cfg_autoHideTimeout);");					//it's now up to the custom dialog to restart the launch process, depending on the user's action there
printf("			return false;");										//return false, so the main launch process will abort
printf("		}");
printf("		else{");
printf("			FavScreen.log('log', \"closeMessagePreCheck(): Configured confirmSend not required on this device (attrDeviceType=\"+FavScreen.get('attrDeviceType')+\", favConfirmSend=\"+favConfirmSend+\"). Continuing close-msg process...\", false);");
printf("			return true;");											//return true, so the main launch process will proceed
printf("		}");
printf("	}");//end if confirmSend
printf("	else if(document.getElementById(clickTargetId).className.indexOf('inboxmsg')) {");
printf("		FavScreen.log('log', \"closeMessagePreCheck(): User must confirm close-msg for inbox msg.\", false);");
printf("		ConfirmCloseMsg.showFor(clickTargetId, cfg_autoHideTimeout);");					//it's now up to the custom dialog to restart the launch process, depending on the user's action there
printf("		return false;");										//return false, so the main launch process will abort
printf("	}");
printf("	FavScreen.log('log', \"closeMessagePreCheck(): No explicit results, so returning default value of '\"+ret+\"'.\", false);");
printf("	return ret;");												//if we've made it to here for some reason, just allow the launch process to continue by returning the default 'true' value set above
printf("}\n");//end function closeMessagePreCheck()
printf("function closeMessage(clickTargetId, skipPreCheck){"); //ex. "toggleicon_185" (the number being the fav-recno, if called from toggle icon... otherwise could be a straight-up inbox-msg-recno w/out the preceeding text)
printf("		if(typeof clickTargetId===\"undefined\"){");
printf("			FavScreen.log('error',\"closeMessage(): Required argument is undefined, aborting.\",true);");
printf("			return false;");
printf("		}");
printf("		if(skipPreCheck==true){");										//if directed to skip pre-check, then don't call it...
printf("			FavScreen.log('log', \"closeMessage() called, with 'skipPreCheck'='\"+skipPreCheck+\"'. Skipping pre-check...\", true);");
printf("		}else{");												//else do the pre-check, by default
printf("			FavScreen.log('log', \"closeMessage() called. Running pre-check...\", true);");
printf("			if(closeMessagePreCheck(clickTargetId)){");
printf("				FavScreen.log('info', \"closeMessage(): Pre-check returned true and the close-msg process shall now proceed...\", true);");
printf("			}else{");
printf("				FavScreen.log('info', \"closeMessage(): Pre-check returned false, so the close-msg process has been interrupted. See 'closeMessagePreCheck' log for more details. Aborting.\", true);");
printf("				return false;");
printf("			}");
printf("		}");
			//figure out some kind of valid record-number from the argument, and flag whether this is from an inbox/toggle close intention
printf("		var msgRecno, inboxRecno, favRecno;");
printf("		var closeFromInbox;");
printf("		if(isNaN(clickTargetId)) {");		//if doesn't parse to a number, then it contains text, and is likely from a toggle icon
printf("			closeFromInbox = false;");				//set flag
printf("			msgRecno = clickTargetId.toString().split(\"_\")[1];");	//parse the fav-recno from what they clicked on (we're closing from a fav-messagecell's toggle icon)
printf("			favRecno = msgRecno;");					//just to help keep things semantically easy to understand
printf("		}else{");				//else since it's just a number, it's likely an inbox message icon
printf("			closeFromInbox = true;");				//set flag
printf("			msgRecno = clickTargetId;");				//get the active-copy-recno (we're closing from an inbox-messagecell's icon)
printf("			inboxRecno = msgRecno;");				//just to help keep things semantically easy to understand
printf("		}");
printf("		if(isNaN(msgRecno)){");			//just a to-be-safe check
printf("			FavScreen.log('error',\"closeMessage(\"+clickTargetId+\"): Invalid argument, could not determine a valid msgRecno (\"+msgRecno+\"). Aborting.\",true);");
printf("			return false;");
printf("		}");
			//figure out the actual active-copy recno to send to server for closing...
printf("		var arrActiveCopyRecnosForFV, recnoToClose;");
printf("		if(closeFromInbox) {");		//then we have an active-copy recno argument to work with directly (so just send it... but handleSuccess will need to know whether or not to take down any associated toggle icons)
printf("			recnoToClose = inboxRecno;");	//give the form the recno of the specific inbox-msg they want to close (the defacto active-copy-recno)
printf("		}else{");			//we have just a fav-recno argument to work with (so need to determine its currently-active copies - as stored in the latest recordset data, and then we'll need to send the most recent one for closure)
printf("			arrActiveCopyRecnosForFV = rsRec_getActiveCopies_asArray((FavScreen.rsOrig || FavScreen.rsRecentDB), favRecno);");	//get an array of active-copy-recnos, as reflected in the hopefully most-current recordset data
printf("			recnoToClose = arrActiveCopyRecnosForFV[arrActiveCopyRecnosForFV.length-1];");						//give the form the last element in the array (should be the most recent active copy)
printf("		}");
			//we should also get the message-template recno of the active-copy/fav (same difference) to make life easy later when we may try to take down any toggle icons...
printf("		var msgTemplateRecno;");
printf("		if(closeFromInbox) {");		//then we need to get the message template recno from what we conveniently embedded into the DOM node for the inbox messagecell...
printf("			if(FavScreen.get('attrBrowserSupports_dataset')){");
printf("				msgTemplateRecno = document.getElementById(clickTargetId).dataset.templaterecno;");
printf("			}else{");
printf("				msgTemplateRecno = document.getElementById(clickTargetId).getAttribute(\"data-templaterecno\");");
printf("			}");
printf("			favRecno = rsRec_getFavRecno_byMsgTemplateRecno(FavScreen.rsOrig, msgTemplateRecno);");	//let's also try to get any matching favRecno (again, to help us later when we try to hide any toggle icons)
printf("		}else{");			//else, since we have the fav-recno, we can just use that to get the message template recno from the recordset data...
printf("			msgTemplateRecno = rsRec_getMsgTemplateRecno(FavScreen.rsOrig, favRecno);");
printf("		}");
			//setup the server transaction and define what happens when we get a response back...
printf("		var objServerResponse;");	//this will be a function-local variable that our response handlers will populate in a synchronous fashion, so the function can return something meaningful (NOTE: this totally depends on YUI playing nicely with the cfg-object's 'sync' flag)
printf("		var dtsec = FavScreen.get('attrDtsec');");
printf("		YUI().use('io-base', function(Y){");
printf("			var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("				Spinner.show();");
printf("				FavScreen.log('verbose', \"closeMessage(\"+clickTargetId+\"): YUI-IO: Starting txn to request message closure (active-copy-recno \"+recnoToClose+\")... YUI-IO txn ID# will be: \"+ioId+\".\", true);");
printf("				};");
printf("			var handleSuccess = function(ioId, o){");						//response HTTP status resolves to 2xx
printf("				var rt = o.responseText;");
printf("				FavScreen.log('log', \"closeMessage(\"+clickTargetId+\"): YUI-IO (txn#\"+ioId+\"):   Txn #\"+ioId+\" succeeded (\"+Date()+\"), checking server response...\", true);");

printf("				function handleAfterCloseActivities() {");
printf("					if(closeFromInbox) {");
printf("						FavScreen.log('verbose',\"closeMessage(\"+clickTargetId+\"): Closed via inbox. Now determining whether any toggle icons exist and should be cancelled...\",true);");
printf("						FavScreen.log('verbose',\"closeMessage(\"+clickTargetId+\"):  Message template recno seems to be '\"+msgTemplateRecno+\"'. Testing for matching fav-msg in recordset...\",true);");
							//if a matching favorite-msg (that matches the template we closed an active copy of) exists, then see about taking down any possible toggle icons for it...
printf("						if(Boolean(favRecno)) {");							//if we found a matching fav-record (in above logic), then we may need to takedown any potential toggle icons (for now, only remove if latest one was closed)
printf("							FavScreen.log('verbose',\"closeMessage(\"+clickTargetId+\"):  Matching fav-msg (recno \"+favRecno+\") found in recordset. May need to take-down corresponding toggle icon. Checking now-active copies...\",true);");

								//get active-copy-recnos for the fav-msg...
/* MAYBE NO NEED FOR LATEST (AFTER-CLOSE) ACTIVE COPIES?
printf("							if(rt.indexOf('active_copies_for_fav') > -1) {");	//if server returned an up-to-date active-copies string, use that (then we should continue checking whether any of those are in this user's favs list)
printf("								var activeCopiesStringFromServer = rt.split('active_copies_for_fav')[1].split('value=')[1].split('></input>')[0].split('\"')[1].toString();");
printf("								arrActiveCopyRecnosForFV = activeCopiesStringFromServer.split(',');");							//convert the string to an array, using its comma delimiter
printf("								arrActiveCopyRecnosForFV.splice(arrActiveCopyRecnosForFV.length-1, 1);");						//strip off last element in the array (which should be a useless comma since our comma delimiter is at the end)
printf("							} else {");						//use whatever data's in the recordset, as it's the next-best available right now
printf("								arrActiveCopyRecnosForFV = rsRec_getActiveCopies_asArray((FavScreen.rsOrig || FavScreen.rsRecentDB), favRecno);");	//get an array of active-copy-recnos, as reflected in the hopefully most-current recordset data
printf("							}"); */
printf("							arrActiveCopyRecnosForFV = rsRec_getActiveCopies_asArray((FavScreen.rsOrig || FavScreen.rsRecentDB), favRecno);");	//get an array of active-copy-recnos, as reflected in the hopefully most-current recordset data prior to actual closure
printf("							FavScreen.log('verbose',\"closeMessage(\"+clickTargetId+\"):  Prior to close, \"+arrActiveCopyRecnosForFV.length+\" active copies existed for the msg-template (\"+msgTemplateRecno+\") that the favorite (\"+favRecno+\") refers to.\",true);");

								//now that we have active-copy information about a matching fav-msg, handle potential removal of its possible toggle icon... (if the right conditions are met)
								//determine whether the active-copy that was just now closed, also happened to be the newest active copy (if so, take toggle down / if not, leave toggle alone)
/* PER KEVIN, IF MULTIPLE ACTIVE COPIES EXIST, THE TOGGLE ICON SHOULD ONLY-EVER POINT TO THE NEWEST ONE... IF THE NEWEST ONE GETS CLOSED, YOU SHOULD TAKE DOWN THE TOGGLE ICON AND NEVER LET IT POINT TO THE NEXT-NEWEST ONE
printf("							if(arrActiveCopyRecnosForFV.length == 1) {");	//DEV-NOTE: for now, only remove the toggle icon if there's just one active copy (later, migrate to support multiple toggles)
printf("								if(typeof arrToggleTimeoutHandles[parseInt(favRecno)] !== 'undefined') {");	//if a toggle auto-hide timeout exists for this fav-recno (that's what the toggle-timeout-handle array is keyed by), cancel it immediately and hide the toggle icon
printf("									FavScreen.log('log',\"closeMessage(\"+clickTargetId+\"):  Toggle-icon auto-hide timeout exists for fav-recno \"+favRecno+\". Cancelling it and taking down the toggle icon for this fav-recno.\",true);");
printf("									clearTimeout(arrToggleTimeoutHandles[parseInt(favRecno)]);");			//cancel the auto-hide toggle icon timer
printf("									arrToggleTimeoutHandles.splice(parseInt(favRecno),1);");			//physically remove the array-element for the timeout handle
printf("									document.getElementById(favRecno.toString()).getElementsByClassName('affectedbytoggle')[0].style.display=\"none\";");//hide the toggle icon for the clicked item (no need to do a global update)
printf("								}");
printf("							}else{");
printf("								FavScreen.log('info',\"closeMessage(\"+clickTargetId+\"):  Hiding toggle icon when multiple active copies exists is not yet supported. Toggle icon for the favorite will not be taken down.\",true);");
printf("							}"); */
printf("							var newestActiveCopyRecno = arrActiveCopyRecnosForFV[arrActiveCopyRecnosForFV.length-1];");	//since it's FIFO, it should be the last element in the array (since length is 1-based and arrays are 0-based, subtract one) - if no data, arr==undefined
printf("							if( Boolean(newestActiveCopyRecno) && (newestActiveCopyRecno == recnoToClose) ){");
printf("								FavScreen.log('verbose',\"closeMessage(\"+clickTargetId+\"):  The active-copy just closed (\"+recnoToClose+\") matches newest active-copy (\"+newestActiveCopyRecno+\") for the favorite (\"+favRecno+\"). Safe to take down its potential toggle.\",true);");
									//does the corresponding fav-msg have an active toggle icon? (2 ways/things to check: DOM img visible for toggle icon & array of toggle timeout handles)
printf("								if(Boolean(arrToggleTimeoutHandles[parseInt(favRecno)])) {");			//if a toggle auto-hide timeout exists for this fav-recno (that's what the toggle-timeout-handle array is keyed by), cancel it immediately and hide the toggle icon
printf("									FavScreen.log('log',\"closeMessage(\"+clickTargetId+\"):  Toggle-icon auto-hide timeout exists for fav-recno \"+favRecno+\". Cancelling it and taking down the toggle icon.\",true);");
printf("									clearTimeout(arrToggleTimeoutHandles[parseInt(favRecno)]);");			//cancel the auto-hide toggle icon timer
printf("									arrToggleTimeoutHandles.splice(parseInt(favRecno), 1);");			//physically remove the array-element/timeout-handle, for the fav
printf("									document.getElementById(favRecno.toString()).getElementsByClassName('affectedbytoggle')[0].style.display=\"none\";");//hide the toggle icon for the clicked item (no need to do a global update)
//printf("									alreadyToggledOffNewestActiveCopy_forFavRecno_thisSession[parseInt(favRecno)] = true;");//add a flag to the global array's favRecno element that we've toggled it off, so any update calls during this session won't re-show a toggle icon
printf("									alreadyToggledOffNewestActiveCopy_forFavRecno_thisSession[parseInt(favRecno)] = recnoToClose;");//add a flag (the closed active copy recno) to the global array's favRecno element that we've toggled it off, so any update calls during this session won't re-show a toggle icon 
printf("								} else {");
printf("									FavScreen.log('log',\"closeMessage(\"+clickTargetId+\"):  Toggle-icon auto-hide timeout does NOT exist for fav-recno \"+favRecno+\". Close operation will complete.\",true);");
printf("								}");
printf("							} else {");
printf("								FavScreen.log('verbose',\"closeMessage(\"+clickTargetId+\"):  The active-copy just closed (\"+recnoToClose+\") does NOT match newest active-copy (\"+newestActiveCopyRecno+\") for the favorite (\"+favRecno+\"). Not appropriate to take down its potential toggle. Toggle analysis complete.\",true);");
printf("							}");

								//need to remove this just-closed active copy recno from the recordset, so future closes (and their recordset-gotten-data) will be correct and work properly
printf("							FavScreen.log('log',\"closeMessage(\"+clickTargetId+\"): Removing closed active-message recno \"+recnoToClose+\" for favRecno \"+favRecno+\" from rsOrig and rsRecentDB...\",true);");
printf("							rsRec_removeActiveCopyRecno_forFav(FavScreen.rsOrig, favRecno, recnoToClose);");	//remove the closed active copy recno from the recordset (this avoids having to do a costly full-refresh)
printf("							rsRec_removeActiveCopyRecno_forFav(FavScreen.rsRecentDB, favRecno, recnoToClose);");	//remove the closed active copy recno from the recordset (this avoids having to do a costly full-refresh)

							//else no matching favorite-msg, so no need to worry about toggle icons... we're done with the close operation!
printf("						}else{");
printf("							FavScreen.log('log',\"closeMessage(\"+clickTargetId+\"):  No matching fav-msg found in recordset, so no toggle icons to check for. Close operation may now complete.\",true);");
printf("						}");
printf("					}");
						//else we closed via a toggle icon directly, so just remove the toggle-icon/timer...
printf("					else {");
printf("						FavScreen.log('verbose',\"closeMessage(\"+clickTargetId+\"): Closed via toggle-icon. Now hiding the toggle icon and cancelling its auto-timeout.\",true);");
							//DEV-NOTE: need to later migrate this to keyed by active-copy-recno instead? (to support multiple toggle interactivity)
printf("						if(typeof arrToggleTimeoutHandles[parseInt(favRecno)] !== 'undefined') {");	//if a toggle auto-hide timeout exists for this fav-recno (that's what the toggle-timeout-handle array is keyed by), cancel it immediately and hide the toggle icon
printf("							FavScreen.log('log',\"closeMessage(\"+clickTargetId+\"): Toggle-icon auto-hide timeout exists. Cancelling it and taking down the toggle icon for this fav-recno.\",true);");
printf("							clearTimeout(arrToggleTimeoutHandles[parseInt(favRecno)]);");			//cancel the auto-hide toggle icon timer
printf("							arrToggleTimeoutHandles.splice(parseInt(favRecno),1);");			//physically remove the array-element for the timeout handle
printf("							var objNodeRef_toggleIcon = document.getElementById(clickTargetId);");		//note: if clicked toggle icon, this will be the icon
printf("							if(objNodeRef_toggleIcon.className.indexOf('affectedbytoggle') > -1) {");	//if this is indeed a toggle icon, then hide it... (don't want to take even the slightest risk of mistakenly hiding a messagecell)
printf("								objNodeRef_toggleIcon.style.display=\"none\";");				//hide the toggle icon for the clicked item (no need to do a global update)
printf("							}");
printf("						}");
							//need to remove this just-closed active copy recno from the recordset, so future closes (and their recordset-gotten-data) will be correct and work properly
printf("						FavScreen.log('log',\"closeMessage(\"+clickTargetId+\"): Removing closed active-message recno \"+recnoToClose+\" for favRecno \"+favRecno+\" from rsOrig and rsRecentDB...\",true);");
printf("						rsRec_removeActiveCopyRecno_forFav(FavScreen.rsOrig, favRecno, recnoToClose);");	//remove the closed active copy recno from the recordset (this avoids having to do a costly full-refresh)
printf("						rsRec_removeActiveCopyRecno_forFav(FavScreen.rsRecentDB, favRecno, recnoToClose);");	//remove the closed active copy recno from the recordset (this avoids having to do a costly full-refresh)
printf("					}");
printf("				}");//end function handleAfterCloseActivities()

					//detect and handle success conditions...
printf("				if(rt.indexOf(\"This message has already been responded to.\")>-1){");			//if message has already been closed someplace else
printf("					FavScreen.log('info',\"closeMessage(\"+clickTargetId+\"):   Server returns 'This message has already been responded to.'\",true);");
printf("					handleAfterCloseActivities();");
printf("					Spinner.hide();");	//just ensure the spinner doesn't show over top of the modal notification next
printf("					setTimeout(function(){ModalNotification_AlreadyClosed.showFor(2000);},800);");
printf("					return true;");
printf("				}");//end already-closed

printf("				if(rt.indexOf(\"Message closed.\")>-1){");						//if message has now been closed by this action
printf("					FavScreen.log('log',\"closeMessage(\"+clickTargetId+\"):   Server returns 'Message closed.'\",true);");
printf("					handleAfterCloseActivities();");
printf("					Spinner.hide();");	//just ensure the spinner doesn't show over top of the modal notification next
printf("					setTimeout(function(){ModalNotification_OK.showFor(1000);},800);");
printf("					return true;");
printf("				}");//end successfully-closed

					//detect and handle error conditions...
printf("				if(rt.indexOf(\"Unknown form load command.\")>-1){");
printf("					FavScreen.log('warn',\"closeMessage(\"+clickTargetId+\"):   Server returns 'Unknown form load command.'\",true);");
printf("				}");
printf("				else if(rt.indexOf(\"Database notice\")>-1){");
printf("					FavScreen.log('warn',\"closeMessage(\"+clickTargetId+\"):   Server returns database notice (perhaps active copy recno does not exist or message is already closed?).\",true);");
printf("				}");
printf("				else if(rt.indexOf(\"smcgi stopped\")>-1){");
printf("					FavScreen.log('error',\"closeMessage(\"+clickTargetId+\"):   Server returns 'smcgi stopped' (\"+rt+\").\",true);");
printf("				}");
printf("				else{");
printf("					FavScreen.log('error',\"closeMessage(\"+clickTargetId+\"):   Server returns unexpected result (\"+rt+\").\",true);");
printf("				}");

printf("				};");//end handleSuccess
printf("			var handleFailure = function(ioId, o){");						//response HTTP status resolves to 2xx
printf("				FavScreen.log('error', \"closeMessage(\"+clickTargetId+\"): YUI-IO:   Txn #\"+ioId+\" failed or timed-out (view 'log' console log for details).\", true);");
printf("				FavScreen.log('verbose', \"closeMessage(\"+clickTargetId+\"): YUI-IO:   Txn #\"+ioId+\"'s responseText returned by server = '\"+rt+\"'\", true);");
printf("				Spinner.hide();");
printf("				setTimeout(function(){ModalNotification_ServiceUnavailable.showFor(4000);},800);");
printf("				};");
printf("			var handleEnd = function(ioId, o){");							//what should happen when the io txn starts
printf("				FavScreen.log('verbose', \"closeMessage(\"+clickTargetId+\"): YUI-IO: Ending txn to request message closure (active-copy-recno \"+recnoToClose+\")... YUI-IO txn ID# was: \"+ioId+\".\", true);");
//printf("				setTimeout(function(){refreshRecordset(\"%s\",false,false);},500);", CurrentUserPin);			//make sure we have the latest data (but use a delay, to give server/banner time to actually update before reading its database)
printf("				setTimeout(function(){refreshRecordset_inboxMsgs(\"%s\",false,false);},1000);", CurrentUserPin);	//make sure we have the latest inbox data (but use a delay, to give server/banner time to actually update before reading its database)
//printf("				Spinner.hide(1000);");
printf("				Spinner.hide(FAVS_SPINNER_DELAY_HIDE);");
printf("				};");
printf("			var cfg ={");										//setup a standard YUI configuration object for our transaction
printf("				on:{");
printf("					start:handleStart,");							//subscribe the above custom start handler to IO's global start event
printf("					success:handleSuccess,");						//subscribe the above custom success handler to IO's global success event
printf("					failure:handleFailure,");						//subscribe the above custom failure handler to IO's global failure event
printf("					end:handleEnd");							//subscribe the above custom failure handler to IO's global end event
printf("					},");
printf("				method:\"POST\", ");								//method will default to GET unless we specify POST here
printf("				data:{");									//whatever fields/data that CGI gets to parse...
printf("					'%s':'%s'", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));//send the encoded brtype for authentication
printf("					,'disableCheckForIP_favorites':'%d'", TRUE);				//tell server not to check for IP changes to invalidate session (as, mobile device may necessarily change IP addresses, frequently)
//printf("					'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP(),");
/* The following will close a message gracefully... */
printf("					,'form_state':'%d'", STATE_INBOX_MESSAGES);
printf("					,'toggle_from_favs':%d", TRUE);
printf("					,'checkbox_checked_clear_checkbox_field':0");
printf("					,'checkbox_checked_inbox_view':1");
printf("					,'inbox_checkbox_checked_1_row':1");
printf("					,'inbox_checkbox_1_recno':recnoToClose");
printf("					,'inbox_checkbox_1_dtsec':0");						//should be fine as long as it's less than when the message was originally launched
printf("					,'page_showlist':0");
printf("					,'page_showlist_dtsec':0");
printf("					,'fav_recno':favRecno");						//send favorite record number (so server can know what string of active copy recnos to include in the response)
/* The following will stop/kill a message (no execution of command lists, etc.)...
printf("					,'form_state':'%d'", STATE_STOP_ACTIVE_MESSAGES);
printf("					,'page_showlist':recnoToClose");
printf("					,'checkbox_checked_inbox_full_view_row_one_recno':recnoToClose");
printf("					,'checkbox_checked_inbox_full_view_row_one_dtsec':dtsec");
printf("					,'active_message_full_view_record_number':0");
printf("					,'checkbox_checked_clear_checkbox_field.value':0");
printf("					,'checkbox_checked_inbox_view':0");
printf("					,'inbox_full_view_recno':1");
*/
printf("					},");
printf("				headers:{");
printf("					'Content-Type':'application/x-www-form-urlencoded'");
printf("					},");
//printf("				sync:true,");									//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete (DEV-NOTE: this value affects Spinner behavior)
printf("				sync:false,");									//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("				timeout:10000");								//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("				};");//end cfg
printf("			var sUrl = \"%s\";", cgi_server);							//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("			FavScreen.log('log', \"closeMessage(\"+clickTargetId+\"): Now invoking YUI-IO to initiate message-close operation. Sending server the following data...\", false);");
printf("			FavScreen.log('verbose', cfg.data, false);");
printf("			objServerResponse = Y.io(sUrl, cfg);");							//do the actual POST operation to the server to request closure of the active message
printf("			});");//end YUI.use()
printf("		return objServerResponse;");
printf("}\n");//end function closeMessage()

/* Try to send the completed reply to the server... returns boolean result of the transaction  (note: called from dialog.js file)
 * Utilizes objects:  FavScreen.objMsgData_replyTo  &  FavScreeen.objMsgData_replyWith */
printf("function sendReplyToMsg() {");
printf("	if((typeof FavScreen.objMsgData_replyTo === 'undefined') || (typeof FavScreen.objMsgData_replyWith === 'undefined')) {");
printf("		FavScreen.log('error',\"sendReplyToMsg(): Global message data object(s) (objMsgData_replyTo/With) missing. Aborting.\",true);");
printf("		Spinner.hide();");
printf("		return false;");
printf("	}");
printf("	var replyTo_recno = FavScreen.objMsgData_replyTo.replyToBannRecno;");
printf("	var replyWith_recno = FavScreen.objMsgData_replyWith.replyWithFavRecno;");
printf("	var replyWith_msgTemplateName = FavScreen.objMsgData_replyWith.replyWithMsgTemplateName;");
printf("	var replyWith_msgTemplateRecno = FavScreen.objMsgData_replyWith.replyWithMsgTemplateRecno;");
printf("	var replyWith_yourNote = '';");
printf("	if(document.getElementsByName(\"yournote\").length > 0) {");
printf("		replyWith_yourNote = document.getElementsByName(\"yournote\")[0].value;");
printf("	}");
printf("	var replyTo_userPin = FavScreen.objMsgData_replyTo.replyToLaunchPin;");
printf("	var result;");
printf("	YUI().use(\"io\", \"io-base\", function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("			Spinner.show();");
printf("			FavScreen.log('verbose',\"sendReplyToMsg(): YUI-IO Txn ID#\"+ioId+\" starting.\",false);");
printf("		};");
printf("		var handleSuccess = function(ioId, o){");						//what should happen when response HTTP status resolves to 2xx
printf("			FavScreen.log('log',\"sendReplyToMsg(): YUI-IO Txn ID#\"+ioId+\" succeeded.\",true);");
printf("			var rt = o.responseText;");
printf("			if(rt.indexOf(\"Invalid form information was found.\")>-1){");				//if smcgi is returning a bad authentication check
printf("				FavScreen.log('error', \"sendReplyToMsg(): Could not authenticate (server says 'Invalid form information was found').\", true);");
//printf("				Spinner.hide();");									//go ahead and hide spinner now, so masks and stuff aren't messed up when the modal-notification shows next...
printf("				ModalNotification_ServiceUnavailable.showFor(4000);");
printf("				result = false;");
printf("			}else if(rt.indexOf(\"Sent To: \")>-1){");		//NOTE: check for better way to determine (this will happen even if reply didn't, if form data isn't perfect)
printf("				FavScreen.log('log', \"sendReplyToMsg(): Reply likely sent (server says 'Sent To:').\", true);");
printf("				ModalNotification_OK.showFor(4000);");
printf("				setTimeout(function(){refreshRecordset(\"%s\",true,false,false);},1000);", CurrentUserPin);		//just make sure we have the latest favorites to display
printf("				setTimeout(function(){refreshRecordset_inboxMsgs(\"%s\",true,false,false);},1500);", CurrentUserPin);//make sure we have the latest inbox data (but use a delay, to give server/banner time to actually update before reading its database)
printf("				FavScreen.set('attrInteractionMode', MODE_LAUNCHABLE);");
printf("				result = true;");
printf("			}else if(rt.indexOf(\"Your message was sent.\")>-1){");		//NOTE: check for better way to determine (this will happen even if reply didn't, if form data isn't perfect)
printf("				FavScreen.log('log', \"sendReplyToMsg(): Reply likely sent (server says 'Your message was sent.').\", true);");
printf("				ModalNotification_OK.showFor(4000);");
printf("				setTimeout(function(){refreshRecordset(\"%s\",true,false,false);},1000);", CurrentUserPin);		//just make sure we have the latest favorites to display
printf("				setTimeout(function(){refreshRecordset_inboxMsgs(\"%s\",true,false,false);},1500);", CurrentUserPin);//make sure we have the latest inbox data (but use a delay, to give server/banner time to actually update before reading its database)
printf("				FavScreen.set('attrInteractionMode', MODE_LAUNCHABLE);");
printf("				result = true;");
printf("			}else{");
printf("				FavScreen.log('warn', \"sendReplyToMsg(): Unknown response from server.\", true);");
printf("				FavScreen.log('verbose',\"sendReplyToMsg(): Raw responseText returned by server = '\"+rt+\"'\",false);");
printf("				result = false;");
printf("			}");
printf("		};");
printf("		var handleFailure = function(ioId, o){");						//what should happen when response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('warn',\"sendReplyToMsg(): YUI-IO Txn ID#\"+ioId+\" failed or timed-out.\",false);");
printf("			var rt = o.responseText;");
printf("			FavScreen.log('verbose',\"sendReplyToMsg(): Raw responseText returned by server = '\"+rt+\"'\",false);");
printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("			result = false;");
printf("		};");
printf("		var handleEnd = function(ioId, o){");							//what should happen when YUI-IO transaction is finished
printf("			FavScreen.log('verbose',\"sendReplyToMsg(): YUI-IO Txn ID#\"+ioId+\" finished.\",false);");
//printf("			Spinner.hide(200);");
printf("			Spinner.hide(FAVS_SPINNER_DELAY_HIDE);");
printf("		};");
printf("		var cfg ={");										//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");							//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");								//subscribe the above custom end handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
//don't send fav name, rather send msg text
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP()");
printf("				,'form_state':'%d'", STATE_PERSONAL_PAGE_WITH_MSG);
//printf("				,'form_state':'%d'", STATE_PERSONAL_PAGE_REPLY);
printf("				,'msg_name':replyWith_msgTemplateName");			//name (DB key) of the message template we're using to replying with
printf("				,'page_showlist':replyWith_msgTemplateRecno");			//recno of the message template we're using to reply with
printf("				,'page_showlist_dtsec':FavScreen.get('attrDtsec')");
printf("				,'personal_page_stream_record':replyTo_recno");			//recno of the banner message we're replying to
printf("				,'reply_to_pin':replyTo_userPin");
printf("				,'fav_recno':FavScreen.objMsgData_replyWith.replyWithFavRecno");//send favorite record number (so server can know where to save any relevant data (e.g. active copy recno)
printf("				,'launch_from_favorites':'%d'", TRUE);				//send flag to smcgi to let it know we are launching from favorites (which may require its own unique behavior if msg is unresolved, popup, etc.)

// USED BY VIEW INBOX MESSAGE
//printf("				,'inbox_full_view_archive_number':0");
//printf("				,'inbox_full_view_recno':strRecno");
//printf("				,'checkbox_checked_inbox_view':0");
//printf("				,'checkbox_checked_inbox_full_view_row_one_recno':strRecno");
//printf("				,'checkbox_checked_inbox_full_view_row_one_dtsec':FavScreen.get('attrDtsec')");
//printf("				,'checkbox_checked_clear_checkbox_field.value':1");
//printf("				,'form_state':'%d'", STATE_INBOX_MESSAGES);
//printf("				,'page_showlist':0");

// WHAT HAPPENS WHEN YOU CLICK THE 'SEND' BUTTON TO REPLY IN LEGACY
// javascript:
// document.forms[0].active_message_full_view_record_number.value=0;
// if(document.forms[0].ldata_165_valid_message_variables_for_launch.value == '0') {return false;}
// if(document.forms[0].launch_selection_list_must_choose) { 
// 	if(document.forms[0].launch_selection_list_must_choose.value == 1) { alert('You must make a selection from the Send To list.'); return false; }
// }
// if(document.forms[0].force_msg_name_change_for_template) {
// 	if(document.forms[0].force_msg_name_change_for_template.value == 1) { alert('You must change the message name.'); return false; }
// }
// ShowListSelection(165, '           1097077987');

// POSTED AT SEND-REPLY TIME
//personal_page_stream_mode:0
//personal_page_stream_record:264				<-- the message we're replying to
//personal_page_stream_archive_number:0
//personal_page_note_recno:0
//alt_directory_reply_record:0
//alt_directory_reply_mode:0
//personal_page_video_conference_1_recno:0
//personal_page_video_conference_1_pin:          
//personal_page_video_conference_2_recno:0
//personal_page_video_conference_2_pin:          
//personal_page_camera_recno:0
//personal_page_show_camera_on_device_recno:0
//delay_submit_of_parent_window:0
//close_window_after_submit:0
//message_line_resizer:0
//recent_message_line_resizer:0
//inbox_table_view:1
//inbox_full_view_recno:0
//inbox_full_view_recent_messages:0
//inbox_full_view_archive_number:0
//inbox_schedule_view_recno:0
//inbox_cancel_lsi_calling:0
//print_inbox:0
//jump_to_message_editor:0
//jump_to_message_editor_dtsec:
//jump_to_schedule_editor:0
//preferences_mode:0
//preferences_form_state:10
//auto_refresh_submitting_skip_routing_messages:0
//directory:
//inbox_escalation_recno:0
//inbox_escalation_pin:
//note_update_type:0
//note_update_field:
//note_update_bann_recno:0
//note_update_archive_number:0
//prohibit_message_active:0
//reply_homework:0
//reply_homework_dtsec:0
//ldata_159_dbb_multi_sign_group:
//ldata_159_dbb_multi_audio_group:
//ldata_rename:
//ldata_159_valid_message_variables_for_launch:1
//ldata_159_dbb_record_voice_call_back:
//call_mode:0
//from_staff_list:4
//sent_messages_first_row:0
//sent_messages_last_row:0
//direction:none
//first_record:159						<-- the message template we're replying with
//first_record_archive:1
//last_record:159                                             <-- the message template we're replying with
//last_record_archive:1
//first_displayed_record:0
//first_displayed_record_archive:
//page_showlist:159                                             <-- the message template we're replying with
//page_remove_from_queue:0
//page_remove_from_queue_dtsec:0
//page_showlist_dtsec:           1105280311
//brtype:6FisQ~J2iMzkrcFBTxhgMvZnc3_IZf2M72XcZeE10i^Tk2MF4TQN3tAaA0pi~aAag~A~6jA2VO8Aj403oTl8AB6~0zj11Qf TuX~ I  hY U1 q3 ow  a eJ K H d c^ A E sZ ^Kyc ddQ^ AjTl Po3 c HG A  Yz K ZA~c i dS JN X 8 M _ wz l lFak61Ub~p.sD1S.T8o6p1^O2.2BN9Hp12JiT ZJNNXIDlsNLMmIDeFD3oMAD~mmTvG^ AlJD0ScEl2GDYlK9SFC~EqlYg37YPccTSY443948
//from_pin:SYS ADMIN 
//multi_user_page_list:                                                                                                                                                                                                                                                                                                                                                                                                               
//button_directory:1
//form_state:12                                 <-- STATE_PERSONAL_PAGE_WITH_MSG
//last_edited_message_name:
//flash_reply_last_dtsec:
//launch_or_delayed_launch:LF
//main_send_message:
//main_reply_sent_messages:
//main_show_send_msgs_by:
//main_page_queue:
//main_prompt_close_window_when_done:2
//main_subject:ALLsubjects                   
//main_proxy_view_pin:
//main_archive_view_detail:
//main_return_on_launch_record_number:
//main_floor_plan_name:                              
//main_floor_plan_area_interval:
//main_archive_view_pin:
//main_kiosk_message_directory:
//main_control_pad_copy_deviceid:
//main_current_department:                              
//main_current_group:                              
//software_version:03.14.97
//main_inbox_view_dtsec:
//main_inbox_view_nines_dtsec:
//show_recent_messages:0
//checkbox_checked_inbox_view:
//checkbox_checked_inbox_full_view_recno:
//checkbox_checked_inbox_full_view_row_one_recno:
//checkbox_checked_inbox_full_view_row_one_dtsec:
//checkbox_checked_clear_checkbox_field:
//active_message_full_view_record_number:0
//prohibit_message_active_recno:                     
//main_current_organization:ADMINISTRATION                
//secondary_commands:0
//main_button_selected:0
//msg_name:WHITE PURE - NONE                                    <-- the message template we're replying with
//senders_note_159:                                             <-- the message template we're replying with
//floor_plan_record_numbers:

printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:true,");										//process this transaction synchronously, so the calling routine can get a response from this
printf("			timeout:10000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("		};");//end cfg
printf("		var strFieldName_ldata = 'ldata_'+replyWith_recno+'_auto_addr';");				//add a dynamic-key field to the cfg.data object for telling smcgi that we want this reply-msg to go to whomever originally sent it to us (may no longer need this?)
printf("		cfg.data[strFieldName_ldata] = replyTo_userPin;");
//printf("		strFieldName_ldata = 'ldata_'+replyWith_recno+'_valid_message_variables_for_launch';");		//add a dynamic-key field to the cfg.data object for ___
//printf("		cfg.data[strFieldName_ldata] = '%d';", TRUE);
printf("		strFieldName_ldata = 'ldata_'+replyWith_msgTemplateRecno+'_0_wholemsg';");			//add a dynamic-key field to the cfg.data object for ___
printf("		cfg.data[strFieldName_ldata] = replyWith_yourNote;");
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");								//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("	});");
printf("	return result;");
printf("}");//end function sendReplyToMsg()

printf("function getDataFromMessagecellDOM_favIconSrc(strMessagecellID) {");
printf("	var ret = \"\";");
printf("	var nodeRefMessagecellLI = document.getElementById(strMessagecellID);");
printf("	var nodeRefIconWrapper = nodeRefMessagecellLI.getElementsByClassName('iconwrapper')[0];");
printf("	var nodeRefIconIMG = nodeRefIconWrapper.getElementsByTagName('img')[0];");
printf("	var strImgSrc = nodeRefIconIMG.src;");
printf("	ret = strImgSrc;");
printf("	return ret;");
printf("}\n");//end function
printf("function getDataFromMessagecellDOM_favName(strMessagecellID) {");
printf("	var ret = \"\";");
printf("	var nodeRefMessagecellLI = document.getElementById(strMessagecellID);");
printf("	var nodeRefNameWrapper = nodeRefMessagecellLI.getElementsByClassName('namewrapper')[0];");
printf("	var strName = nodeRefNameWrapper.innerHTML;");
printf("	ret = strName;");
printf("	return ret;");
printf("}\n");//end function
printf("function getDataFromMessagecellDOM_libPin(strMessagecellID) {");
printf("	var ret = \"\";");
printf("	var nodeRefMessagecellLI = document.getElementById(strMessagecellID);");
printf("	var nodeRefLibraryLI = nodeRefMessagecellLI.parentNode.parentNode;");
printf("	if(FavScreen.get('attrBrowserSupports_dataset')){");				//acquire the message-template recno 
printf("		var li_data_userpin = nodeRefLibraryLI.dataset.userpin;");
printf("	}else{");
printf("		var li_data_userpin = nodeRefLibraryLI.getAttribute(\"data-userpin\");");
printf("	}");
printf("	ret = li_data_userpin;");
printf("	return ret;");
printf("}\n");//end function
printf("function getDataFromMessagecellDOM_msgTemplateName(strMessagecellID) {");
printf("	var ret = \"\";");
printf("	var nodeRefMessagecellLI = document.getElementById(strMessagecellID);");
printf("	if(FavScreen.get('attrBrowserSupports_dataset')){");				//acquire the message-template recno 
printf("		var li_data_msgtemplatename = nodeRefMessagecellLI.dataset.msgtemplatename;");
printf("	}else{");
printf("		var li_data_msgtemplatename = nodeRefMessagecellLI.getAttribute(\"data-msgtemplatename\");");
printf("	}");
printf("	ret = li_data_msgtemplatename;");
printf("	if(ret === undefined) {");							//if nothing could be found (perhaps no data-* attribute), try to fall back to recordset-data method)
printf("		FavScreen.log('info',\"getDataFromMessagecellDOM_msgTemplateName(): No data available using 'data-msgtemplatename' attribute, falling back to recordset method...\",false);");
printf("		try {");
printf("			ret = rsRec_getMsgTemplateName(FavScreen.rsOrig, strMessagecellID);");
printf("			FavScreen.log('log',\"getDataFromMessagecellDOM_msgTemplateName(): Apparent success... returning '\"+ret+\"'.\",false);");
printf("		} catch(err) {");
printf("			FavScreen.log('warn',\"getDataFromMessagecellDOM_msgTemplateName(): No data acquired, returning '\"+ret+\"' (\"+err+\").\",false);");
printf("		}");
printf("	}");
printf("	return ret;");
printf("}\n");//end function
printf("function getDataFromMessagecellDOM_msgTemplateRecno(strMessagecellID) {");
printf("	var ret = \"\";");
printf("	var nodeRefMessagecellLI = document.getElementById(strMessagecellID);");
printf("	if(FavScreen.get('attrBrowserSupports_dataset')){");				//acquire the message-template recno 
printf("		var li_data_msgtemplaterecno = nodeRefMessagecellLI.dataset.msgtemplaterecno;");
printf("	}else{");
printf("		var li_data_msgtemplaterecno = nodeRefMessagecellLI.getAttribute(\"data-msgtemplaterecno\");");
printf("	}");
printf("	ret = li_data_msgtemplaterecno;");
printf("	if(ret === undefined) {");							//if nothing could be found (perhaps no data-* attribute), try to fall back to recordset-data method)
printf("		FavScreen.log('info',\"getDataFromMessagecellDOM_msgTemplateRecno(): No data available using 'data-msgtemplaterecno' attribute, falling back to recordset method...\",false);");
printf("		try {");
printf("			ret = rsRec_getMsgTemplateRecno(FavScreen.rsOrig, strMessagecellID);");
printf("			FavScreen.log('log',\"getDataFromMessagecellDOM_msgTemplateRecno(): Apparent success... returning '\"+ret+\"'.\",false);");
printf("		} catch(err) {");
printf("			FavScreen.log('warn',\"getDataFromMessagecellDOM_msgTemplateRecno(): No data acquired, returning '\"+ret+\"' (\"+err+\").\",false);");
printf("		}");
printf("	}");
printf("	return ret;");
printf("}\n");//end function

/* NOTE: this has been migrated to a ClassMajorSection method... deprecated... remove once certain it's not being used by anything else! */
printf("function messageCellActionIsValid(e) {");	// Evaluates the circumstances surrounding a messagecell action and returns a Boolean value representing whether it's valid or not
printf("	var ret = true;");
printf("	if(typeof e !== 'object') {");
printf("		FavScreen.log('error',\"messageCellActionIsValid(): Required object argument not provided, aborting checks and returning true.\",true);");
printf("		return ret;");
printf("	}");
printf("	var cfgFocusDelay = 150;");									//amount of time (in milliseconds) to wait before allowing launch after window has been brought into focus (average testing shows 70-110ms is needed ~ go over to be safe)
printf("	var cfgJumpNavDelay = 350;");									//amount of time (in milliseconds) to wait before allowing launch after user has pressed a jump-nav button
printf("	var cfgAdditionalFooterClickOffset = 10;");							//pixels to bleed the footer's clickable area out into the bodywrapper (to help prevent accidental launches while tapping footer elements)
printf("	var tsNow = Date.now();");									//get current timestamp
printf("	var tsLast_focus = FavScreen.get('attrLastFocused_window');");					//get timestamp from class attribute (should be the last focus-change timestamp)
printf("	var tsLast_jumpNav = FavScreen.get('attrJumpNavLastPressedTimestamp');");			//get timestamp from class attribute (should be the last jump-nav button press timestamp)
printf("	var whereUserClickedY = e.clientY;");								//get the Y-position in the client-window where they clicked (don't use pageY, or it'll be the position within the full bodywrapper node)
//printf("	var bottomOfHeader = document.getElementById('footerwrapper').offsetHeight;");			//get how far from the top of the window the bottom of the header is
printf("	var nodeRefPagetitle = document.getElementById('pagetitle');");
printf("	var bottomOfPagetitle = nodeRefPagetitle.offsetTop + nodeRefPagetitle.offsetHeight;");		//get how far from the top of the window the bottom of the pagetitle is
printf("	var topOfFooter = document.getElementById('footerwrapper').offsetTop;");			//get how far from the top of the window the footer is
printf("	if(!isLoadedInMobileApp() && (tsNow-tsLast_focus <= cfgFocusDelay) ){");
printf("		FavScreen.log('info', \"messageCellActionIsValid(): Window was not in focus (tsNow-tsLast_focus=\"+(tsNow-tsLast_focus)+\"ms, delay=\"+cfgFocusDelay+\"ms). NOT taking action on message, since the click was likely done just to bring the window into focus.\", false);");
printf("		ret = false;");
printf("	}");
printf("	if(tsNow-tsLast_jumpNav <= cfgJumpNavDelay) {");
printf("		FavScreen.log('info', \"messageCellActionIsValid(): User just pressed a jump-nav button (tsNow-tsLast_jumpNav=\"+(tsNow-tsLast_jumpNav)+\"ms, delay=\"+cfgJumpNavDelay+\"ms). NOT taking action on message, since the click was likely done errantly while trying to press a jump-nav button.\", false);");
printf("		ret = false;");
printf("	}");
printf("	if(whereUserClickedY <= bottomOfPagetitle) {");							//if the click happened in the pagetitle's clickable area, then abort the launch (they may have been trying to click pagetitle to jump to the top)
printf("		FavScreen.log('info', \"messageCellActionIsValid(): User just clicked in the pagetitle's area (whereUserClickedY:\"+whereUserClickedY+\" <= bottomOfPagetitle:\"+bottomOfPagetitle+\". NOT taking action on message, since the launch was likely unintended while trying to jump to top of document.\", true);");
printf("		ret = false;");
printf("	}");
printf("	if(whereUserClickedY > (topOfFooter - cfgAdditionalFooterClickOffset)) {");			//if the click happened in the footer's extra padding (no click-to-launch) area, then abort the launch
printf("		FavScreen.log('info', \"messageCellActionIsValid(): User just clicked in the footer's extra-padding area (whereUserClickedY:\"+whereUserClickedY+\" >= topOfFooter:\"+topOfFooter+\" - cfgAdditionalFooterClickOffset:\"+cfgAdditionalFooterClickOffset+\"). NOT taking action on message, since the click was likely done errantly while trying to press a jump-nav button.\", true);");
printf("		ret = false;");
printf("	}");
printf("	if((FavScreen.get('attrInteractionMode')==MODE_REPLYING) && (FavScreen.get('attrCurrentResponseRule')==ENCODED_RESPONSE_RULE_2)) {");//rule 2 means they shouldn't be allowed to launch any non-predefined reply msg, so catch that here
printf("		FavScreen.log('info', \"messageCellActionIsValid(): User just clicked a message in reply mode with response-rule-2 in effect ('\"+FavScreen.get('attrCurrentResponseRule')+\"'), so cannot allow them to continue. Ending reply-mode (it should have already been ended).\", true);");
printf("		handleAutoEndResponseMode_setOrReset(0);");						//NOTE: this is a fall-back.. restoring main node from iframe should do this, primarily
printf("		ret = false;");
printf("	}");
printf("	return ret;");
printf("}");

printf("function anyLibraryIsOwnedBy(strUserPin) {");								// Check whether any libraries are owned by the provided user, and return that library's container (LI) node, if so.
printf("	var li_data_userpin;");
printf("	var node_libSection = document.getElementById('subsectionlist-libraries');");				//get a reference to the library section's main UL node
printf("	if(typeof node_libSection === 'undefined') {");
printf("		FavScreen.log('info', \"anyLibraryIsOwnedBy(): The library major section has not been rendered. Returning false.\", true);");
printf("		return false;");
printf("	}");
printf("	var nodelist_subsections = node_libSection.getElementsByClassName('subsectioncontainer');");		//get a list of references to each library's UL node
printf("	for(var i=0; i<nodelist_subsections.length; i++) {");							//for each node (library) in the nodelist (of libraries)
printf("		if(FavScreen.get('attrBrowserSupports_dataset')){");							//acquire its userpin data attribute for testing...
printf("			li_data_userpin = nodelist_subsections[i].dataset.userpin;");
printf("		}else{");
printf("			li_data_userpin = nodelist_subsections[i].getAttribute(\"data-userpin\");");
printf("		}");
printf("		if(li_data_userpin == strUserPin) {");									//if this library's owner matches what was provided, then we should return an implicit true (the node reference) and be done with this routine
printf("			FavScreen.log('log',\"anyLibraryIsOwnedBy(): A library-subsection LI node (id='\"+nodelist_subsections[i].id+\"') matches the provided userpin ('\"+strUserPin+\"'), returning a reference to the node.\",true);");
printf("			return nodelist_subsections[i];");
printf("		}else if((typeof li_data_userpin === 'undefined') || (li_data_userpin === null)) {");
printf("			FavScreen.log('warn',\"anyLibraryIsOwnedBy(): An apparent library-subsection LI node (id='\"+nodelist_subsections[i].id+\"') doesn't seem to have a 'data-userpin' attribute, returning false as long as nothing further is found.\",true);");
printf("		}");
printf("	}");
printf("	return false;");
printf("}");

/* NOTE: As of v0.47-beta, this has begun to be deprecated, in favor of just a one-time, static listener assignment, pointing to a single handler routine (a method) in ClassMajorSection. */
printf("YUI().add(\"messagecell-listeners-attach\", function(Y){");						//Create a YUI module for attaching event listeners to message cells  (to use, specify this namespace as an argument to the usual YUI().use method)
printf("	var i;");
printf("	Y.attachListenersForLaunching = function(strListNodeId){");						//define a method for attaching launch listeners...
printf("		FavScreen.log('log',\"attachListenersForLaunching: Attaching launch listeners to \"+strListNodeId+\"...\",true);");
printf("		FavScreen.log('verbose',\"attachListenersForLaunching: CALL STACK: \"+Error().stack,false);");
//printf("		Spinner.show();");
//printf("		Spinner.showAfterDelay(300);");
printf("		i = 0;");												//so we can count how many were attached (for reporting purposes)
/*
printf("		var listitems = Y.all(strListNodeId+\" li\");");							//get a nodelist of all LI nodes in the list node specified
printf("		listitems.each( function(){");										//for each node in the nodelist, dictate what should happen whenever it's clicked (to launch a msg)
printf("			var thisId = this.get('id');");										//get this LI node's ID attribute value (which is the favorite recno)
printf("			if(thisId.length>0){");											//if this is a valid favorite list-item (indicated by some id-attribute being specified)...
printf("				var thisSubscription = this.on('click', function(e){");							//create an on-click event listener and subscribe the LaunchFavorite function to its callback
printf("					if(messageCellActionIsValid(e)) {");
printf("						if(this.getDOMNode().parentNode.getAttribute('id').indexOf('dropbox') > 0) {");
printf("							ModalNotification_DropboxLaunch.showFor(2000);");
printf("						}");
printf("						else {");
printf("							launchFavorite(thisId);");
printf("						}");
printf("					}");
printf("					});");
printf("				arrEventHandles[parseInt(thisId)] = thisSubscription;");					//save this event handle into the global array (so it may be successfully detached later) -- we have to remove it from the YUI sandbox, in other words
printf("				i++;");
printf("			}");//end if
printf("			});");//listitems.each
*/
printf("		FavScreen.log('log', \"attachListenersForLaunching: Attached \"+i+\" 'click-to-launch' event listeners to messagecells in '\"+strListNodeId+\"'.\", true);");
//printf("		Spinner.hide();");
//printf("		Spinner.hide(FAVS_SPINNER_DELAY_HIDE + 300);");
//
			//BEST GUESS as to when we're done loading initially the app?
printf("		if(FavScreen.get('attrFinishedInitialLoading_timestamp') == 0) {");
printf("			FavScreen.set('attrFinishedInitialLoading_timestamp', Date.now());");
printf("		}");

printf("		};\n");//end method definition 
/*
printf("	Y.attachListenersForActionWrapperItems = function(strListNodeId){");
printf("		var listitems = Y.all(strListNodeId+\" img\");");							//get a nodelist of all IMG nodes in the actionwrapper div node specified
printf("		i = 0;");												//so we can count how many were attached (for reporting purposes)
printf("		listitems.each( function(){");										//for each node in the nodelist, dictate what should happen whenever it's clicked (to perform some action)
printf("			});");//listitems.each
printf("		};\n");//end method definition 
*/
printf("	Y.attachListenersForEditing = function(strListNodeId){");						//define a method for attaching edit listeners...
printf("		FavScreen.log('log',\"attachListenersForEditing: Attaching edit listeners to \"+strListNodeId+\"...\",true);");
//printf("		Spinner.show();");
//printf("		Spinner.showAfterDelay(300);");
printf("		FavScreen.log('verbose',\"attachListenersForEditing: CALL STACK: \"+Error().stack,false);");
printf("		i = 0;");												//so we can count how many were attached (for reporting purposes)
/*
printf("		var listitems = Y.all(strListNodeId+\" li\");");							//get a nodelist of all LI nodes in the list node specified
printf("		listitems.each( function(){");										//for each node in the nodelist, dictate what should happen whenever it's clicked (to edit a favorite msg)
printf("			var boolDoAttachForThisNode = true;");
printf("			try {");
printf("				var node_this = this.getDOMNode();");
printf("				if(node_this.getAttribute('class') === null) {");
printf("					boolDoAttachForThisNode = false;");
printf("				}");
printf("				else if(node_this.getAttribute('class').indexOf('messagecell') <= -1) {");
printf("					boolDoAttachForThisNode = false;");
printf("				}");
printf("				else if(node_this.getAttribute('class').indexOf('libmsg') > -1) {");						//if the node is a library message, we need to check whether the current user has edit privilege, first...
printf("					if((typeof node_this.parentNode.parentNode !== 'undefined') && (node_this.parentNode.parentNode.getAttribute('data-userpin') !== null)) {");//if the node has a valid container and it bears a 'data-userpin' attribute
printf("						var thisNodesLibUserPin = '';");
printf("						var node_li_subsectioncontainer = node_this.parentNode.parentNode;");
printf("						if(FavScreen.get('attrBrowserSupports_dataset')){");							//acquire the library's user-pin
printf("							thisNodesLibUserPin = node_li_subsectioncontainer.dataset.userpin;");
printf("						}else{");
printf("							thisNodesLibUserPin = node_li_subsectioncontainer.getAttribute(\"data-userpin\");");
printf("						}");
printf("						if(thisNodesLibUserPin != CURRENT_USER_PIN) {");							//does this library-message's user-pin NOT match the current user? (if so, then they're not authorized to edit it)
printf("							boolDoAttachForThisNode = false;");
printf("						}");
printf("					}");
printf("				}");
printf("			} catch(err) {");
printf("				FavScreen.log('warn',\"attachListenersForEditing: Conditional event handling attachment encountered an error (\"+err.message+\").\",true);");
printf("			}");
				//note: add any other edit handling exclusions here as else-if statements
printf("			if(boolDoAttachForThisNode) {");
printf("				var thisId = this.get('id');");									//get this LI node's ID attribute value (which is the favorite recno)
printf("				var thisSubscription = this.on('click', function(e){editFav_popPanel(thisId,e,this);});");	//create an on-click event listener and subscribe the editFav_popPanel function to its callback
printf("				arrEventHandles[parseInt(thisId)] = thisSubscription;");					//save this event handle into the global array (so it may be successfully detached later) -- we have to remove it from the YUI sandbox, in other words
printf("				i++;");
printf("			}");
printf("			});");//listitems.each
*/
printf("		FavScreen.log('log', \"attachListenersForEditing: Attached \"+i+\" 'click-to-edit' event listeners to messagecells in '\"+strListNodeId+\"'.\", true);");
//printf("		Spinner.hide();");
//printf("		Spinner.hide(FAVS_SPINNER_DELAY_HIDE + 300);");
printf("		};\n");//end method definition
printf("	Y.attachListenersForResponding = function(strListNodeId){");						//define a method for attaching edit listeners...
printf("		FavScreen.log('log',\"attachListenersForResponding: Attaching response listeners to \"+strListNodeId+\"...\",true);");
//printf("		Spinner.show();");
//printf("		Spinner.showAfterDelay(300);");
printf("		FavScreen.log('verbose',\"attachListenersForResponding: CALL STACK: \"+Error().stack,false);");
printf("		var listitems = Y.all(strListNodeId+\" li\");");							//get a nodelist of all LI nodes in the list node specified
printf("		i = 0;");												//so we can count how many were attached (for reporting purposes)
printf("		listitems.each( function(){");										//for each node in the nodelist, dictate what should happen whenever it's clicked (to edit a favorite msg)
printf("			var thisId = this.get('id');");									//get this LI node's ID attribute value (which is the favorite recno)
printf("			if(thisId.length>0){");										//if this is a valid favorite list-item (indicated by some id-attribute being specified)...
printf("				var thisSubscription = this.on('click', function(e){");						//create an on-click event listener and subscribe the LaunchFavorite function to its callback
printf("					if(messageCellActionIsValid(e)){");								//if a certain amount of time hasn't passed between now and when window-focus last changed, then don't launch the favorite (to prevent accidental launches when focusing window)
						//NOTE: Don't get confused! Validation routine returns false if Rule #2 AND exits reply-mode for us.
						//So, At the point, we should definitely be allowed to continue with a reply-msg of their own choosing (i.e. the msg-definition should not have reply-msgs specified)
printf("						flashHeaderWrapper('white');");
printf("						if(document.getElementById(thisId).className.indexOf('libmsg') > -1) {");			//if replying with a library message...
printf("							FavScreen.objMsgData_replyWith = {");								//populate the global object with data about the message they're using to reply with (from DOM)
printf("								replyWithFavRecno	  : thisId,");								//banner recno of the message-template to reply with
printf("								replyWithFavIcon	  : getDataFromMessagecellDOM_favIconSrc(thisId),");			//entire string of the icon (what would go in the IMG's SRC attribute)
printf("								replyWithFavName	  : getDataFromMessagecellDOM_favName(thisId),");			//name of the message on the fav's screen (not the msg-template key/name)
printf("								replyWithMsgTemplateDir	  : rsRec_getMsgTemplateDir(FavScreen.rsOrig, thisId),");		//directory of the message template that they're using to reply with
printf("								replyWithMsgTemplateName  : getDataFromMessagecellDOM_msgTemplateName(thisId),");		//name of the message template that they're using to reply with
printf("								replyWithMsgTemplateRecno : getDataFromMessagecellDOM_msgTemplateRecno(thisId)");		//record number of the message template that they're using to reply with
printf("								};");
printf("							if(getDataFromMessagecellDOM_libPin(thisId).trim() == \"%s\") {", FAVS_LIB_USER_STDREPLIES_PIN);//if they clicked on a standard-reply message (show the reply dialog)...
printf("								FavScreen.log('log',\"attachListenersForResponding: Reply-with message is in the standard-reply library. Showing reply-dialog...\",false);");
printf("								FavScreen.MessageReplyDialog.show();");								//initiate user dialog to actually reply (Note: routine is in dialogs.js file)
printf("							}else{");											//else not a standard reply (future-dev: expand other libs to new way we're using for standard reply, above)
printf("								FavScreen.log('log',\"attachListenersForResponding: Reply-with message is not in the standard-reply library. Treating it like a normal reply.\",true);");
printf("								launchFavorite(thisId);");
printf("							}");
printf("						}else{");											//else responding with a regular fav-message
printf("							FavScreen.objMsgData_replyWith = {");								//populate the global object with data about the message they're using to reply with (from rsOrig)
printf("								replyWithFavRecno	  : thisId,");								//banner recno of the message-template to reply with
printf("								replyWithFavIcon	  : getDataFromMessagecellDOM_favIconSrc(thisId),");			//entire string of the icon (what would go in the IMG's SRC attribute)
printf("								replyWithFavName	  : getDataFromMessagecellDOM_favName(thisId),");			//name of the message on the fav's screen (not the msg-template key/name)
printf("								replyWithMsgTemplateDir	  : rsRec_getMsgTemplateDir(FavScreen.rsOrig, thisId),");		//directory of the message template that they're using to reply with
printf("								replyWithMsgTemplateName  : rsRec_getMsgTemplateName(FavScreen.rsOrig, thisId),");		//name of the message template that they're using to reply with
printf("								replyWithMsgTemplateRecno : rsRec_getMsgTemplateRecno(FavScreen.rsOrig, thisId)");		//record number of the message template that they're using to reply with
printf("								};");
printf("							FavScreen.log('log',\"attachListenersForResponding: Reply-with message does not belong to a library (it may be a normal message). Calling launchFavorite...\",false);");
printf("							launchFavorite(thisId);");
/* PROB SAFE TO REMOVE THIS?
printf("							var response = sendReplyToMsg();");
printf("							if(response) {");
printf("								FavScreen.log('log', 'attachListenersForResponding: Success reported in response from sendReplyToMsg().', true);");
printf("								setTimeout(function(){window.refreshRecordset_inboxMsgs(CURRENT_USER_PIN, false, true);},1000);");
printf("								window.FavScreen.set('attrInteractionMode', window.MODE_LAUNCHABLE);");
printf("								window.scrollTo_animated(document.body, FavScreen.get('attrPreviousScrollPositionPixelY'), 150);");
printf("							}else{");
printf("								FavScreen.log('log', 'attachListenersForResponding: Failure reported in response from sendReplyToMsg().', true);");
printf("							}");
*/
printf("						}");
printf("					}");//end if-action-is-valid
printf("					});");//end click-to-respond event handler
printf("				arrEventHandles[parseInt(thisId)] = thisSubscription;");					//save this event handle into the global array (so it may be successfully detached later) -- we have to remove it from the YUI sandbox, in other words
printf("				i++;");
printf("			}");//end if
printf("			});");//listitems.each
printf("		FavScreen.log('log', \"attachListenersForResponding: Attached \"+i+\" 'click-to-reply' event listeners to messagecells in '\"+strListNodeId+\"'.\", true);");
//printf("		Spinner.hide();");
//printf("		Spinner.hide(FAVS_SPINNER_DELAY_HIDE + 300);");
printf("		};\n");//end method definition
printf("	Y.attachListenersForSorting = function(){");								//define a method for making the lists sortable (this method should only be invoked once for the page... not once for each list, like the other event listeners)
printf("		FavScreen.log('log',\"attachListenersForSorting: Attaching sort listeners to various lists...\",true);");
printf("		Spinner.show();");
//printf("		Spinner.showAfterDelay(300);");
printf("		FavScreen.log('verbose',\"attachListenersForSorting: CALL STACK: \"+Error().stack,false);");
printf("		var j = 0;");												//so we can count how many types of sort event listeners were attached (and save references into the global scope for later detachment)
printf("		var k = 0;");												//so we can count how many overall sort event listeners were attached in each list (and save references into the global scope for later detachment)
printf("		var l = 0;");												//so we can count how many overall sort event listeners were attached globally (and save references into the global scope for later detachment)
			// Setup main sortable list (aka critical)...
printf("		try {");
printf("			var supportsScrollY = Boolean(FavScreen.get('attrBrowserSupports_scrollY'));");
printf("			i = 0;");												//re-initiatialize a counter to keep track of how many lists will have had sort-listeners attached
printf("			j = 0;");												//re-initiatialize a counter to keep track of how many types of event listener we will have attached
printf("			k = 0;");												//re-initiatialize a counter to keep track of how many event listeners total we will have attached to this list
				// Setup sorted list...
printf("			var list_critical = new Y.Sortable({");									//instantiate a Sortable instance on the sorted list, making its items draggable (note: Sortable uses DD.Delegate)
printf("				container:'#'+window.objConfig_MajorSection_critical.str_sectionDomID,");				//the container of the critical node(s)
printf("				nodes:'li.messagecell',");										//the entire LI node, as a whole, is sortable
printf("				handles:[\".actionwrapper\",\".iconwrapper\"],");							//drag handles shall only be the actionwrapper and iconwrapper areas
printf("				opacity:'.1'");												//make the node semi-transparent when it starts to be dragged, so you can see what potential drop targets it's going over
printf("				});");
printf("			FavScreen.log('log',\"attachListenersForSorting:  Delegating for '\"+list_critical.get('container')+\"'...\",true);");
printf("			list_critical.delegate.dd.plug(Y.Plugin.DDConstrained, {");						//set the constraint for dragging sorted messagecell items
//printf("				constrain2node:'#'+window.objConfig_MajorSection_critical.str_sectionDomID");				//constrain dragging of msgs already in the 'critical' section to only the critical list node
printf("				constrain2node:'#bodywrapper'");									//constrain dragging to the bodywrapper node (gives a more fluid impression, rather than snapping to the sorted list)
printf("				});");
printf("			list_critical.delegate.on('drag:start', function(e){");							//define what should happen on a drag:start event
printf("				if(typeof FavScreen.timeoutHandle_autoEndEditMode!==\"undefined\"){");					//if the edit-mode automatic timeout is running, cancel it for the duration of this drag operation
printf("					clearTimeout(FavScreen.timeoutHandle_autoEndEditMode);");					//cancel the auto-end edit-mode timer
printf("				}");//end if timeoutHandle exists
printf("				});");
printf("			list_critical.delegate.on('drag:drag', function(e){");							//define what should happen on a drag:drag event (each time an item moves 1px while dragging) -- we need to scroll the window for them while they drag up or down near window edge
printf("				var scrollTriggerPx = 50;");										//define the space with which to trigger scrolling (should be at least the height of a messagecell item
printf("				var y = e.target.lastXY[1];");										//get the most-recent (effectively, the current) Y value from this event
//printf("				if(FavScreen.get('attrBrowserSupports_scrollY')){var currentScrollY = window.scrollY;}");		//get current vertical scroll value (for better browsers)
printf("				if(supportsScrollY){var currentScrollY = window.scrollY;}");						//get current vertical scroll value (for better browsers)
printf("				else{var currentScrollY = document.documentElement.scrollTop;}");					//get current vertical scroll value (for crappy browsers)
printf("				if(y<currentScrollY+scrollTriggerPx){window.scrollTo(0,y-scrollTriggerPx);}");				//if the favorite is being dragged above the visible window, scroll the window up
printf("				if(y+scrollTriggerPx>currentScrollY+window.innerHeight){window.scrollTo(0,y+scrollTriggerPx);}");	//if the favorite (including a small margin below it) is being dragged below the visible window, scroll the window down  -DEV-NOTE: this doesn't work in IE9, but who cares
printf("				});");
printf("			list_critical.delegate.after('drag:end', function(e){");						//define what should happen after a drag:end event -- we need to update the recordset with this new ordering
printf("				var node = list_critical.delegate.get('currentNode');");						//get reference to the messagecell node being dragged
printf("				var drop = node.ancestor();");										//get reference to the list node where the dragged node was just dropped
printf("				handleMessageCellUpdates_afterDragAndDropEvent(node, drop);");
printf("				handleAutoEndEditMode_setOrReset();");									//handle restarting the edit mode auto timeout
printf("				});");
printf("			objEventHandles_forSorting.messagelist_critical = [];");						//create an array for this list in the object that globalizes event handles (so it can be detached later)
printf("			for(var ii=0; ii<list_critical.delegate._handles.length; ii++){");					//for each event handler type (delegation) registered with this list (e.g. mouseenter, mousedown, etc.)...
printf("				k = k + list_critical.delegate._handles[ii].evt.el.getElementsByClassName('messagecell').length;");	//add the number of children we delegated this type of event listener to
printf("				FavScreen.log('log',\"attachListenersForSorting:   Delegated \"+list_critical.delegate._handles[ii].evt.el.getElementsByClassName('messagecell').length+\" '\"+list_critical.delegate._handles[ii].evt.type+\"' event-listeners to the list-items in '\"+list_critical.get('container')+\"'.\",true);");
printf("				objEventHandles_forSorting.messagelist_critical[ii] = list_critical.delegate._handles[ii];");		//hand it to the global object's array for this list
printf("				j++;");
printf("			}");
printf("			window.listenerDelegationsForSorting = window.listenerDelegationsForSorting + j;");			//add this list's delegation type count to the global total
printf("			l = l + k;");												//add this list's total to the global total
printf("			FavScreen.log('log',\"attachListenersForSorting:   Finished delegating a total of \"+k+\" event-listeners in '\"+list_critical.get('container')+\"'. Total for all lists is now \"+l+\".\",true);");
printf("		}");
printf("		catch(err) {");
printf("			FavScreen.log('warn',\"attachListenersForSorting: Conditional event handling attachment on sorted section encountered an error (\"+err.message+\").\",true);");
printf("		}");
			// Setup personal-libraries sortable list...
printf("		try {");
printf("			var supportsScrollY = Boolean(FavScreen.get('attrBrowserSupports_scrollY'));");
printf("			i++;");													//increment our list counter (remember, we're using zero-based, that's why we're incrementing at the beginning)
printf("			j = 0;");												//re-initiatialize a counter to keep track of how many types of event listener we will have attached
printf("			k = 0;");												//re-initiatialize a counter to keep track of how many event listeners total we will have attached to this list
printf("			var list_personalLibs = new Y.Sortable({");								//instantiate a Sortable instance on the personal-libs list, making its items draggable (note: Sortable uses DD.Delegate)
printf("				container:'#'+window.objConfig_MajorSection_personalLibs.str_sectionDomID,");				//the container of the personal-libs node(s)
printf("				nodes:'li.sortable',");										//the entire LI node, as a whole, is sortable
//printf("				invalid:'li.sectionheader',");	//nodes to exclude
printf("				handles:[\".actionwrapper\",\".iconwrapper\"],");							//drag handles shall only be the actionwrapper and iconwrapper areas
printf("				opacity:'.1'");												//make the node semi-transparent when it starts to be dragged, so you can see what potential drop targets it's going over
printf("				});");
//printf("debugger;");
printf("			FavScreen.log('log',\"attachListenersForSorting:  Delegating for '\"+list_personalLibs.get('container')+\"'...\",true);");
printf("			list_personalLibs.delegate.dd.plug(Y.Plugin.DDConstrained, {");						//set the constraint for dragging sorted messagecell items
//printf("				constrain2node:'#'+window.objConfig_MajorSection_critical.str_sectionDomID");				//constrain dragging of msgs already in the 'critical' section to only the critical list node
printf("				constrain2node:'#bodywrapper'");									//constrain dragging to the bodywrapper node (gives a more fluid impression, rather than snapping to the sorted list)
printf("				});");
printf("			list_personalLibs.delegate.on('drag:start', function(e){");						//define what should happen on a drag:start event
printf("				if(typeof FavScreen.timeoutHandle_autoEndEditMode!==\"undefined\"){");					//if the edit-mode automatic timeout is running, cancel it for the duration of this drag operation
printf("					clearTimeout(FavScreen.timeoutHandle_autoEndEditMode);");					//cancel the auto-end edit-mode timer
printf("				}");//end if timeoutHandle exists
printf("				});");
printf("			list_personalLibs.delegate.on('drag:drag', function(e){");						//define what should happen on a drag:drag event (each time an item moves 1px while dragging) -- we need to scroll the window for them while they drag up or down near window edge
printf("				var scrollTriggerPx = 50;");										//define the space with which to trigger scrolling (should be at least the height of a messagecell item
printf("				var y = e.target.lastXY[1];");										//get the most-recent (effectively, the current) Y value from this event
//printf("				if(FavScreen.get('attrBrowserSupports_scrollY')){var currentScrollY = window.scrollY;}");		//get current vertical scroll value (for better browsers)
printf("				if(supportsScrollY){var currentScrollY = window.scrollY;}");						//get current vertical scroll value (for better browsers)
printf("				else{var currentScrollY = document.documentElement.scrollTop;}");					//get current vertical scroll value (for crappy browsers)
printf("				if(y<currentScrollY+scrollTriggerPx){window.scrollTo(0,y-scrollTriggerPx);}");				//if the favorite is being dragged above the visible window, scroll the window up
printf("				if(y+scrollTriggerPx>currentScrollY+window.innerHeight){window.scrollTo(0,y+scrollTriggerPx);}");	//if the favorite (including a small margin below it) is being dragged below the visible window, scroll the window down  -DEV-NOTE: this doesn't work in IE9, but who cares
printf("				});");
printf("			list_personalLibs.delegate.after('drag:end', function(e){");						//define what should happen after a drag:end event -- we need to update the recordset with this new ordering
printf("				var node = list_personalLibs.delegate.get('currentNode');");						//get reference to the messagecell node being dragged
printf("				var drop = node.ancestor();");										//get reference to the list node where the dragged node was just dropped
printf("				handleMessageCellUpdates_afterDragAndDropEvent(node, drop);");
printf("				handleAutoEndEditMode_setOrReset();");									//handle restarting the edit mode auto timeout
printf("				});");
printf("			objEventHandles_forSorting.messagelist_personalLibs = [];");						//create an array for this list in the object that globalizes event handles (so it can be detached later)
printf("			for(var ii=0; ii<list_personalLibs.delegate._handles.length; ii++){");						//for each event handle registered with this list...
printf("				k = k + list_personalLibs.delegate._handles[ii].evt.el.getElementsByClassName('messagecell').length;");	//add the number of children we delegated this type of event listener to
printf("				FavScreen.log('log',\"attachListenersForSorting:   Delegated \"+list_personalLibs.delegate._handles[ii].evt.el.getElementsByClassName('messagecell').length+\" '\"+list_personalLibs.delegate._handles[ii].evt.type+\"' event-listeners to the list-items in '\"+list_personalLibs.get('container')+\"'.\",true);");
printf("				objEventHandles_forSorting.messagelist_personalLibs[ii] = list_personalLibs.delegate._handles[ii];");	//hand it to the global object's array for this list
printf("				j++;");
printf("			}");
printf("			window.listenerDelegationsForSorting = window.listenerDelegationsForSorting + j;");			//add this list's delegation type count to the global total
printf("			l = l + k;");												//add this list's total to the global total
printf("			FavScreen.log('log',\"attachListenersForSorting:   Finished delegating a total of \"+k+\" event-listeners in '\"+list_personalLibs.get('container')+\"'. Total for all lists is now \"+l+\".\",true);");
printf("		}");
printf("		catch(err) {");
printf("			FavScreen.log('warn',\"attachListenersForSorting: Conditional event handling attachment on personal-libs section encountered an error (\"+err.message+\").\",true);");
printf("		}");
			// Setup shared-library list (if necessary by virtue of current user being a LIB class of user)...
printf("		var isAnyLibOwnedByCurrentUser = anyLibraryIsOwnedBy(CURRENT_USER_PIN);");				//get whether there is any library owned by this currently-logged-in user (is a ref to their owned-lib node if true, or false)
printf("		if(Boolean(isAnyLibOwnedByCurrentUser)) {");								//if current user *is* a LIB user, use their pin to setup sorting on their library sub-section UL
printf("			try {");
printf("				i++;");
printf("				j = 0;");												//re-initiatialize a counter to keep track of how many types of event listener we will have attached
printf("				k = 0;");												//re-initiatialize a counter to keep track of how many event listeners total we will have attached to this list
printf("				var node_sortableLIs = isAnyLibOwnedByCurrentUser.getElementsByClassName('messagelist')[0];");		//get a reference to the node of actual messagecell LIs in the library (we don't want subheaders, etc.)
printf("				var node_sortableLIs_id = node_sortableLIs.id;");
printf("				var list_sharedLib = new Y.Sortable({");									//instantiate a Sortable instance on the user's owned library list, making its items draggable (note: Sortable uses DD.Delegate)
printf("					container:'#'+node_sortableLIs_id,");									//the container of the sortable node(s)
printf("					nodes:'li.libmsg',");											//the entire LI node, as a whole, is sortable (but only those with a libmsg class, so we don't attach to subsection titles, etc.)
printf("					handles:[\".actionwrapper\",\".iconwrapper\"],");							//drag handles shall only be the actionwrapper and iconwrapper areas
printf("					opacity:'.1'");												//make the node semi-transparent when it starts to be dragged, so you can see what potential drop targets it's going over
printf("					});");
printf("				FavScreen.log('log',\"attachListenersForSorting:  Delegating for '\"+list_sharedLib.get('container')+\"'...\",true);");
printf("				list_sharedLib.delegate.dd.plug(Y.Plugin.DDConstrained, {");						//set the constraint for dragging sorted messagecell items
printf("					constrain2node:'#'+node_sortableLIs_id");								//constrain dragging of msgs already in the 'sorted' sectiion to only the sorted list node
printf("					});");
printf("				list_sharedLib.delegate.on('drag:start', function(e){");							//define what should happen on a drag:start event
printf("					if(typeof FavScreen.timeoutHandle_autoEndEditMode!==\"undefined\"){");					//if the edit-mode automatic timeout is running, cancel it for the duration of this drag operation
printf("						clearTimeout(FavScreen.timeoutHandle_autoEndEditMode);");					//cancel the auto-end edit-mode timer
printf("					}");//end if timeoutHandle exists
printf("					});");
printf("				list_sharedLib.delegate.on('drag:drag', function(e){");							//define what should happen on a drag:drag event (each time an item moves 1px while dragging) -- we need to scroll the window for them while they drag up or down near window edge
printf("					var scrollTriggerPx = 50;");										//define the space with which to trigger scrolling (should be at least the height of a messagecell item
printf("					var y = e.target.lastXY[1];");										//get the most-recent (effectively, the current) Y value from this event
//printf("					if(FavScreen.get('attrBrowserSupports_scrollY')){var currentScrollY = window.scrollY;}");		//get current vertical scroll value (for better browsers)
printf("					if(supportsScrollY){var currentScrollY = window.scrollY;}");						//get current vertical scroll value (for better browsers)
printf("					else{var currentScrollY = document.documentElement.scrollTop;}");					//get current vertical scroll value (for crappy browsers)
printf("					if(y<currentScrollY+scrollTriggerPx){window.scrollTo(0,y-scrollTriggerPx);}");				//if the favorite is being dragged above the visible window, scroll the window up
printf("					if(y+scrollTriggerPx>currentScrollY+window.innerHeight){window.scrollTo(0,y+scrollTriggerPx);}");	//if the favorite (including a small margin below it) is being dragged below the visible window, scroll the window down  -DEV-NOTE: this doesn't work in IE9, but who cares
printf("					});");
printf("				list_sharedLib.delegate.after('drag:end', function(e){");							//define what should happen after a drag:end event -- we need to update the recordset with this new ordering
printf("					var node = list_sharedLib.delegate.get('currentNode');");							//get reference to the messagecell node being dragged
printf("					var drop = node.ancestor();");										//get reference to the list node where the dragged node was just dropped
printf("					handleMessageCellUpdates_afterDragAndDropEvent(node, drop);");
printf("					handleAutoEndEditMode_setOrReset();");									//handle restarting the edit mode auto timeout
printf("					});");
printf("				objEventHandles_forSorting.messagelist_sharedLib = [];");							//create an array for this list in the object that globalizes event handles (so it can be detached later)
printf("				for(var ii=0; ii<list_sharedLib.delegate._handles.length; ii++){");					//for each event handle registered with this list...
printf("					k = k + list_sharedLib.delegate._handles[ii].evt.el.getElementsByClassName('messagecell').length;");	//add the number of children we delegated this type of event listener to
printf("					FavScreen.log('log',\"attachListenersForSorting:   Delegated \"+list_sharedLib.delegate._handles[ii].evt.el.getElementsByClassName('messagecell').length+\" '\"+list_sharedLib.delegate._handles[ii].evt.type+\"' event-listeners to the list-items in '\"+list_sharedLib.get('container')+\"'.\",true);");
printf("					objEventHandles_forSorting.messagelist_sharedLib[ii] = list_sharedLib.delegate._handles[ii];");		//hand it to the global object's array for this list
printf("					j++;");
printf("				}");
printf("				window.listenerDelegationsForSorting = window.listenerDelegationsForSorting + j;");			//add this list's delegation type count to the global total
printf("				l = l + k;");												//add this list's total to the global total
printf("				FavScreen.log('log',\"attachListenersForSorting:   Finished delegating a total of \"+k+\" event-listeners in '\"+list_sharedLib.get('container')+\"'. Total for all lists is now \"+l+\".\",true);");
printf("			}");
printf("			catch(err) {");
printf("				FavScreen.log('warn',\"attachListenersForSorting: Conditional event handling attachment on library section encountered an error (\"+err.message+\").\",true);");
printf("			}");
printf("		}");//end if LIB user
			// Setup unsorted/dropbox list...
printf("		try {");
printf("			if(document.getElementById('messagelist-dropbox') === null) {");
printf("				throw new Error('#messagelist-dropbox does not exist in the DOM. Nothing to attach.');");
printf("			}else{");
printf("			i++;");
printf("			j = 0;");												//re-initiatialize a counter to keep track of how many types of event listener we will have attached
printf("			k = 0;");												//re-initiatialize a counter to keep track of how many event listeners total we will have attached to this list
printf("			var list_dropbox = new Y.Sortable({");								//instantiate a Sortable instance on the unsorted list, making its items draggable (note: Sortable uses DD.Delegate)
printf("				container:'#'+window.objConfig_MajorSection_dropbox.str_sectionDomID,");				//the container of the dropbox node(s)
printf("				nodes:'li.messagecell',");												//the entire LI node, as a whole, is sortable
printf("				handles:[\".actionwrapper\",\".iconwrapper\"],");							//drag handles shall only be the actionwrapper and iconwrapper areas
printf("				opacity:'.1'");												//make the node semi-transparent when it starts to be dragged, so you can see what potential drop targets it's going over
printf("				});");
printf("				FavScreen.log('log',\"attachListenersForSorting:  Delegating for '\"+list_dropbox.get('container')+\"'...\",true);");
printf("			list_dropbox.delegate.dd.plug(Y.Plugin.DDConstrained, {");						//set the constraint for dragging unsorted messagecell items
printf("				constrain2node:'#bodywrapper'");									//constrain dragging to the bodywrapper node (gives a more fluid impression, rather than snapping to the sorted list)
printf("				});");
printf("			list_dropbox.delegate.on('drag:start', function(e){");						//define what should happen on a drag:start event
printf("				if(typeof FavScreen.timeoutHandle_autoEndEditMode!==\"undefined\"){");					//if the edit-mode automatic timeout is running, cancel it for the duration of this drag operation
printf("					clearTimeout(FavScreen.timeoutHandle_autoEndEditMode);");					//cancel the auto-end edit-mode timer
printf("				}");//end if timeoutHandle exists
printf("				});");
printf("			list_dropbox.delegate.on('drag:drag', function(e){");							//define what should happen on a drag:drag event (each time an item moves 1px while dragging) -- we need to scroll the window for them while they drag up or down near window edge
printf("				var scrollTriggerPx = 50;");										//define the space with which to trigger scrolling (should be at least the height of a messagecell item
printf("				var y = e.target.lastXY[1];");										//get the most-recent (effectively, the current) Y value from this event
//printf("				if(FavScreen.get('attrBrowserSupports_scrollY')){var currentScrollY = window.scrollY;}");		//get current vertical scroll value (for better browsers)
printf("				if(supportsScrollY){var currentScrollY = window.scrollY;}");						//get current vertical scroll value (for better browsers)
printf("				else{var currentScrollY = document.documentElement.scrollTop;}");					//get current vertical scroll value (for crappy browsers)
printf("				if(y<currentScrollY+scrollTriggerPx){window.scrollTo(0,y-scrollTriggerPx);}");				//if the favorite is being dragged above the visible window, scroll the window up
printf("				if(y+scrollTriggerPx>currentScrollY+window.innerHeight){window.scrollTo(0,y+scrollTriggerPx);}");	//if the favorite (including a small margin below it) is being dragged below the visible window, scroll the window down  -DEV-NOTE: this doesn't work in IE9, but who cares
printf("				});");
printf("			list_dropbox.delegate.after('drag:end', function(e){");						//define what should happen after a drag:end event -- we need to update the recordset with this new ordering
printf("				var node = this.get('currentNode');");									//get reference to the messagecell node being dragged
printf("				var drop = node.ancestor();");										//get reference to the list node where the dragged node was just dropped
printf("				handleMessageCellUpdates_afterDragAndDropEvent(node, drop);");
printf("				handleAutoEndEditMode_setOrReset();");									//handle restarting the edit mode auto timeout
printf("				});");
//DEV-NOTE: left-off... click wasn't working like this... need to bring in another class maybe? -- search how to delegate regular click listeners
//printf("			list_dropbox.delegate.on('click', function(e){");
//printf("				alert('clicked');");
//printf("				");
//printf("				});");
printf("			objEventHandles_forSorting.messagelist_dropbox = [];");						//create an array for this list in the object that globalizes event handles (so it can be detached later)
printf("			for(var ii=0; ii<list_dropbox.delegate._handles.length; ii++){");					//for each event handle registered with this list...
printf("				k = k + list_dropbox.delegate._handles[ii].evt.el.getElementsByClassName('messagecell').length;");	//add the number of children we delegated this type of event listener to
printf("				FavScreen.log('log',\"attachListenersForSorting:   Delegated \"+list_dropbox.delegate._handles[ii].evt.el.getElementsByClassName('messagecell').length+\" '\"+list_dropbox.delegate._handles[ii].evt.type+\"' event-listeners to the list-items in '\"+list_dropbox.get('container')+\"'.\",true);");
printf("				objEventHandles_forSorting.messagelist_dropbox[ii] = list_dropbox.delegate._handles[ii];");		//hand it to the global object's array for this list
printf("				j++;");
printf("			}");
printf("			window.listenerDelegationsForSorting = window.listenerDelegationsForSorting + j;");			//add this list's delegation type count to the global total
printf("			l = l + k;");												//add this list's total to the global total
printf("			FavScreen.log('log',\"attachListenersForSorting:   Finished delegating a total of \"+k+\" event-listeners in '\"+list_dropbox.get('container')+\"'. Total for all lists is now \"+l+\".\",true);");
printf("			}");//end else
printf("		}");
printf("		catch(err) {");
printf("			FavScreen.log('info',\"attachListenersForSorting: Conditional event handling attachment on dropbox section encountered a quirk (\"+err.message+\").\",true);");
printf("		}");
			//do stuff for overall sorting...

printf("		if((typeof list_critical !== 'undefined') && (typeof list_dropbox !== 'undefined')) {");			//join any conditionally-existing drag/drop eligible lists...
printf("			list_critical.join(list_dropbox, 'inner');");									// dropbox -> critical  (join the lists in the way that makes it so that dropbox items can be dragged into the critical list, but not the other way around)
printf("		}");
printf("		if((typeof list_sharedLib !== 'undefined') && (typeof list_dropbox !== 'undefined')) {");			//join any conditionally-existing drag/drop eligible lists...
printf("			list_sharedLib.join(list_dropbox, 'inner');");									// dropbox -> sharedLib  (join the lists in the way that makes it so that dropbox items can be dragged into a share-library list, but not the other way around)
printf("		}");
printf("		if((typeof list_sharedLib !== 'undefined') && (typeof list_critical !== 'undefined')) {");			//join any conditionally-existing drag/drop eligible lists...
printf("			list_sharedLib.join(list_critical);");										// critical <-> sharedLib  (join the lists in the way that makes it so that critical items can be dragged into a shared-library list, and vice-versa)
printf("		}");
printf("		if((typeof list_personalLibs !== 'undefined') && (typeof list_critical !== 'undefined')) {");			//join any conditionally-existing drag/drop eligible lists...
printf("			list_personalLibs.join(list_critical);");									// critical <-> personalLibs  (join the lists in the way that makes it so that critical items can be dragged into the personal-libraries list, and vice-versa)
printf("		}");
printf("		if((typeof list_personalLibs !== 'undefined') && (typeof list_dropbox !== 'undefined')) {");			//join any conditionally-existing drag/drop eligible lists...
printf("			list_personalLibs.join(list_dropbox, 'inner');");								// dropbox -> personalLibs  (join the lists in the way that makes it so that dropbox items can be dragged into the personal-libraries list, but not the other way around)
printf("		}");

//printf("		window.listenerDelegationsForSorting = j;");
printf("		FavScreen.log('log', \"attachListenersForSorting:  Finished attaching drag-and-drop event listeners (\"+l+\" total listeners among \"+(i+1)+\" lists).\", true);");
//printf("		Spinner.hide();");
printf("		Spinner.hide(FAVS_SPINNER_DELAY_HIDE + 500);");
printf("		};\n");//end method definition
printf("	},\"\",{requires:[\"node\",\"dd-constrain\",\"sortable\"]});\n");//end messagecell-listeners-attach module creation

printf("YUI().add(\"messagecell-listeners-detach\", function(Y){");						//Create a YUI module for detaching event listeners to message cells  (to use, specify this namespace as an argument to the usual YUI().use method)
printf("	Y.detachListeners = function(strListNodeId){");							//define a method for detaching all listeners from messagecells in a specified list...
printf("		var i = 0;");
printf("		var ii = 0;");
			// Handle detaching traditional event listeners (non delegation?)...
printf("		if(arrEventHandles.length>0 && typeof strListNodeId!==\"undefined\"){");			//if there are any non-delegated event handles saved in the global array used for keeping track of them AND the list node id is valid...
printf("			i = 0;");											//reinitialize so we can count how many were successfully detached (for reporting purposes)
printf("			ii = 0;");											//reinitialize so we can count how many were supposed to be detached (for reporting purposes)
printf("			var listitems = Y.all(strListNodeId+\" li\");");						//get a nodelist of all LI nodes in the list node specified
printf("			listitems.each( function(){");									//for each node in the nodelist, detach its event listeners
printf("				ii++;");
printf("				var thisId = this.get('id');");								//get this LI node's ID attribute value (which is the favorite recno)
printf("				this.detach();");									//try the "proper" way (DEV-NOTE: this likely won't work until the YUI sandboxing issue is addressed)
printf("				if(typeof arrEventHandles[parseInt(thisId)]!==\"undefined\"){");			//make sure we have a valid object to apply the detach method to, so we don't get any errors
printf("					arrEventHandles[parseInt(thisId)].detach();");
printf("					i++;");
printf("				}");//end if
printf("				});");//listitems.each
printf("			FavScreen.log('log', \"detachListeners: Detached \"+i+\" out of approx \"+ii+\" potentially existing event listeners (could be headers w/out listeners) from list-items in '\"+strListNodeId+\"'.\", true);");
printf("		}");//end if
			// Handle detaching the sort (drag-and-drop) delegated event listeners...
printf("		if(window.listenerDelegationsForSorting>0){");							//if there are any sort-type event handles saved in the global array used for keeping track of them...
printf("			if(typeof objEventHandles_forSorting.messagelist_critical===\"object\"){");
printf("				for(var i=0; i<objEventHandles_forSorting.messagelist_critical.length; i++){");		//for each handle attached/delegated to this list...
printf("					if(typeof objEventHandles_forSorting.messagelist_critical[i]!==\"undefined\"){");//make sure we have a valid object to apply the detach method to, so we don't get any errors
printf("						objEventHandles_forSorting.messagelist_critical[i].detach();");
printf("						listenerDelegationsForSorting--;");
printf("					}");//end if
printf("				}");//end for
printf("			}");//end if
printf("			if(typeof objEventHandles_forSorting.messagelist_dropbox===\"object\"){");
printf("				for(var i=0; i<objEventHandles_forSorting.messagelist_dropbox.length; i++){");		//for each handle attached/delegated to this list...
printf("					if(typeof objEventHandles_forSorting.messagelist_dropbox[i]!==\"undefined\"){");//make sure we have a valid object to apply the detach method to, so we don't get any errors
printf("						objEventHandles_forSorting.messagelist_dropbox[i].detach();");
printf("						listenerDelegationsForSorting--;");
printf("					}");//end if
printf("				}");//end for
printf("			}");//end if
printf("			if(typeof objEventHandles_forSorting.messagelist_sharedLib===\"object\"){");
printf("				for(var i=0; i<objEventHandles_forSorting.messagelist_sharedLib.length; i++){");	//for each handle attached/delegated to this list...
printf("					if(typeof objEventHandles_forSorting.messagelist_sharedLib[i]!==\"undefined\"){");//make sure we have a valid object to apply the detach method to, so we don't get any errors
printf("						objEventHandles_forSorting.messagelist_sharedLib[i].detach();");
printf("						listenerDelegationsForSorting--;");
printf("					}");//end if
printf("				}");//end for
printf("			}");//end if
printf("			if(typeof objEventHandles_forSorting.messagelist_personalLibs===\"object\"){");
printf("				for(var i=0; i<objEventHandles_forSorting.messagelist_personalLibs.length; i++){");	//for each handle attached/delegated to this list...
printf("					if(typeof objEventHandles_forSorting.messagelist_personalLibs[i]!==\"undefined\"){");//make sure we have a valid object to apply the detach method to, so we don't get any errors
printf("						objEventHandles_forSorting.messagelist_personalLibs[i].detach();");
printf("						listenerDelegationsForSorting--;");
printf("					}");//end if
printf("				}");//end for
printf("			}");//end if
printf("		}");//end if
printf("		};");//end method definition
printf("	},\"\",{requires:[\"node\"]});\n");//end messagecell-listeners-detach module creation

printf("var listenerDelegationsForSorting = 0;");
printf("function attachActionListenersToMessageCells(strListNodeId){");					//Tell each cell in the specified list node what to do whenever the user performs various actions upon them...
printf("	FavScreen.log('verbose',\"attachActionListenersToMessageCells('\"+strListNodeId+\"'): Starting... (mode is '\"+FavScreen.get('attrInteractionMode')+\"')\",true);");
printf("	if(typeof document.getElementById(strListNodeId.split('#')[1]) === null) {");
printf("		FavScreen.log('warn',\"attachActionListenersToMessageCells(): Node with ID of '\"+strListNodeId.split('#')[1]+\"' does not exist, aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	if(FavScreen.get('attrInteractionMode')==MODE_LAUNCHABLE){");					//If favorites screen is in click-to-launch mode... (a click should launch the message, so need to disallow edit features)...
printf("		YUI().use('node','messagecell-listeners-attach','messagecell-listeners-detach', function(Y){");
printf("			Y.detachListeners(strListNodeId);");							//detach any pre-existing event listeners (e.g. click to edit, drag to sort)
printf("			Y.attachListenersForLaunching(strListNodeId);");					//attach event listeners appropriate for launch mode (e.g. click to launch)
printf("		});");//end YUI.use()

printf("	}");//end if MODE_LAUNCHABLE
printf("	else if(FavScreen.get('attrInteractionMode')==MODE_EDITABLE){");				// Else-if favorites screen is in editable mode... (enable drag and drop, click to change text, icons, etc.)...
printf("		YUI().use('node','messagecell-listeners-attach', 'messagecell-listeners-detach', function(Y){");
printf("			Y.detachListeners(strListNodeId);");							//detach any pre-existing event listeners (e.g. click to launch)
//DEV-NOTE: see whether refreshRecordset already does this... need to refresh but not jump after going to edit mode
printf("			Y.attachListenersForEditing(strListNodeId);");						//attach event listeners appropriate for edit mode (e.g. click to edit)
printf("			if( YUI.Env.UA.android>0 && (YUI.Env.UA.chrome<35.01916) ){");
printf("				FavScreen.log('info', \"This Android browser does not currently support YUI drag-drop of messagecells... drag-drop disabled.\", true);");
printf("				window.alert(\"This Android browser does not currently support drag-and-drop sorting of %s, but you may still edit a %s.\\n\\nTo access all features, we recomend you use the official app or the latest Chrome.\");", FAVS_NAME_PLURAL, FAVS_NAME_SINGULAR);
printf("			}");
printf("			else{");
printf("				if(listenerDelegationsForSorting>0){return false;}");				//if listeners for sorting have already been attached, then don't do it again (abort this method/function)
printf("				Y.attachListenersForSorting();");						//attach event listeners appropriate for edit mode sorting operations
printf("			}");
printf("		});");//end YUI.use()
printf("	}");//end else-if
printf("	else if(FavScreen.get('attrInteractionMode')==MODE_DELETED){");					// Else-if favorites screen is in deleted-favs mode... (enable click to un-delete and send back to unsorted)...
printf("		evtHandleClickMessageCells.detach();");
printf("		YUI().use('node', 'io-base', 'querystring-stringify-simple', function(Y){");			//attach click event listeners to favorite-message cells, so they can be clicked to launch the message template they refer to...
printf("			evtHandleClickMessageCells = Y.one(strListNodeId).delegate('click', function(){undeleteFav_popPanel(this.get(\"id\"))}, 'li');");//actually attach the click event listener to each LI node that exists in any UL with the specified ID
printf("		});");//end YUI.use()
printf("	}");//end else-if
printf("	else if(FavScreen.get('attrInteractionMode')==MODE_REPLYING){");				// Else-if favorites screen is in replying mode... (enable click to reply to a specific message -which data is in global state)...
printf("		YUI().use('node','messagecell-listeners-attach','messagecell-listeners-detach', function(Y){");
printf("			Y.detachListeners(strListNodeId);");							//detach any pre-existing event listeners (e.g. click to edit, drag to sort)
printf("			Y.attachListenersForResponding(strListNodeId);");					//attach event listeners appropriate for reply mode (e.g. click to reply to a particular message)
printf("		});");//end YUI.use()
printf("	}");//end else-if
printf("	else{");
printf("		console.error(\"There was a problem with attaching action listeners because the interaction mode couldn't be determined.\");");
//printf("		FavScreen.log('error', \"There was a problem with the FavScreen class instance\", true);");
printf("	}");
printf("}\n");//end function attachActionListenersToMessageCells()
printf("function attachActionListenersToMessageCells_allSubsectionsInSection(strNodeID_listOfSubsections){");//Tell each cell in the specified list node what to do whenever the user performs various actions upon them...
printf("	var nodeRefListOfSubsections = document.getElementById(strNodeID_listOfSubsections);");		//get a reference to the main UL (section) that contains our nested subsection lists
printf("	if(nodeRefListOfSubsections === null) {");
printf("		FavScreen.log('error',\"attachActionListenersToMessageCells_allSubsectionsInSection(): Node with id '\"+strNodeID_listOfSubsections+\"' does not exist. Nothing to attach listeners to... Aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	var numOfSubsectionLIs = nodeRefListOfSubsections.childNodes.length;");				//get how many LI nodes (containers for nested UL's) there are (Note: the first one will likely be the section header text, so will need to account for that)
printf("	var nodeRefLI, nodeRefNestedUL, listNodeID;");
printf("	for(var i=0; i<numOfSubsectionLIs; i++){");							//going through each LI node in the main section list...
printf("		nodeRefLI = nodeRefListOfSubsections.childNodes[i];");						//get a reference to the LI node
printf("		nodeRefNestedUL = nodeRefLI.getElementsByTagName('ul')[0];");					//get a reference to that LI node's nested UL node (which, again, should be the subsection list - but could be a text-node with the subsection's header text)
printf("		if(typeof nodeRefNestedUL !== 'undefined') {");
printf("			if(nodeRefNestedUL.childNodes.length >= 2 && nodeRefNestedUL.childNodes[1].className.indexOf('messagecell') > -1 ) {");//if the subsection actually contains valid messagecells (first is title, second is either "no messages" or a valid messagecell)
printf("				listNodeID = nodeRefNestedUL.id;");								//get the id of the list node, so we can...
printf("				attachActionListenersToMessageCells(\"ul#\"+listNodeID);");					//handle attaching the necessary action listeners to its message-cells
printf("			}");
printf("		}");
printf("	}");
printf("}\n");//end function attachActionListenersToMessageCells_allSubsectionsInSection()

//NOTE: making this to abstract out common fav-messagecell creation routine... later need to apply to other create-node functions...
/* Generate and return a list-item (LI node object) for the provided message...
 * objMsgData members:
 * 	{
 *	fvRecno: "",	//fav message's record number
 *	fvIcon: "",	//fav icon filename
 *	fvName: "",	//fav name
 *	fvDesc: "",	//fav description
 *	mtRecno: "",	//msg-template recno
 *	mtName: "",	//msg-template name
 *	mtDir: "",	//msg-template's directory
 *	mtDesc: ""	//msg-template description
 * 	} */
printf("function createMessageCellNode(objMsgData, strMsgCellClass){");
printf("	var cfg_requiredMemberNames = ['fvRecno','fvIcon','fvName','fvDesc','mtRecno','mtName','mtDir','mtDesc'];");
printf("	var node_li_messagecell = document.createElement('li');");					//initialize our core, basic node that will compose our messagecell
printf("	var ret = node_li_messagecell;");								//our default return value will be the LI node
printf("	if(typeof objMsgData === 'undefined') {");
printf("		FavScreen.log('error',\"createMessageCellNode(): The 'objMsgData' argument is required. Aborting and returning blank LI node.\",true);");
printf("		return ret;");
printf("	}");
printf("	if(typeof strMsgCellClass === 'undefined') {");
printf("		strMsgCellClass = \"\";");
printf("	}");
/* NOTE: if you want to get this working, then need to figure out why eval is failing (apparently), when it works perfectly when manually ran in the console... error is cannot do length of undefined
printf("	try{");
printf("		var i = errCount = 0;");
printf("		var l = cfg_requiredMemberNames.length;");
printf("		for(i; i<l; i++){");										//investigate the provided object to make sure it contains a valid data structure
printf("			if( eval('objMsgData.' + cfg_requiredMemberNames[i]) === 'undefined') {");
printf("				FavScreen.log('warn',\"createMessageCellNode(): The 'objMsgData' argument's object is missing a required member... '\"+cfg_requiredMemberNames[i]+\"' is undefined.\",true);");
printf("				errCount++;");
printf("			}");
printf("		}");
printf("		if(errCount > 0) {");
printf("			FavScreen.log('error',\"createMessageCellNode(): The 'objMsgData' argument's object has a bad structure... \"+(errCount+1)+\" members are undefined. Aborting and returning blank LI node.\",true);");
printf("			return ret;");
printf("		}");
printf("	}catch(err){");
printf("		FavScreen.log('warn',\"createMessageCellNode(): The 'objMsgData' argument could not be validated (\"+err+\"), but this may be OK if you're sure it is valid. Continuing...\",true);");
printf("	}");
*/
		//initialize all the necessary nodes...
printf("	var node_img_icon = document.createElement('img');");						//create IMG node for the actual icon itself
printf("	var node_div_iconwrapper = document.createElement('div');");					//create DIV node for wrapping the favorite-icon
printf("	var node_div_textwrapper = document.createElement('div');");					//create DIV node for wrapping the favorite-name and favorite-description wrappers
printf("	var node_div_namewrapper = document.createElement('div');");					//create DIV node for wrapping the favorite's name
printf("	var node_div_descwrapper = document.createElement('div');");					//create DIV node for wrapping the favorite's description
printf("	var node_div_actionwrapper = document.createElement('div');");					//create DIV node for wrapping action items (e.g. drag handle icon)
printf("	var node_img_draghandle = document.createElement('img');");					//create IMG node for drag handle icon
printf("	var node_img_toggle = document.createElement('img');");						//create IMG node for toggle icon
printf("	var node_div_clearfloats = document.createElement('div');");					//create DIV node for clearing a messagecell's float
		//construct messagecell...
printf("	node_li_messagecell.id = objMsgData.fvRecno;");
printf("	node_li_messagecell.className = \"messagecell \"+strMsgCellClass;");
printf("	if(FavScreen.get('attrBrowserSupports_dataset')){");				//acquire the message-template recno 
printf("		node_li_messagecell.dataset.msgtemplatename = objMsgData.mtName;");
printf("		node_li_messagecell.dataset.msgtemplaterecno = objMsgData.mtRecno;");
printf("	}else{");
printf("		node_li_messagecell.setAttribute(\"data-msgtemplatename\", objMsgData.mtName);");
printf("		node_li_messagecell.setAttribute(\"data-msgtemplaterecno\", objMsgData.mtRecno);");
printf("	}");
		//construct icon...
printf("	if(objMsgData.fvIcon.length > 0) {");								//if some kind of icon was specified (presumably by the user), then it's probably preferable to show it instead of the default?
printf("		node_img_icon.src = \"%s/icons/32x32/\"+objMsgData.fvIcon+\"\";", cgi_icons);
printf("	}else{");											//else nothing specified, so show the system-default icon
printf("		node_img_icon.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_DEFAULT_UNSORTED_ICON_FILE);
printf("	}");
printf("	node_div_iconwrapper.className = \"iconwrapper\";");
		//construct text areas...
printf("	node_div_textwrapper.className = \"textwrapper\";");
printf("	node_div_namewrapper.className = \"namewrapper\";");
printf("	if(objMsgData.fvName.length>0){");								//if there is a favorite-msg name (there probably won't be for new messages, but just to be safe), show the favorite-message's name
printf("		node_div_namewrapper.innerHTML = objMsgData.fvName;");
printf("	}else{");											//else show the message-template's name
printf("		node_div_namewrapper.innerHTML = objMsgData.mtName;");
printf("	}");
printf("	node_div_descwrapper.className = \"descriptionwrapper\";");
printf("	if(objMsgData.fvDesc.length>0){");								//if there is a favorite-msg description (there probably won't be for new messages, but just to be safe), show it
printf("		node_div_descwrapper.innerHTML = favDescription;");
printf("	}else{");											//else, we won't be showing a description line, so will need to move things around a bit...
printf("		node_div_namewrapper.style.marginTop = \"7px\";");						//since there's no description line, try to vertically center the namewrapper
printf("		node_div_namewrapper.style.fontSize = \"15px\";");						//since there's no description line, try to vertically center the namewrapper
printf("	}");
		//construct action area...
printf("	node_div_actionwrapper.className = \"actionwrapper\";");
printf("	node_div_actionwrapper.style.display = \"none\";");						//by default, first load (presumably launch mode), don't show this... it should show only in edit mode (to re-show, need to loop through all elements with this className and show them)
printf("	node_img_draghandle.id = \"draghandleicon_\"+objMsgData.fvRecno;");				//assign a DOM id to this node, so we can reference it whenever we need
printf("	node_img_draghandle.className = \"affectedbyinteractionmode\";");				//assign a DOM class to this node, flagging it as possibly affected by a change in interaction mode
printf("	node_img_draghandle.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_DRAGHANDLE);		//load the drag handle icon
printf("	node_img_draghandle.display = \"none\";");							//no initial display state (don't want to see this until they explicitly enter edit mode)
printf("	node_img_toggle.id = \"toggleicon_\"+objMsgData.fvRecno;");					//assign a DOM id to this node, so we can reference it whenever we need
printf("	node_img_toggle.className = \"affectedbytoggle\";");						//assign a DOM class to this node, flagging it as possibly affected by the toggle feature
printf("	node_img_toggle.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_TOGGLE_CLOSE);		//load the toggle icon
printf("	node_img_toggle.display = \"none\";");								//no initial display state (don't want to see this until toggle is needed)
		//construct float-clear...
printf("	node_div_clearfloats.className = \"clearfloats\";");
		//assemble the completed messagecell, working from the deepest child, upward
printf("	node_div_iconwrapper.appendChild(node_img_icon);");						//add fav-icon IMG to iconwrapper DIV
printf("	node_div_textwrapper.appendChild(node_div_namewrapper);");					//add namewrapper DIV to textwrapper DIV
printf("	node_div_textwrapper.appendChild(node_div_descwrapper);");					//add descwrapper DIV to textwrapper DIV
printf("	node_div_actionwrapper.appendChild(node_img_draghandle);");					//add the drag handle icon to our actionwrapper node
printf("	node_div_actionwrapper.appendChild(node_img_toggle);");						//add the toggle icon to our actionwrapper node
printf("	node_li_messagecell.appendChild(node_div_actionwrapper);");					//add actionwrapper DIV to messagecell LI (even though this is on the right side, it must go first -- just an odd thing about right-floats to get them actually on the right side)
printf("	node_li_messagecell.appendChild(node_div_iconwrapper);");					//add iconwrapper DIV to messagecell LI
printf("	node_li_messagecell.appendChild(node_div_textwrapper);");					//add textwrapper DIV to messagecell LI
printf("	node_li_messagecell.appendChild(node_div_clearfloats);");					//add the float-clearing DIV to messagecell LI (SHOULD BE AT THE END)
printf("	return ret;");
printf("}\n");//end function createMessageCellNode()

/* Generate and return a list (UL node object) of favorite message cells (LI nodes)...
 * 	objRS			- (required obj) YUI Recordset object containing the records to use
 * 	strListID		- (required str) The DOM id attribute value to give to the UL node that will be returned
 * 	strClassName_list	- (optional str) Any DOM class attribute value(s) to give to the UL node that will be returned
 * 	strClassName_item	- (optional str) Any DOM class attribute value(s) to give to the LI nodes that will be returned as children of the UL */
printf("function createMessageListNode(objRS, strListID, strClassName_list, strClassName_item){");
printf("	if(typeof objRS !== 'object'){");						//if no Recordset object was supplied, log an error and don't allow this function to continue
printf("		FavScreen.log('error', \"Calling createMessageListNode() requires a valid objRS (YUI Recordset) to be specified.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof strListID==='undefined'){");					//if nothing was supplied, log an error and don't allow this function to continue
printf("		FavScreen.log('error', \"Calling createMessageListNode() requires strListID to be specified.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof strClassName_list==='undefined'){");				//if nothing was supplied (because the argument is optional), initialize an empty string
printf("		strClassName_list = \"\";");
printf("	}");
printf("	if(typeof strClassName_item==='undefined'){");				//if nothing was supplied (because the argument is optional), initialize an empty string
printf("		strClassName_item = \"\";");
printf("	}");
printf("	var favRecno;");								//declare a local variable that will store the favorite-message's record number for each iteration, to prevent repeated costly calls to the recordset's getValue method
printf("	var favMsgTemplateRecno;");							//declare a local variable that will store the favorite-message's message-template record number for each iteration, to prevent repeated costly calls to the recordset's getValue method
printf("	var favMsgTemplateName;");							//declare a local variable that will store the favorite-message's message-template name for each iteration, to prevent repeated costly calls to the recordset's getValue method
printf("	var favMsgTemplateDir;");							//declare a local variable that will store the favorite-message's message-template directory for each iteration, to prevent repeated costly calls to the recordset's getValue method
printf("	var favMsgTemplateDesc;");							//declare a local variable that will store the favorite-message's message-template description for each iteration, to prevent repeated costly calls to the recordset's getValue method
//printf("	var favPosition;");								//declare a local variable that will store the favorite-message's position for each iteration, to prevent repeated costly calls to the recordset's getValue method
//printf("	var favPositionType;");								//declare a local variable that will store the favorite-message's position's type flag for each iteration, to prevent repeated costly calls to the recordset's getValue method
//printf("	var favPositionInt1;");								//declare a local variable that will store the favorite-message's position's 1st dimention value for each iteration, to prevent repeated costly calls to the recordset's getValue method
printf("	var favIcon;");									//declare a local variable that will store the favorite-message's icon for each iteration, to prevent repeated costly calls to the recordset's getValue method
//printf("	var favIcon2;");									//declare a local variable that will store the favorite-message's icon for each iteration, to prevent repeated costly calls to the recordset's getValue method
printf("	var favName;");									//declare a local variable that will store the favorite-message's name for each iteration, to prevent repeated costly calls to the recordset's getValue method
printf("	var favDescription;");								//declare a local variable that will store the favorite-message's description for each iteration, to prevent repeated costly calls to the recordset's getValue method
printf("	var i = 0;");
//		VISUAL LAYOUT/STYLING:
//		+-[node_ul_messagelist]---------------------------------------------------------------------------+
//		| +-[node_li_messagecell]-----------------------------------------------------------------------+ |
//		| | +-[node_div_iconwrapper]-+  +-[node_div_textwrapper]--------+  +-[node_div_actionwrapper]-+ | |
//		| | | [node_img_icon]        |  | [node_div_namewrapper]        |  | [node_img_draghandle]    | | |
//		| | +------------------------+  | [node_div_descriptionwrapper] |  | [node_img_toggle]        | | |
//		| |                             |                               |  +--------------------------+ | |
//		| |                             +-------------------------------+                               | |
//		| | [node_div_clearfloats]                                                                      | |
//		| +---------------------------------------------------------------------------------------------+ |
//		+-------------------------------------------------------------------------------------------------+
printf("	var node_ul_messagelist = document.createElement('ul');");			//create a UL node for containing the potential favorites listing (this will be the node that actually gets returned by this function, when complete)
printf("	node_ul_messagelist.id = strListID.toString();");				//assign the ID attribute/value specified by the function argument
printf("	node_ul_messagelist.className = \"messagelist \"+strClassName_list+\"\";");	//assign the CLASS attribute/value(s) specified by the function argument
printf("	for(i; i<objRS.size(); i++){");							//loop through the recordset, creating an LI node (and its unique-per-favorite children), and then adding it to the main UL that this function will return
		      //Get static vars for this favorite-message iteration...
printf("		favRecno		= objRS.item(i).getValue('recno_fav');");		//get the favorite's recno
printf("		favMsgTemplateRecno	= objRS.item(i).getValue('recno_msgtemplate');");	//get the message-template's recno
printf("		favMsgTemplateName	= objRS.item(i).getValue('msgname');");			//get the message-template's message name
printf("		favMsgTemplateDir	= objRS.item(i).getValue('msgdir');");			//get the message-template's message directory
printf("		favMsgTemplateDesc	= objRS.item(i).getValue('msgdesc');");			//get the message-template's message description
//printf("		favPosition		= objRS.item(i).getValue('position');");		//get the favorite's raw position data from the recordset
//printf("		favPositionType		= parsePositionType(favPosition);");			//get the favorite's position type flag (whether sorted, unsorted, deleted, etc.)
//printf("		favPositionInt1		= parsePositionInteger(favPosition,1);");		//get the favorite's 1st-dimension's integer value
printf("		favIcon			= objRS.item(i).getValue('icon');");			//get the favorite's icon filename
//printf("		favIcon2		= objRS.item(i).getValue('icon2');");			//get the favorite's secondary icon filename
printf("		favName			= objRS.item(i).getValue('label1');");			//get the favorite's name
printf("		favDescription		= objRS.item(i).getValue('label2');");			//get the favorite's description
		      //Construct the iconwrapper node and its child that will become this favorite's icon...
printf("		var node_img_icon = document.createElement('img');");				//create the IMG node
//printf("		var node_img_icon2 = document.createElement('img');");				//create the IMG node
printf("		if(favIcon.length>0){");							//if some kind of icon was specified (presumably by the user), then it's probably preferable to show it instead of the default?
printf("		    node_img_icon.src = \"%s/icons/32x32/\"+favIcon+\"\";", cgi_icons);		//show the favorite's icon
printf("		}else{");
printf("		    node_img_icon.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_DEFAULT_UNSORTED_ICON_FILE);//show the system-default icon
printf("		}");
printf("		var node_div_iconwrapper = document.createElement('div');");			//create DIV node for wrapping the favorite-icon
printf("		    node_div_iconwrapper.className = \"iconwrapper\";");			//assign CLASS attribute/value
printf("		    node_div_iconwrapper.appendChild(node_img_icon);");				//add fav-icon IMG to iconwrapper DIV
		      //Construct a DIV node that will contain this favorite's name...
printf("		var node_div_namewrapper = document.createElement('div');");			//create the node
printf("		    node_div_namewrapper.className = \"namewrapper\";");			//assign CLASS attribute/value
printf("		if(favName.length>0){");							//if there is a favorite-msg name (there probably won't be for new messages, but just to be safe)...
printf("		    node_div_namewrapper.innerHTML = favName;");				//show the favorite-msg name
printf("		}else{");
printf("		    node_div_namewrapper.innerHTML = favMsgTemplateName;");			//show the message-template's name
printf("		}");
		      //Construct a DIV node that will contain this favorite's description...
printf("		var node_div_descriptionwrapper = document.createElement('div');");		//create the node
printf("		    node_div_descriptionwrapper.className = \"descriptionwrapper\";");		//assign CLASS attribute/value
printf("		if(favDescription.length>0){");							//if there is a favorite-msg description (there probably won't be for new messages, but just to be safe), show it
printf("		    node_div_descriptionwrapper.innerHTML = favDescription;");
printf("		}");
printf("		else{");
//printf("		    node_div_namewrapper.style.marginTop = \"8px\";");				//since there's no description line, try to vertically center the namewrapper
printf("		    node_div_namewrapper.style.marginTop = \"7px\";");				//since there's no description line, try to vertically center the namewrapper
printf("		    node_div_namewrapper.style.fontSize = \"15px\";");				//since there's no description line, try to vertically center the namewrapper
printf("		}");
		      //Construct a DIV node that contains the fav name and description...
printf("		var node_div_textwrapper = document.createElement('div');");			//create DIV node for wrapping the favorite-name and favorite-description...
printf("		    node_div_textwrapper.className = \"textwrapper\";");			//assign CLASS attribute/value
printf("		    node_div_textwrapper.appendChild(node_div_namewrapper);");			//add namewrapper DIV to textwrapper DIV
printf("		    node_div_textwrapper.appendChild(node_div_descriptionwrapper);");		//add descriptionwrapper DIV to textwrapper DIV
		      //Construct a DIV node that contains action icons (e.g. drag handle), and its children...
printf("		var node_img_draghandle = document.createElement('img');");			//create IMG node for drag handle icon
printf("		    node_img_draghandle.id = \"draghandleicon_\"+favRecno;");			//assign a DOM id to this node, so we can reference it whenever we need
printf("		    node_img_draghandle.className = \"affectedbyinteractionmode\";");		//assign a DOM class to this node, flagging it as possibly affected by a change in interaction mode
printf("		    node_img_draghandle.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_DRAGHANDLE);//load the drag handle icon
printf("		    node_img_draghandle.display = \"none\";");					//no initial display state (don't want to see this until they explicitly enter edit mode)
printf("		var node_img_toggle = document.createElement('img');");				//create IMG node for drag handle icon
printf("		    node_img_toggle.id = \"toggleicon_\"+favRecno;");				//assign a DOM id to this node, so we can reference it whenever we need
printf("		    node_img_toggle.className = \"affectedbytoggle\";");			//assign a DOM class to this node, flagging it as possibly affected by the toggle feature
printf("		    node_img_toggle.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_TOGGLE_CLOSE);//load the toggle icon
printf("		    node_img_toggle.display = \"none\";");					//no initial display state (don't want to see this until toggle is needed)
printf("		var node_div_actionwrapper = document.createElement('div');");			//create DIV node for wrapping action items (e.g. drag handle icon)
printf("		    node_div_actionwrapper.className = \"actionwrapper\";");			//assign CLASS attribute/value
printf("		    node_div_actionwrapper.appendChild(node_img_draghandle);");			//add the drag handle icon to our actionwrapper node
printf("		    node_div_actionwrapper.appendChild(node_img_toggle);");			//add the toggle icon to our actionwrapper node
printf("		    node_div_actionwrapper.style.display = \"none\";");				//by default, first load (presumably launch mode), don't show this... it should show only in edit mode (to re-show, need to loop through all elements with this className and show them)
		      //Construct the clear-floats DIV
printf("		var node_div_clearfloats = document.createElement('div');");			//create DIV node for clearing a messagecell's float...
printf("		    node_div_clearfloats.className = \"clearfloats\";");			//assign CLASS attribute/value
		      //Construct the LI node that will become the messagecell for this favorite-message...
printf("		var node_li_messagecell = document.createElement('li');");			//create the node (this, being the root node for each messagecell, should be overwritten with each iteration... so do createElement assignment inside the loop like this)
printf("		    node_li_messagecell.id = \"\"+favRecno+\"\";");				//assign an ID attribute/value
printf("		    node_li_messagecell.className = \"messagecell \"+strClassName_item+\"\";");	//assign CLASS attribute/values
//printf("		    if(FavScreen.get('attrBrowserSupports_dataset')){");			//assign DATA-* attribute/values (different browsers require different methods)...
//printf("		    node_li_messagecell.dataset.listpositionindex = i+1;");
//printf("		    }else{");
//printf("		    node_li_messagecell.setAttribute(\"data-listpositionindex\", i+1);");
//printf("		    }");
printf("		    node_li_messagecell.appendChild(node_div_actionwrapper);");			//add actionwrapper DIV to messagecell LI (even though this is on the right side, it must go first -- just an odd thing about right-floats)
printf("		    node_li_messagecell.appendChild(node_div_iconwrapper);");			//add iconwrapper DIV to messagecell LI
printf("		    node_li_messagecell.appendChild(node_div_textwrapper);");			//add textwrapper DIV to messagecell LI
printf("		    node_li_messagecell.appendChild(node_div_clearfloats);");			//add the float-clearing DIV to messagecell LI (SHOULD BE AT THE END)
		      //Add the completed messagecell LI to the UL node that gets returned...
printf("		node_ul_messagelist.appendChild(node_li_messagecell);");			//add the fully-built LI (and all its above contents) back into the main UL
printf("	}");//end for
printf("	if(i==0){");									//if we didn't loop any (no favorites exist)... we should make sure our returned UL node has at least one LI child to be completely valid HTML
printf("		var node_li_messagecell = document.createElement('li');");			//create LI node for messagecell (that will contain nothing or some text indicating that to the user)...
printf("		    node_li_messagecell.className = \"nomessages\";");
printf("		    node_li_messagecell.innerHTML = \"%s\";", FAVS_DEFAULT_NOFAVSTODISPLAYHTML);//fill in the default text
printf("		node_ul_messagelist.appendChild(node_li_messagecell);");			//add the LI to the main UL
printf("	}");
printf("	return node_ul_messagelist;");
printf("}\n");//end function createMessageListNode()

printf("function viewMessageByBannerRecno(e){");						// View a message (specified by its banner record number in the DOM id value) -- works similarly as resolving a message for launch (i.e. visually replaces document contents)
printf("	if(FavScreen.get('attrInteractionMode')!=MODE_LAUNCHABLE){");			//if favorites screen is in anything but click-to-launch mode, abort...
printf("		FavScreen.log('info',\"viewMessageByBannerRecno(): Currently not in launchable mode, so this function will abort.\",false);");
printf("		return false;");
printf("	}");
printf("	if(!messageCellActionIsValid(e)) {");
printf("		FavScreen.log('info',\"viewMessageByBannerRecno(): Checking messageCellActionIsValid() returned false, so this function will abort.\",false);");
printf("		return false;");
printf("	}");
printf("	var whereUserClickedX = e.pageX;");
printf("	var actionWrapperLeft = e.currentTarget.getElementsByClassName(\"actionwrapper\")[0].offsetLeft;");
printf("	var cfg_additionalLeftOffset = 15;");						//specify any additional no-click zone to the left of the actionwrapper (reply icon)
printf("	if(whereUserClickedX > (actionWrapperLeft - cfg_additionalLeftOffset)) {");	//if they clicked in the action wrapper area, they probably intended to use one of those actions (e.g. reply icon), so abort
printf("		FavScreen.log('info',\"viewMessageByBannerRecno(): User clicked/tapped in the actionwrapper area. Assuming they don't mean to view this message, and aborting.\",false);");
printf("		return false;");
printf("	}");
printf("	var strRecno = e.currentTarget.id;");							//parse the record number (should be contained in the LI node's ID attribute)
printf("	FavScreen.log('log',\"viewMessageByBannerRecno(): Clicked a message to view it (recno = \"+parseInt(strRecno)+\").\",false);");
printf("	YUI().use(\"io\", \"io-base\", function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("			FavScreen.log('verbose',\"viewMessageByBannerRecno(): YUI-IO Txn ID#\"+ioId+\": Starting txn.\",true);");
printf("		};");
printf("		var handleSuccess = function(ioId, o){");						//what should happen when response HTTP status resolves to 2xx
printf("			FavScreen.log('log',\"viewMessageByBannerRecno(): YUI-IO Txn ID#\"+ioId+\": Txn succeeded.\",true);");
printf("			var rt = o.responseText;");
printf("			if(rt.indexOf(\"This message has already been responded to.\")>-1){");			//note: not defined anywhere, just hard-coded in smcgi.c
printf("				FavScreen.log('log',\"viewMessageByBannerRecno(): Message has already been responded to, nothing to view.\",true);");
printf("				ModalNotification_MessageUnavailable.showFor(2000);");
printf("				refreshRecordset_inboxMsgs(\"%s\",true,false);", CurrentUserPin);			//just take the opportunity to update data on screen
printf("			}");
printf("			else if(rt.indexOf(\"No new messages.\")>-1){");					//note: not defined anywhere, just hard-coded in smcgi.c
printf("				FavScreen.log('log',\"viewMessageByBannerRecno(): No message exists, perhaps it has expired.\",true);");
printf("				ModalNotification_MessageUnavailable.showFor(2000);");
printf("				refreshRecordset_inboxMsgs(\"%s\",true,false);", CurrentUserPin);			//just take the opportunity to update data on screen
printf("			}");
printf("			else if(rt.indexOf(\"thisisinboxmsgview\")>-1){");
if(isLoadedOnMobileDevice()) 															//just using this method to save network traffic, only giving the client what it needs
	{ /* iframe method only... */
	printf("			FavScreen.log('log',\"viewMessageByBannerRecno(): Viewing Message in iframe...\",true);");
	printf("			iframeHandle = replaceDocumentContentsToViewMessage(rt);");
	printf("			var iframeHandle_document = iframeHandle.contentWindow.document || iframeHandle.contentDocument;");
	printf("			if(rt.indexOf(\"SetFormIsLoaded\")>-1 && iframeHandle_document!=false){");		//if this function exists in the html, have the new window call it (since by using this method, the onbodyload event doesn't fire)
	printf("				iframeHandle.contentWindow.setTimeout(\"SetFormIsLoaded()\",1500);");
	printf("				setTimeout(hideNativeSpinner,1500);");							//handle hiding any native spinner that may be showing (function handles platform/version validation)
	printf("			}");
	printf("			overrideIframeWindowMethod_open(\"iframe_toViewMsg\");");
	//printf("			overrideIframeWindowMethod_close(\"iframe_toViewMsg\");"); //NOTE: looks like we can do most of this in smcgi.c with conditional onclicks
	printf("			iframeHandle.onload = function(){ iframeHandle.contentWindow.SetFormIsLoaded(); };");		//assign this in case the iframe's document changes (e.g. they hit 'save' in legacy note field or something)
	}
else
	{ /* try popup method first... if that doesn't work (e.g. blocked or something), fall back to the iframe method */
	printf("			FavScreen.log('log',\"viewMessageByBannerRecno(): Trying to pop open a new window (since in a normal browser) to view the inbox message.\",false);");
	printf("			popupHandle = popupNewWindowForSMCGI_viewMsg(\"SMPersonalPage\", rt);");	//DEV-NOTE: to open resolve-msg in same window on PC, comment this out and it will fall back to iframe method
	printf("			if(typeof popupHandle===\"undefined\" || !popupHandle){");
	printf("				FavScreen.log('info',\"viewMessageByBannerRecno(): Failed to pop open a new window to view the message. Falling back to iframe method.\",false);");
	printf("				iframeHandle = replaceDocumentContentsToViewMessage(rt);");
	printf("				var iframeHandle_document = iframeHandle.contentWindow.document || iframeHandle.contentDocument;");
	printf("				if(rt.indexOf(\"SetFormIsLoaded\")>-1 && iframeHandle_document!=false){iframeHandle.contentWindow.setTimeout(\"SetFormIsLoaded()\",1000);}");//if this function exists in the html, have the new window call it (since by using this method, the onbodyload event doesn't fire)
	printf("				overrideIframeWindowMethod_open(\"iframe_toViewMsg\");");
	//printf("				overrideIframeWindowMethod_close(\"iframe_toViewMsg\");");
	printf("				iframeHandle.onload = function(){ iframeHandle.contentWindow.SetFormIsLoaded(); };");		//assign this in case the iframe's document changes (e.g. they hit 'save' in legacy note field or something)
	printf("			}else{");
	printf("				if(rt.indexOf(\"SetFormIsLoaded\")>-1){popupHandle.setTimeout(\"SetFormIsLoaded()\",1500);}");//if this function exists in the html, have the new window call it (since by using this method, the onbodyload event doesn't fire)
	printf("			}");
	}
printf("			}");
printf("			else{");
printf("				FavScreen.log('warn',\"viewMessageByBannerRecno(): Could not explicitly understand server response. Raw responseText returned by server... (next log entry)\",true);");
printf("				FavScreen.log('verbose', rt, false);");
printf("				ModalNotification_MessageUnavailable.showFor(2000);");
printf("				refreshRecordset_inboxMsgs(\"%s\",true,false);", CurrentUserPin);			//just take the opportunity to update data on screen
printf("			}");
printf("		};");
printf("		var handleFailure = function(ioId, o){");						//what should happen when response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('warn',\"viewMessageByBannerRecno(): YUI-IO Txn ID#\"+ioId+\": Txn failed or timed-out.\",true);");
printf("			FavScreen.log('verbose',\"Txn ID#\"+ioId+\"'s responseText returned by server = '\"+o.responseText+\"'\",true);");
//printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("			return false;");
printf("		};");
printf("		var handleEnd = function(ioId, o){");							//what should happen when YUI-IO transaction is finished
printf("			FavScreen.log('verbose',\"viewMessageByBannerRecno(): YUI-IO Txn ID#\"+ioId+\": Txn has ended.\",true);");
printf("			Spinner.hide();");
printf("		};");
printf("		var cfg ={");										//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");							//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");								//subscribe the above custom end handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
/*
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP(),");
printf("				'form_state':'%d',", STATE_INBOX_MESSAGES);
printf("				'inbox_table_view':'1',");								//
printf("				'button_directory':'1',");								//
printf("				'launch_or_delayed_launch':'LF',");								//
printf("				'inbox_full_view_archive_number':'0',");								//
printf("				'inbox_full_view_recno':strRecno,");								//
printf("				'checkbox_checked_inbox_view':'0',");								//
printf("				'checkbox_checked_inbox_full_view_row_one_recno':strRecno,");								//
printf("				'checkbox_checked_inbox_full_view_row_one_dtsec':FavScreen.get('attrDtsec'),");								//
printf("				'checkbox_checked_clear_checkbox_field':'1'");								//
*/
printf("					'%s':'%s'", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));//send the encoded brtype for authentication
printf("					,'disableCheckForIP_favorites':'%d'", TRUE);				//tell server not to check for IP changes to invalidate session (as, mobile device may necessarily change IP addresses, frequently)
//printf("					'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP(),");
printf("					,'inbox_full_view_archive_number':0");
printf("					,'inbox_full_view_recno':strRecno");
printf("					,'checkbox_checked_inbox_view':0");
printf("					,'checkbox_checked_inbox_full_view_row_one_recno':strRecno");
printf("					,'checkbox_checked_inbox_full_view_row_one_dtsec':FavScreen.get('attrDtsec')");
printf("					,'checkbox_checked_clear_checkbox_field.value':1");
printf("					,'form_state':'%d'", STATE_INBOX_MESSAGES);
printf("					,'page_showlist':0");
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:true,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:10000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("		};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		Spinner.show();");
printf("		setTimeout(function(){");
printf("			objResponse = Y.io(sUrl, cfg);");								//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("			}, 100);");
printf("	});");
printf("}\n");//end function viewMessageByBannerRecno()

/*
printf("function messageReplyViaLegacyWithMessage(e){");					// Reply to a message with the legacy method (in popup or iframe)... this gets called by a message click while in replying mode
printf("	if(FavScreen.get('attrInteractionMode')!=MODE_REPLYING){");				//if favorites screen is in anything but click-to-reply mode, abort...
printf("		FavScreen.log('log',\"messageReplyViaLegacyWithMessage(): Currently not in replying mode, so this function will abort.\",false);");
printf("		return false;");
printf("	}");
printf("	var strRecno = e.currentTarget.id;");							//parse the record number of the reply-w (should be contained in the LI node's ID attribute)
printf("	FavScreen.log('log',\"messageReplyViaLegacyWithMessage(): Clicked a message to view it (recno = \"+parseInt(strRecno)+\").\",false);");
printf("	YUI().use(\"io\", \"io-base\", function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("			FavScreen.log('log',\"messageReplyViaLegacyWithMessage(): YUI-IO Txn ID#\"+ioId+\": Starting txn.\",true);");
printf("		};");
printf("		var handleSuccess = function(ioId, o){");						//what should happen when response HTTP status resolves to 2xx
printf("			FavScreen.log('log',\"messageReplyViaLegacyWithMessage(): YUI-IO Txn ID#\"+ioId+\": Txn succeeded.\",true);");
printf("			var rt = o.responseText;");
printf("			if(rt.indexOf(\"This message has already been responded to.\")>-1){");			//note: not defined anywhere, just hard-coded in smcgi.c
printf("				FavScreen.log('log',\"messageReplyViaLegacyWithMessage(): Message has already been responded to, nothing to view.\",true);");
printf("				ModalNotification_MessageUnavailable.showFor(2000);");
printf("				refreshRecordset_inboxMsgs(\"%s\",true,false);", CurrentUserPin);			//just take the opportunity to update data on screen
printf("			}");
printf("			else if(rt.indexOf(\"No new messages.\")>-1){");					//note: not defined anywhere, just hard-coded in smcgi.c
printf("				FavScreen.log('log',\"messageReplyViaLegacyWithMessage(): No message exists, perhaps it has expired.\",true);");
printf("				ModalNotification_MessageUnavailable.showFor(2000);");
printf("				refreshRecordset_inboxMsgs(\"%s\",true,false);", CurrentUserPin);			//just take the opportunity to update data on screen
printf("			}");
printf("			else if(rt.indexOf(\"thisisinboxmsgview\")>-1){");
if(isLoadedOnMobileDevice()) 															//just using this method to save network traffic, only giving the client what it needs
	{ // iframe method only...
	printf("			FavScreen.log('log',\"messageReplyViaLegacyWithMessage(): Viewing Message in iframe...\",true);");
	printf("			iframeHandle = replaceDocumentContentsToViewMessage(rt);");
	printf("			var iframeHandle_document = iframeHandle.contentWindow.document || iframeHandle.contentDocument;");
	printf("			if(rt.indexOf(\"SetFormIsLoaded\")>-1 && iframeHandle_document!=false){");		//if this function exists in the html, have the new window call it (since by using this method, the onbodyload event doesn't fire)
	printf("				iframeHandle.contentWindow.setTimeout(\"SetFormIsLoaded()\",1500);");
	printf("				setTimeout(hideNativeSpinner,1500);");							//handle hiding any native spinner that may be showing (function handles platform/version validation)
	printf("			}");
	printf("			overrideIframeWindowMethod_open(\"iframe_toViewMsg\");");
	//printf("			overrideIframeWindowMethod_close(\"iframe_toViewMsg\");"); //NOTE: looks like we can do most of this in smcgi.c with conditional onclicks
	printf("			iframeHandle.onload = function(){ iframeHandle.contentWindow.SetFormIsLoaded(); };");		//assign this in case the iframe's document changes (e.g. they hit 'save' in legacy note field or something)
	}
else
	{ // try popup method first... if that doesn't work (e.g. blocked or something), fall back to the iframe method
	printf("			FavScreen.log('log',\"messageReplyViaLegacyWithMessage(): Trying to pop open a new window (since in a normal browser) to view the inbox message.\",false);");
	printf("			popupHandle = popupNewWindowForSMCGI_viewMsg(\"SMPersonalPage\", rt);");	//DEV-NOTE: to open resolve-msg in same window on PC, comment this out and it will fall back to iframe method
	printf("			if(typeof popupHandle===\"undefined\" || !popupHandle){");
	printf("				FavScreen.log('info',\"messageReplyViaLegacyWithMessage(): Failed to pop open a new window to view the message. Falling back to iframe method.\",false);");
	printf("				iframeHandle = replaceDocumentContentsToViewMessage(rt);");
	printf("				var iframeHandle_document = iframeHandle.contentWindow.document || iframeHandle.contentDocument;");
	printf("				if(rt.indexOf(\"SetFormIsLoaded\")>-1 && iframeHandle_document!=false){iframeHandle.contentWindow.setTimeout(\"SetFormIsLoaded()\",1000);}");//if this function exists in the html, have the new window call it (since by using this method, the onbodyload event doesn't fire)
	printf("				overrideIframeWindowMethod_open(\"iframe_toViewMsg\");");
	//printf("				overrideIframeWindowMethod_close(\"iframe_toViewMsg\");");
	printf("				iframeHandle.onload = function(){ iframeHandle.contentWindow.SetFormIsLoaded(); };");		//assign this in case the iframe's document changes (e.g. they hit 'save' in legacy note field or something)
	printf("			}else{");
	printf("				if(rt.indexOf(\"SetFormIsLoaded\")>-1){popupHandle.setTimeout(\"SetFormIsLoaded()\",1500);}");//if this function exists in the html, have the new window call it (since by using this method, the onbodyload event doesn't fire)
	printf("			}");
	}
printf("			}");
printf("			else{");
printf("				FavScreen.log('warn',\"messageReplyViaLegacyWithMessage(): Could not explicitly understand server response. Raw responseText returned by server... (next log entry)\",true);");
printf("				FavScreen.log('info', rt, false);");
printf("				ModalNotification_MessageUnavailable.showFor(2000);");
printf("				refreshRecordset_inboxMsgs(\"%s\",true,false);", CurrentUserPin);			//just take the opportunity to update data on screen
printf("			}");
printf("		};");
printf("		var handleFailure = function(ioId, o){");						//what should happen when response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('warn',\"messageReplyViaLegacyWithMessage(): YUI-IO Txn ID#\"+ioId+\": Txn failed or timed-out.\",true);");
printf("			FavScreen.log('log',\"Txn ID#\"+ioId+\"'s responseText returned by server = '\"+o.responseText+\"'\",true);");
//printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("			return false;");
printf("		};");
printf("		var handleEnd = function(ioId, o){");							//what should happen when YUI-IO transaction is finished
printf("			FavScreen.log('log',\"messageReplyViaLegacyWithMessage(): YUI-IO Txn ID#\"+ioId+\": Txn has ended.\",true);");
printf("		};");
printf("		var cfg ={");										//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");							//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");								//subscribe the above custom end handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
printf("					'%s':'%s'", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));//send the encoded brtype for authentication
printf("					,'disableCheckForIP_favorites':'%d'", TRUE);				//tell server not to check for IP changes to invalidate session (as, mobile device may necessarily change IP addresses, frequently)
//printf("					'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP(),");
printf("					,'inbox_full_view_archive_number':0");
printf("					,'inbox_full_view_recno':strRecno");
printf("					,'checkbox_checked_inbox_view':0");
printf("					,'checkbox_checked_inbox_full_view_row_one_recno':strRecno");
printf("					,'checkbox_checked_inbox_full_view_row_one_dtsec':FavScreen.get('attrDtsec')");
printf("					,'checkbox_checked_clear_checkbox_field.value':1");
printf("					,'form_state':'%d'", STATE_INBOX_MESSAGES);
printf("					,'page_showlist':0");
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:true,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:10000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("		};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");								//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("	});");
printf("	");
printf("}\n");//end function messageReplyViaLegacyWithMessage()
*/

printf("function encodeResponseRules(objMsgData) {");
printf("	try{");
			//Rule #1: Can reply using any message
printf("		if((objMsgData.replyToAltReplyDirName.toString().trim().length==0) && (objMsgData.replyToReplyMsgName.toString().trim().length==0)){");		//If alt-reply-dir is blank AND reply-msg-name is blank, then continue with allowing them to reply using any message
printf("			FavScreen.log('log',\"encodeResponseRules(): Inbox msg's template has no reply or alt-reply messages defined, so allowing response using any message...\",true);");
printf("			return ENCODED_RESPONSE_RULE_1;");
			//Rule #2: Presented with the legacy window in iframe (ultimately, also just launch if that is fully-resolved)... also exit reply-mode if they cancel or finish legacy
printf("		}else if((objMsgData.replyToAltReplyDirName.toString().trim().length==0) && (objMsgData.replyToReplyMsgName.toString().trim().length>0)){");	//If alt-reply-dir is blank AND reply-msg-name is specified, then they need to be presented with the legacy window in the iframe (if unresolve) or just allow reply to continue if resolved
printf("			FavScreen.log('log',\"encodeResponseRules(): Inbox msg's template has no alt-reply-directory defined, but reply-msg-name is defined ('\"+objMsgData.replyToReplyMsgName+\"'), so loading legacy reply window in iframe...\",true);");
printf("			return ENCODED_RESPONSE_RULE_2;");
			//Rule #3: Presented with the legacy window in iframe (ultimately, also just launch if that is fully-resolved)... also allow reply using any message if they cancel legacy (which is probably why we needed to save it as a global attribute)
printf("		}else if((objMsgData.replyToAltReplyDirName.toString().trim().length>0) && (objMsgData.replyToReplyMsgName.toString().trim().length>0)){");	//If alt-reply-dir is specified AND reply-msg-name is specified, then they need to be presented with the legacy window in the iframe (but jump back to standard replies if they cancel that ~ allow respond with any message though)
printf("			FavScreen.log('log',\"encodeResponseRules(): Inbox msg's template has an alt-reply-directory defined ('\"+objMsgData.replyToAltReplyDirName+\"'), and reply-msg-name is defined ('\"+objMsgData.replyToReplyMsgName+\"'), so loading legacy reply window in iframe, but allowing cancel back to standard replies...\",true);");
printf("			return ENCODED_RESPONSE_RULE_3;");
			//Rule #4: Can reply using any message (same as #1)
printf("		}else if((objMsgData.replyToAltReplyDirName.toString().trim().length>0) && (objMsgData.replyToReplyMsgName.toString().trim().length==0)){");	//If alt-reply-dir is specified AND reply-msg-name is blank, then just ignore the alt-reply-dir
printf("			FavScreen.log('log',\"encodeResponseRules(): Inbox msg's template has an alt-reply-directory defined ('\"+objMsgData.replyToAltReplyDirName+\"'), but reply-msg-name is blank. This is an invalid definition, so just allowing them to reply with any.\",true);");
printf("			return ENCODED_RESPONSE_RULE_4;");
printf("		}else{");	//unexpected condition
printf("			FavScreen.log('warn',\"encodeResponseRules(): Unexpected condition (alt-reply-dir='\"+objMsgData.replyToAltReplyDirName+\"', reply-msg-name='\"+objMsgData.replyToReplyMsgName+\"'). Returning '\"+ENCODED_RESPONSE_RULE_1+\"'.\",true);");
printf("			return ENCODED_RESPONSE_RULE_1;");
printf("		}");
printf("	}catch(err){");
printf("		FavScreen.log('warn',\"encodeResponseRules(): Caught: '\"+err.message+\"' (alt-reply-dir='\"+objMsgData.replyToAltReplyDirName+\"', reply-msg-name='\"+objMsgData.replyToReplyMsgName+\"'). Returning '\"+ENCODED_RESPONSE_RULE_1+\"'.\",true);");
printf("		return ENCODED_RESPONSE_RULE_1;");
printf("	}");
printf("}");

//Take care of entering reply mode and allowing the user to select a reply to a particular message (or automatically reply with any pre-defined msgs, if that's the case)
// Note: The 'e' argument is the click event that naturally gets passed when this function is fired by a click event listener.
// 	 This is intended to be called by a click on an inbox-item's reply icon.
// Handling reply properly:
// 	Needs to figure out what kind of reply rules exist (as defined by the template's reply/alt fields ~ which may be encoded into event target somehow?)
// 	- If alt-reply-dir is blank AND reply-msg-name is blank, then continue with allowing them to reply using any message
//	- If alt-reply-dir is blank AND reply-msg-name is specified, then they need to be presented with the legacy window in the iframe (if unresolve) or just allow reply to continue if resolved
//	- If alt-reply-dir is specified AND reply-msg-name is specified, then they need to be presented with the legacy window in the iframe (but jump back to standard replies if they cancel that)
//	- If alt-reply-dir is specified AND reply-msg-name is blank, then just ignore the alt-reply-dir
printf("function respondToMessageByBannerRecno(e) {");
printf("	FavScreen.log('verbose',\"respondToMessageByBannerRecno(): Called.\",true);");
printf("	Spinner.show();");
//printf("	Spinner.showAfterDelay(500);");
printf("	var strRecno, strLaunchPin;");
printf("	var libPin = \"%s\";", FAVS_LIB_USER_STDREPLIES_PIN);
printf("	if(typeof e === 'object') {");						//if we have an object (should be an event object), then this function should be acting as an event handler, so get the target's data
printf("		e.stopImmediatePropagation();");					//prevent any other event handlers from firing (e.g. view message)
printf("		var node_clicked = e.target;");						//get a reference to the event that called this function (NOTE: should/must be the reply icon in the inbox messagecell)
printf("		var node_messagecell = node_clicked.parentNode.parentNode;");		//get a reference to the messagecell of the icon-clicked's event
printf("		strRecno = node_messagecell.id;");					//parse the banner recno of the message they're replying to (NOTE: for this parent cascade to refer to the right thing, the event must have been from a click on the reply icon in the inbox messagecell)
printf("		if(FavScreen.get('attrBrowserSupports_dataset')){");			//acquire the inbox msg's from-pin (so we can use it to tell smcgi who to auto-addr to when the reply is sent)
printf("			strLaunchPin = node_messagecell.dataset.launchpin;");
printf("		}else{");
printf("			strLaunchPin = node_messagecell.getAttribute(\"data-launchpin\");");
printf("		}");
printf("	}else{");								//else an object was NOT passed to this function (meaning this function was called outside of event's listener)
printf("		FavScreen.log('error',\"respondToMessageByBannerRecno(): Apparently not called by an event listener, so cannot determine record number from event's target. Aborting.\",true);");
printf("		Spinner.hide(FAVS_SPINNER_DELAY_HIDE);");
printf("		return false;");
printf("	}");
printf("	FavScreen.log('log',\"respondToMessageByBannerRecno(): Banner recno determined to be \"+strRecno,true);");
printf("	FavScreen.set(\"attrInteractionMode\", MODE_REPLYING);");		//set the app to reply mode
		//NOTE: after mode-change (which fires attachListenersForResponding), each msg gets instructions to create the objMsgData_replyWith data object
printf("	var objMsgData = {");							//create an object to contain data about the message we're replying to
printf("		replyToBannRecno: strRecno");
printf("		,replyToLaunchPin: strLaunchPin");//note: this is what we will use to pass who it goes to, in auto_addr case???
//printf("		,replyToBackgroundColor: ''");//DEV-NOTE: figure out how to get around style.backgroundColor not populating here
printf("		,replyToFromText: node_messagecell.getElementsByClassName('fromwrapper')[0].textContent || node_messagecell.getElementsByClassName('fromwrapper')[0].innerHTML");
printf("		,replyToMsgText: node_messagecell.getElementsByClassName('msgwrapper')[0].textContent || node_messagecell.getElementsByClassName('fromwrapper')[0].innerHTML");
printf("		,replyToTemplateDirName: rsRec_getMsgTemplateDir_inbox(FavScreen.rsInbox, strRecno)");
printf("		,replyToTemplateMsgName: rsRec_getMsgTemplateName_inbox(FavScreen.rsInbox, strRecno)");
printf("		,replyToReplyDirName: rsRec_getMsgTemplateReplyDirName(FavScreen.rsInbox, strRecno)");
printf("		,replyToReplyMsgName: rsRec_getMsgTemplateReplyMsgName(FavScreen.rsInbox, strRecno)");
printf("		,replyToAltReplyDirName: rsRec_getMsgTemplateAltReplyDirName(FavScreen.rsInbox, strRecno)");
printf("		};");
printf("	FavScreen.objMsgData_replyTo = objMsgData;");				//save the data object in the global scope
printf("	var currResponseRule = encodeResponseRules(objMsgData);");		//determine which rule to follow for this responding to this message (as defined by its template's reply-fields)
printf("	FavScreen.set('attrCurrentResponseRule', currResponseRule);");		//save a global for the response rule (this should also serve to re-initialize it, so we shouldn't need to deal with that (as long as here is the only place we use it)
		//Rule #1: Can reply using any message
		//Rule #2: Presented with the legacy window in iframe (ultimately, also just launch if that is fully-resolved)... also exit reply-mode if they cancel or finish legacy
		//Rule #3: Presented with the legacy window in iframe (ultimately, also just launch if that is fully-resolved)... also allow reply using any message if they cancel legacy (which is probably why we needed to save it as a global attribute)
		//Rule #4: Can reply using any message (same as #1)
printf("	switch(currResponseRule) {");
printf("		case ENCODED_RESPONSE_RULE_1:");
printf("		case ENCODED_RESPONSE_RULE_4:");
printf("			FavScreen.log('log', \"respondToMessageByBannerRecno(): User should be allowed to respond, using any msg (currResponseRule = '\"+currResponseRule+\"').\", true);");
printf("			jumpScrollTo(\"libraryAnchor_\"+libPin.trim(), false, false);");	//for convenience, take them to the std-replies section so they can choose a message to reply with (they can, of course, scroll to any other section and respond using any message)
printf("			break;");
printf("		case ENCODED_RESPONSE_RULE_2:");
printf("			FavScreen.log('log', \"respondToMessageByBannerRecno(): User should be presented with the pre-defined reply msg, loaded in a legacy iframe (currResponseRule = '\"+currResponseRule+\"').\", true);");
//zzz POPULATE replyWith?
printf("			launchFavorite(strRecno);");
printf("			break;");
printf("		case ENCODED_RESPONSE_RULE_3:");
printf("			FavScreen.log('log', \"respondToMessageByBannerRecno(): User should be presented with the pre-defined reply msg, loaded in a legacy iframe, but be allowed to cancel that and then respond, using any msg (currResponseRule = '\"+currResponseRule+\"').\", true);");
printf("			launchFavorite(strRecno);");
printf("			break;");
printf("		default:");
printf("			FavScreen.log('warn', \"respondToMessageByBannerRecno(): Switch-case not understood (currResponseRule = '\"+currResponseRule+\"').\", true);");
printf("			break;");
printf("	}");
printf("	Spinner.hide(FAVS_SPINNER_DELAY_HIDE);");
//printf("	var libPin = \"%s\";", FAVS_LIB_USER_STDREPLIES_PIN);
//printf("	jumpScrollTo(\"libraryAnchor_\"+libPin.trim());");			//take them to the reply section so they can choose a message to reply with
printf("}\n");//end function respondToMessageByBannerRecno()

/* Generate and return a list (UL node object) of inbox message cells (LI nodes)...
 * 	objRS			- (required obj) YUI Recordset object containing the records to use
 * 	strListID		- (required str) The DOM id attribute value to give to the UL node that will be returned
 * 	strClassName_list	- (optional str) Any DOM class attribute value(s) to give to the UL node that will be returned
 * 	strClassName_item	- (optional str) Any DOM class attribute value(s) to give to the LI nodes that will be returned as children of the UL */
printf("var PRELOADED_REPLY_ICON = new Image();");
printf("var PRELOADED_SPINNER_ICON = new Image();");
printf("PRELOADED_REPLY_ICON.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_REPLY);	//load the proper reply icon
printf("PRELOADED_SPINNER_ICON.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_MINI_SPINNER);	//load the mini-spinner icon
printf("function createMessageListNode_inboxMsgs(objRS, strListID, strClassName_list, strClassName_item){");
printf("	if(typeof objRS !== 'object'){");					//if no Recordset object was supplied, log an error and don't allow this function to continue
printf("		FavScreen.log('error', \"createMessageListNode_inboxMsgs(): A valid objRS (YUI Recordset) needs to be specified. Aborting.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof strListID==='undefined'){");					//if nothing was supplied, log an error and don't allow this function to continue
printf("		FavScreen.log('error', \"createMessageListNode_inboxMsgs(): strListID must be specified. Aborting.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof strClassName_list==='undefined'){");				//if nothing was supplied (because the argument is optional), initialize an empty string
printf("		strClassName_list = \"\";");
printf("	}");
printf("	if(typeof strClassName_item==='undefined'){");				//if nothing was supplied (because the argument is optional), initialize an empty string
printf("		strClassName_item = \"\";");
printf("	}");
//printf("	var nonGraphicalBullet = '&#x25cf;';");
printf("	var nonGraphicalBullet = false;");
printf("	var i = 0;");
printf("	var currentUserPin = \"%s\";", CurrentUserPin);
printf("	var inMsgRecno;");							//declare a local variable that will store the inbox-message's ZX record number for each iteration, to prevent repeated costly calls to the recordset's getValue method
printf("	var inMsgTemplateRecno;");						//declare a local variable that will store the inbox-message's message-template-recno for each iteration
printf("	var inMsgFavIcon;");							//declare a local variable that may store the inbox-message's corresponding favorite icon (if applicable)
printf("	var inMsgFromPin;");							//declare a local variable that will store the inbox-message's from-user-pin data for each iteration
printf("	var inMsgFromFullName;");						//declare a local variable that will store the inbox-message's from-user-fullname data for each iteration
printf("	var inMsgMessage;");							//declare a local variable that will store the inbox-message's actual message text for each iteration
//printf("	var inMsgMessageTruncated;");						//declare a local variable that will store the inbox-message's actual message text (albeit, truncated) for each iteration
//printf("	var cfg_msgTruncatedLength = 15;");					//specify the length of the truncated version of the message text
printf("	var inMsgSendersNote;");
//printf("	var inMsgSendersNoteTruncated;");
//printf("	var cfg_inMsgSendersNoteTruncatedLength = 15;");			//specify the length of the truncated version of the message text
//		VISUAL LAYOUT/STYLING:
//		+-[node_ul_messagelist]---------------------------------------------------------------------------+
//		| +-[node_li_messagecell]-----------------------------------------------------------------------+ |
//		| | +-[node_div_iconwrapper]-+  +-[node_div_textwrapper]--------+  +-[node_div_actionwrapper]-+ | |
//		| | | [node_img_icon]        |  | [node_div_namewrapper]        |  | [node_img_draghandle]    | | |
//		| | +------------------------+  | [node_div_descriptionwrapper] |  | [node_img_toggle]        | | |
//		| |                             |                               |  +--------------------------+ | |
//		| |                             +-------------------------------+                               | |
//		| | [node_div_clearfloats]                                                                      | |
//		| +---------------------------------------------------------------------------------------------+ |
//		+-------------------------------------------------------------------------------------------------+
printf("	var node_ul_messagelist = document.createElement('ul');");			//create a UL node for containing the potential inbox messages listing (this will be the node that actually gets returned by this function, when complete)
printf("	node_ul_messagelist.id = strListID.toString();");				//assign the ID attribute/value specified by the function argument
printf("	node_ul_messagelist.className = \"messagelist \"+strClassName_list+\"\";");	//assign the CLASS attribute/value(s) specified by the function argument
		//create the subheader title cell...
printf("	var node_li_messagecell = document.createElement('li');");			//create the node (this, being the root node for each messagecell, should be overwritten with each iteration... so do createElement assignment inside the loop like this)
printf("	    node_li_messagecell.id = \"\";");						//assign an ID attribute/value
printf("	    node_li_messagecell.className = \"messagecell sublistheader roundedtopcorners8\";");//assign CLASS attribute/values
printf("	    node_li_messagecell.innerHTML = \"%s\";", FAVS_SECTION_TITLE_INBOX);	//give the InBox section its title text
printf("	var node_img_refresh = document.createElement('img');");
printf("	    node_img_refresh.className = \"headericon\";");				//assign CLASS attribute/value
printf("	    node_img_refresh.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_REFRESH);
//printf("	    node_img_refresh.addEventListener('click', refreshRecordset_inboxMsgs, false);");	//DEV-NOTE: this seems to add an extra click (to focus??) before actually working, on iOS at least
printf("	    node_img_refresh.onclick = refreshRecordset_inboxMsgs;");
printf("	var node_img_minmax = document.createElement('img');");
printf("	    node_img_minmax.className = \"headericon minmax\";");			//assign CLASS attribute/value
printf("	    node_img_minmax.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_MINIMIZE);//initialize with minimize icon (since section starts out maximized
//printf("	    node_img_minmax.addEventListener('click', toggleExpandCollapse_contentWrapper, false);");	//DEV-NOTE: this seems to add an extra click (to focus??) before actually working, on iOS at least
printf("	    node_img_minmax.onclick = toggleExpandCollapse_contentWrapper;");
printf("	var node_div_clearfloats = document.createElement('div');");			//create DIV node for clearing any float...
printf("	    node_div_clearfloats.className = \"clearfloats\";");			//assign CLASS attribute/value
printf("	node_li_messagecell.appendChild(node_img_refresh);");
printf("	node_li_messagecell.appendChild(node_img_minmax);");
printf("	node_li_messagecell.appendChild(node_div_clearfloats);");
printf("	node_ul_messagelist.appendChild(node_li_messagecell);");			//add the fully-built LI (and all its above contents) back into the main UL
printf("	if(checkSetIntegSec()) {");							//if integrity is broken, fall back to display no-msgs
printf("		var node_li_messagecell = document.createElement('li');");			//create LI node for messagecell (that will contain nothing or some text indicating that to the user)...
printf("	    	    node_li_messagecell.id = \"\";");						//assign an ID attribute/value
printf("	    	    node_li_messagecell.className = \"messagecell nomessages\";");		//assign CLASS attribute/values
printf("		    node_li_messagecell.innerHTML = \"%s\";", FAVS_DEFAULT_NOFAVSTODISPLAYHTML);//fill in the default text
printf("		node_ul_messagelist.appendChild(node_li_messagecell);");			//add the LI to the main UL
printf("	}");
printf("	else {");
		//generate the dynamic messagecells...
printf("	for(i; i<objRS.size(); i++){");							//loop through the recordset, creating an LI node (and its unique-per-msg children), and then adding it to the main UL that this function will return
		      //Get static vars for this inbox-message iteration...
printf("		inMsgRecno		= objRS.item(i).getValue('recno_inbox');");		//get the message's ZX recno
printf("		inMsgTemplateRecno	= objRS.item(i).getValue('recno_msgtemplate');");	//get the message's message-template-recno
printf("		inMsgFromPin		= objRS.item(i).getValue('from_pin');");		//get the message's from-user-pin (note: this is populated by the server with launch_pin)
printf("		inMsgFromFullName	= objRS.item(i).getValue('from_fullname');");		//get the message's from-user-fullname
printf("		inMsgMessage		= objRS.item(i).getValue('message');");			//get the message's actual message-text
//printf("		inMsgMessageTruncated 	= inMsgMessage.substr(0,cfg_msgTruncatedLength);");	//create a truncated version of the message-text (pretty much just for logging purposes - at least in the beginning of development)
//printf("		FavScreen.log('log',\"createMessageListNode_inboxMsgs(): Constructing node LI#\"+inMsgRecno+\" (From '\"+inMsgFromFullName+\"': '\"+inMsgMessageTruncated+\"...')...\",false);");
printf("		FavScreen.log('log',\"createMessageListNode_inboxMsgs(): Constructing node LI#\"+inMsgRecno+\" (From '\"+inMsgFromFullName+\"')...\",false);");
printf("		inMsgSendersNote	= objRS.item(i).getValue('senders_note');");		//get the message's sender's note text (there may or may not be any)
		      //Conditionally construct the iconwrapper node and its child that might become this active-message's favorites icon (if launched by this favs user)...
printf("		if(inMsgFromPin == \"%s\"){", CurrentUserPin);
//printf("			FavScreen.log('log',\"createMessageListNode_inboxMsgs():  Msg ('\"+inMsgMessageTruncated+\"...') from self (inMsgFromPin='\"+inMsgFromPin+\"', CurrentUserPin='%s'). Checking if this msg has an entry/icon in their favs list...\",false);", CurrentUserPin);
printf("			inMsgFavIcon = rsRec_getFavIcon_byMsgTemplateRecno(FavScreen.rsOrig, inMsgTemplateRecno);");//figure out whether there's a corresponding fav-icon for this inbox message, using its msg-template-recno
printf("			if(inMsgFavIcon == false || inMsgFavIcon.toString().length < 4){");		//if we determined that there is no associated fav-icon (or it's invalid)...
printf("				FavScreen.log('verbose','createMessageListNode_inboxMsgs():   From self & no fav-icon ('+inMsgFavIcon+') for inbox-msg-recno '+inMsgRecno+' w/msg-template-recno '+inMsgTemplateRecno+' for this user. Showing default icon.',false);");//no need to render an iconwrapper node (in fact, the CSS depends on one not existing, to align the following textwrapper node correctly)
printf("				if(Boolean(nonGraphicalBullet)) {");
printf("				    var node_span_bullet = document.createElement('span');");
printf("				    node_span_bullet.innerHTML = '&#x25cf;';");
printf("				    node_span_bullet.className = \"bigblackbullet\";");
printf("				    }");
printf("				var node_img_icon = document.createElement('img');");				//create the IMG node
printf("				    node_img_icon.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_DEFAULT_UNSORTED_ICON_FILE);//show the system-default icon
printf("				var node_div_iconwrapper = document.createElement('div');");			//create DIV node for wrapping the favorite-icon
printf("				    node_div_iconwrapper.className = \"iconwrapper\";");			//assign CLASS attribute/value
printf("				  if(Boolean(nonGraphicalBullet)) {");
printf("				    node_div_iconwrapper.appendChild(node_span_bullet);");			//add fav-icon IMG to iconwrapper DIV
printf("				  }");
printf("				    node_div_iconwrapper.appendChild(node_img_icon);");				//add fav-icon IMG to iconwrapper DIV
printf("			}else{");									//else there appears to be an associated fav-icon, so render it for this inbox message...
printf("				FavScreen.log('verbose','createMessageListNode_inboxMsgs():   From self & fav-icon exists ('+inMsgFavIcon+') for inbox-msg-recno#'+inMsgRecno+' w/msg-template-recno#'+inMsgTemplateRecno+' for this user.',false);");
printf("				var node_img_icon = document.createElement('img');");				//create the IMG node
printf("				if(inMsgFavIcon.length>3){");							//if some kind of icon was specified (presumably by the user), then it's probably preferable to show it instead of the default?
printf("				    node_img_icon.src = \"%s/icons/32x32/\"+inMsgFavIcon+\"\";", cgi_icons);		//show the favorite's icon
printf("				}else{");
printf("				    node_img_icon.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_DEFAULT_UNSORTED_ICON_FILE);//show the system-default icon
printf("				}");
printf("				var node_div_iconwrapper = document.createElement('div');");			//create DIV node for wrapping the favorite-icon
printf("				    node_div_iconwrapper.className = \"iconwrapper\";");			//assign CLASS attribute/value
printf("				    node_div_iconwrapper.appendChild(node_img_icon);");				//add fav-icon IMG to iconwrapper DIV
printf("			}");
				//also, in this case, it's possible that this inbox msg was launched from a favorite on this client - so need to define a proper closeMessage command for the icon's action if so
//printf("			rsRec_getFavRecno_byMsgTemplateRecno(FavScreen.rsOrig, inMsgTemplateRecno);");
//printf("			");
printf("		}else{");
//printf("			FavScreen.log('log','createMessageListNode_inboxMsgs():  No need to check-for a defined icon, since message is from another user ('+inMsgFromPin+'). Showing default icon.',false);");//no need to render an iconwrapper node (in fact, the CSS depends on one not existing, to align the following textwrapper node correctly)
printf("			inMsgFavIcon = rsRec_getFavIcon_byMsgTemplateRecno(FavScreen.rsOrig, inMsgTemplateRecno);");//figure out whether there's a corresponding fav-icon for this inbox message, using its msg-template-recno
printf("			if(inMsgFavIcon === undefined || Boolean(inMsgFavIcon) == false){");
printf("				if(Boolean(nonGraphicalBullet)) {");
printf("				    var node_span_bullet = document.createElement('span');");
printf("				    node_span_bullet.innerHTML = '&#x25cf;';");
printf("				    node_span_bullet.className = \"bigblackbullet\";");
printf("				    }");
printf("				var node_img_icon = document.createElement('img');");				//create the IMG node
printf("				    node_img_icon.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_DEFAULT_UNSORTED_ICON_FILE);//show the system-default icon
printf("				var node_div_iconwrapper = document.createElement('div');");			//create DIV node for wrapping the favorite-icon
printf("				    node_div_iconwrapper.className = \"iconwrapper\";");			//assign CLASS attribute/value
printf("				  if(Boolean(nonGraphicalBullet)) {");
printf("				    node_div_iconwrapper.appendChild(node_span_bullet);");			//add fav-icon IMG to iconwrapper DIV
printf("				  }");
printf("				    node_div_iconwrapper.appendChild(node_img_icon);");				//add fav-icon IMG to iconwrapper DIV
printf("			}else{");									//else there appears to be no associated fav-icon, so render default icon for this inbox message...
printf("				FavScreen.log('verbose','createMessageListNode_inboxMsgs():   From another user & fav-icon exists ('+inMsgFavIcon+') for inbox-msg-recno#'+inMsgRecno+' w/msg-template-recno#'+inMsgTemplateRecno+'.',false);");
printf("				var node_img_icon = document.createElement('img');");				//create the IMG node
printf("				    node_img_icon.src = \"%s/icons/32x32/\"+inMsgFavIcon+\"\";", cgi_icons);		//show the favorite's icon
printf("				var node_div_iconwrapper = document.createElement('div');");			//create DIV node for wrapping the favorite-icon
printf("				    node_div_iconwrapper.className = \"iconwrapper\";");			//assign CLASS attribute/value
printf("				    node_div_iconwrapper.appendChild(node_img_icon);");				//add fav-icon IMG to iconwrapper DIV
printf("			}");
printf("		}");
printf("		node_div_iconwrapper.onclick = function(e) {");
printf("			closeMessage(e.currentTarget.parentNode.id);");							//the closeMessage routine will take care of handling after-close stuff (like toggle icon cleanup), on its own... perhaps using this LI's data attributes
printf("			e.stopImmediatePropagation();");								//be extra safe and prevent any other event handlers from firing (e.g. launch/view message)
printf("			e.stopPropagation();");										//be extra safe and prevent any other event handlers from firing (e.g. launch/view message)
printf("			e.preventDefault();");										//be extra safe and prevent any other event handlers from firing (e.g. launch/view message)
printf("			};");
		      //Construct a DIV node that will contain this message's "from"...
//printf("		var fromText_pre = \"<span style='font-weight:bold;'>From: </span>\";");
printf("		var fromText_pre = \"\";");
printf("		if(inMsgFromPin == \"%s\"){", CurrentUserPin);
printf("			var fromText_body = \"Me\";");
printf("		}else{");
printf("			var fromText_body = inMsgFromFullName;");
printf("		}");
printf("		var node_div_fromwrapper = document.createElement('div');");			//create the node
printf("		    node_div_fromwrapper.className = \"fromwrapper\";");			//assign CLASS attribute/value
printf("		    node_div_fromwrapper.innerHTML = fromText_pre + fromText_body;");		//populate the HTML content of the node with the full name of who the inbox message is from
		      //Construct a DIV node that will contain this message's "message-text"...
printf("		var node_div_msgwrapper = document.createElement('div');");			//create the node
printf("		    node_div_msgwrapper.className = \"msgwrapper\";");				//assign CLASS attribute/value
printf("		    node_div_msgwrapper.innerHTML = inMsgMessage;");				//populate the HTML content of the node with the actual text of the inbox-message
		      //Construct a DIV node that may contain this message's "senders-note"...
printf("		var node_div_snotewrapper = document.createElement('div');");			//create the node
printf("		    node_div_snotewrapper.className = \"notewrapper\";");			//assign CLASS attribute/value
printf("		    node_div_snotewrapper.innerHTML = inMsgSendersNote;");			//populate the HTML content of the node with the actual text of the inbox-message
		      //Construct a DIV node that contains the from and message-text nodes...
printf("		var node_div_textwrapper = document.createElement('div');");			//create DIV node for wrapping the from text and message text...
printf("		    node_div_textwrapper.className = \"textwrapper\";");			//assign CLASS attribute/value
printf("		    node_div_textwrapper.appendChild(node_div_fromwrapper);");			//add fromwrapper DIV to textwrapper DIV
printf("		    node_div_textwrapper.appendChild(node_div_msgwrapper);");			//add msgwrapper DIV to textwrapper DIV
printf("		if(inMsgSendersNote.length > 0) {");
printf("		    node_div_textwrapper.appendChild(node_div_snotewrapper);");			//add senders-note wrapper DIV to textwrapper DIV (if there was any text in it, that is)
printf("		}");
		      //Construct a DIV node that may contain action icons (e.g. reply icon), and its children...
printf("		var node_img_reply = document.createElement('img');");				//create IMG node for reply icon
printf("		    node_img_reply.id = \"replyicon_\"+inMsgRecno;");				//assign a DOM id to this node, so we can reference it whenever we need
//printf("		    node_img_reply.className = \"button roundedcorners\";");			//assign DOM class(es) to this node
printf("		    node_img_reply.className = \"button roundedcorners replyicon\";");		//assign DOM class(es) to this node
printf("		    node_img_reply.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_REPLY);	//load the reply icon
//printf("		    node_img_reply.src = PRELOADED_SPINNER_ICON.src;");//load the mini-spinner
//printf("		    node_img_reply.display = \"none\";");					
//printf("		    node_img_reply.style.visibility = \"hidden\";");				//set initial visibility to hidden, so we can show it once it's finished loading
//printf("		    node_img_reply.addEventListener('click', respondToMessageByBannerRecno, false);");//point to the global function (rather than an anonymous function) to help save on overall memory footprint	//DEV-NOTE: this seems to add an extra click (to focus??) before actually working, on iOS at least
printf("		    node_img_reply.onclick = respondToMessageByBannerRecno;");		//NOTE: this seems to happen faster, maybe??
//printf("		    node_img_reply.onload = function(){this.style.visibility='visible';};");
//printf("		attachFastClick(node_img_reply);");
printf("		var node_div_actionwrapper = document.createElement('div');");			//create DIV node for wrapping action items (e.g. drag handle icon)
printf("		    node_div_actionwrapper.className = \"actionwrapper\";");			//assign CLASS attribute/value
printf("		    node_div_actionwrapper.appendChild(node_img_reply);");			//add the reply icon to our actionwrapper node
//printf("		    node_div_actionwrapper.style.display = \"none\";");				//by default, first load (presumably launch mode), don't show this... it should show only in edit mode (to re-show, need to loop through all elements with this className and show them)
		      //Construct the clear-floats DIV
printf("		var node_div_clearfloats = document.createElement('div');");			//create DIV node for clearing a messagecell's float...
printf("		    node_div_clearfloats.className = \"clearfloats\";");			//assign CLASS attribute/value
		      //Construct the LI node that will become the messagecell for this inbox-message...
printf("		var node_li_messagecell = document.createElement('li');");			//create the node (this, being the root node for each messagecell, should be overwritten with each iteration... so do createElement assignment inside the loop like this)
printf("		    node_li_messagecell.id = \"\"+inMsgRecno+\"\";");				//assign an ID attribute/value (the inbox-msg recno)
printf("		    node_li_messagecell.className = \"messagecell \"+strClassName_item+\"\";");	//assign CLASS attribute/values (whatever was provided as this function's argument)
printf("		if(FavScreen.get('attrBrowserSupports_dataset')){");				//acquire the banner-message's launch_pin (who the message is from, basically)
printf("		    node_li_messagecell.dataset.launchpin = inMsgFromPin;");
printf("		    node_li_messagecell.dataset.templaterecno = inMsgTemplateRecno;");
printf("		}else{");
printf("		    node_li_messagecell.setAttribute(\"data-launchpin\", inMsgFromPin);");
printf("		    node_li_messagecell.setAttribute(\"data-templaterecno\", inMsgTemplateRecno);");
printf("		}");
printf("		    node_li_messagecell.appendChild(node_div_actionwrapper);");			//add actionwrapper DIV to messagecell LI (even though this is on the right side, it must go first -- just an odd thing about right-floats)
printf("		    if(node_div_iconwrapper){node_li_messagecell.appendChild(node_div_iconwrapper);}");//add iconwrapper DIV to messagecell LI, if the iconwrapper node was created above
printf("		    node_li_messagecell.appendChild(node_div_textwrapper);");			//add textwrapper DIV to messagecell LI
//printf("		    node_li_messagecell.addEventListener('click', viewMessageByBannerRecno, false);");//point to the global function (rather than an anonymous function) to help save on overall memory footprint	//DEV-NOTE: this seems to add an extra click (to focus??) before actually working, on iOS at least
printf("		    node_li_messagecell.onclick = viewMessageByBannerRecno;");//point to the global function (rather than an anonymous function) to help save on overall memory footprint
printf("		    node_li_messagecell.appendChild(node_div_clearfloats);");			//add the float-clearing DIV to messagecell LI (SHOULD BE AT THE END)
		      //Add the completed messagecell LI to the UL node that gets returned...
printf("		node_ul_messagelist.appendChild(node_li_messagecell);");			//add the fully-built LI (and all its above contents) back into the main UL
printf("		node_div_iconwrapper = false;");						//Weird-Bug: need to re-initialize this, since all not all messagecells may contain an iconwrapper ~ otherwise, the result would be icons errantly showing where they weren't supposed to
printf("	}");//end for
printf("	if(i==0){");									//if we didn't loop any (no messages exist)... we should make sure our returned UL node has at least one LI child to be completely valid HTML
printf("		var node_li_messagecell = document.createElement('li');");			//create LI node for messagecell (that will contain nothing or some text indicating that to the user)...
printf("	    	    node_li_messagecell.id = \"\";");						//assign an ID attribute/value
printf("	    	    node_li_messagecell.className = \"messagecell nomessages\";");		//assign CLASS attribute/values
printf("		    node_li_messagecell.innerHTML = \"%s\";", FAVS_DEFAULT_NOFAVSTODISPLAYHTML);//fill in the default text
printf("		node_ul_messagelist.appendChild(node_li_messagecell);");			//add the LI to the main UL
printf("	}");
/*
printf("	else {");									//else we should have messages in the inbox, so...
printf("		setTimeout(function() {");							//go through and make the reply icons visible, after a small delay (NOTE: this is a patch to help reduce the liklihood of a user experiencing a non-responsive reply icon e.g. after restore from iframe)
printf("			var theList = document.getElementById(strListID);");
printf("			var replyIcons = theList.getElementsByClassName('replyicon');");
printf("			for(var i=0; i<replyIcons.length; i++) {");
//printf("		    		replyIcons[i].src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_REPLY);	//load the proper reply icon
printf("		    		replyIcons[i].src = PRELOADED_REPLY_ICON.src;");	//load the proper reply icon
//printf("				replyIcons[i].style.visibility = 'visible';");
printf("			}");//end for
printf("			}, 2000);");
printf("	}");
*/
printf("	}");
printf("	return node_ul_messagelist;");
printf("}\n");//end function createMessageListNode_inboxMsgs()

/* Generate and return a list (UL node object) of library messages...
 * 	objSublistData		- (required obj) Sublist object (containing a YUI Recordset object) to create the subsection/list for
 * 	strListID		- (required str) The DOM id attribute value to give to the UL node that will be returned
 * 	strListClassName	- (optional str) Any DOM class attribute value(s) to give to the UL node that will be returned
 * 	strItemClassName	- (optional str) Any DOM class attribute value(s) to give to the LI nodes that will be returned as children of the UL */
printf("function createMessageListNode_libraryMsgs(objLibraryData, rsMessages, strListID, strListClassName, strItemClassName) {");
printf("	if(typeof objLibraryData === 'undefined'){");				//if no object was supplied
printf("		FavScreen.log('error', \"createMessageListNode_libraryMsgs(): The library-data to use to create the list-node (objLibraryData) wasn't provided. Aborting.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof rsMessages === 'undefined'){");				//if no recordset object was supplied
printf("		FavScreen.log('error', \"createMessageListNode_libraryMsgs(): The messages-data to use to create the list-node (rsMessages) wasn't provided. Aborting.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof strListID==='undefined'){");					//if nothing was supplied, log an error and don't allow this function to continue
printf("		FavScreen.log('error', \"createMessageListNode_libraryMsgs(): An ID attribute value (strListID) for the list-node to be returned wasn't provided. Aborting.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof strListClassName==='undefined'){");				//if nothing was supplied (because the argument is optional), initialize an empty string
printf("		strListClassName = \"\";");
printf("	}");
printf("	if(typeof strItemClassName==='undefined'){");				//if nothing was supplied (because the argument is optional), initialize an empty string
printf("		strItemClassName = \"\";");
printf("	}");
printf("	var objMsgData;");							//declare what will become an object that gets used to create each message cell (list item) -- note: declaring here, so as not to redeclare in each loop iteration
		//create the generic node used for clearing floats (NOTE: be sure to do a "cloneNode()" on this, if re-used multiple times)
printf("	var node_div_clearfloats = document.createElement('div');");		//create DIV node for clearing any float...
printf("	    node_div_clearfloats.className = \"clearfloats\";");		//assign CLASS attribute/value
		//extract applicable library information from the library-data object...
printf("	var libTitle = objLibraryData.user_title;");				//extract the lib-user's "job-title" field text (we're repurposing as library title text)
printf("	var libLastName = objLibraryData.user_lname;");				//extract the lib-user's "last-name" field text (we're using this as a fall-back title text, if title above is blank)
printf("	if(libTitle.length <= 0){");						//if no specific title text was specified, fall back to using the last name field's value instead
printf("		libTitle = libLastName;");						//the variable 'libTitle' is what we'll plug-in below
printf("	}");
		//generate library's subsection node structure...
printf("	var node_ul_messagelist = document.createElement('ul');");		//the list's root node
printf("	    node_ul_messagelist.id = strListID.toString();");
printf("	    node_ul_messagelist.className = \"messagelist library \"+strListClassName+\"\";");
		//create a messagecell for the subsection title ~note: this is just the name of the library...
printf("	var node_li_messagecell = document.createElement('li');");		//create the first LI node for the subsection's header/title text
printf("	    node_li_messagecell.className = \"messagecell subsectionheader sublistheader roundedtopcorners8\";");
printf("	    node_li_messagecell.innerHTML = libTitle;");
printf("	var node_img_refresh = document.createElement('img');");
printf("	    node_img_refresh.className = \"headericon\";");				//assign CLASS attribute/value
printf("	    node_img_refresh.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_REFRESH);
//printf("	    node_img_refresh.addEventListener('click', refreshRecordset_library_fromEvent, false);");	//DEV-NOTE: this seems to add an extra click (to focus??) before actually working, on iOS at least
printf("	    node_img_refresh.onclick = refreshRecordset_library_fromEvent;");
printf("	var node_img_minmax = document.createElement('img');");
printf("	    node_img_minmax.className = \"headericon minmax\";");			//assign CLASS attribute/value
printf("	if(strListClassName.indexOf('collapsed')) {");
printf("	    node_img_minmax.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_MINIMIZE);//initialize with minimize icon (since section starts out maximized
printf("	}else{");
printf("	    node_img_minmax.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_MAXIMIZE);//initialize with minimize icon (since section starts out maximized
printf("	}");
//printf("	    node_img_minmax.addEventListener('click', toggleExpandCollapse_subsection, false);");	//DEV-NOTE: this seems to add an extra click (to focus??) before actually working, on iOS at least
printf("	    node_img_minmax.onclick = toggleExpandCollapse_subsection;");
printf("	node_li_messagecell.appendChild(node_img_refresh);");
printf("	node_li_messagecell.appendChild(node_img_minmax);");
printf("	node_li_messagecell.appendChild(node_div_clearfloats.cloneNode());");
printf("	node_ul_messagelist.appendChild(node_li_messagecell);");		//go ahead and add that messagecell for subsection-title to the messagelist so it will be at the top
		//for each message in this subsection, create a message cell (li and its child elements)
printf("	var i = 0;");
printf("	var j = 0;");
printf("	var numOfMessages = rsMessages.size();");
printf("	for(i; i<numOfMessages; i++){");					//extract this message's data and construct an object of it that we can pass to our messagecell-creation function
printf("		objMsgData = {");							//object structure req'd members --> 'fvRecno','fvIcon','fvName','fvDesc','mtRecno','mtName','mtDir','mtDesc'
printf("			fvRecno: rsMessages.item(i).getValue('recno_fav'),");
printf("			fvIcon: rsMessages.item(i).getValue('icon'),");
printf("			fvName: rsMessages.item(i).getValue('label1'),");
printf("			fvDesc: rsMessages.item(i).getValue('label2'),");
printf("			fvPosition: rsMessages.item(i).getValue('position'),");
printf("			mtRecno: rsMessages.item(i).getValue('recno_msgtemplate'),");
printf("			mtName: rsMessages.item(i).getValue('msgname'),");
printf("			mtDir: rsMessages.item(i).getValue('msgdir'),");
printf("			mtDesc: rsMessages.item(i).getValue('msgdesc')");
printf("			};");
printf("		if(objMsgData.fvPosition.substr(0,1) == '%s') {", FAVS_LIBRARY_FLAG);	//if this message is flagged as a "L" library type, then use it
printf("			node_li_messagecell = createMessageCellNode(objMsgData, strItemClassName);");	//go get a messagecell LI node, using that set of data just created
printf("			node_ul_messagelist.appendChild(node_li_messagecell);");			//add the completed LI node for this message to the library's list
printf("			j++;");
printf("		}");
printf("	}");
		//if no messages existed for this section, round out the UL that the function will return
printf("	if(j==0){");									//if we didn't loop any (no messages exist)... we should make sure our returned UL node has at least one LI child to be completely valid HTML
printf("		node_li_messagecell = document.createElement('li');");				//create LI node for messagecell (that will contain nothing or some text indicating that to the user)...
printf("		node_li_messagecell.innerHTML = \"%s\";", FAVS_DEFAULT_NOFAVSTODISPLAYHTML);	//fill in the default text
//printf("		node_li_messagecell.style.padding = \"2px\";");
printf("		node_li_messagecell.className = \"messagecell nomessages\";");
printf("		node_ul_messagelist.appendChild(node_li_messagecell);");			//add the LI to the main UL
printf("	}");
printf("	return node_ul_messagelist;");
printf("}\n");//end function createMessageListNode_libraryMsgs()

/* Generate and return a list (UL node object) of library subsections (which, themselves, are UL nodes filled with messagecell LI's, all nested in this)...
 * 	objSublistData		- (required obj) Sublist object (containing a YUI Recordset object) to create the subsection/list for
 * 	strListID		- (required str) The DOM id attribute value to give to the UL node that will be returned
 * 	strListClassName	- (optional str) Any DOM class attribute value(s) to give to the UL node that will be returned
 * 	strItemClassName	- (optional str) Any DOM class attribute value(s) to give to the LI nodes that will be returned as children of the UL */
printf("function createMessageListNode_subsectionsLibraries(objSublistData, strListID, strListClassName, strItemClassName) {");
printf("	if(typeof objSublistData === 'undefined'){");				//if no object was supplied, default to the library hard-coded one
printf("		FavScreen.log('error', \"createMessageListNode_subsectionsLibraries(): The data to use to create the list-node (objSublistData) wasn't provided. Aborting.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof strListID==='undefined'){");					//if nothing was supplied, log an error and don't allow this function to continue
printf("		FavScreen.log('error', \"createMessageListNode_subsectionsLibraries(): An ID attribute value (strListID) for the list-node to be returned wasn't provided. Aborting.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof strListClassName==='undefined'){");				//if nothing was supplied (because the argument is optional), initialize an empty string
printf("		strListClassName = \"\";");
printf("	}");
printf("	if(typeof strItemClassName==='undefined'){");				//if nothing was supplied (because the argument is optional), initialize an empty string
printf("		strItemClassName = \"\";");
printf("	}");
printf("	var objLibUser;");							//declare a reference to the user-based section data object
//VISUAL LAYOUT/STYLING OF A TYPICAL SECTION AND ITS SUBSECTIONS (using libraries as an example):
//	+-[node_ul_subsectionlist]--------------------------------------------------------------------------------+	<ul id="subsectionlist-libraries" class="subsectionlist">		(root node for the entire section that gets returned ~ a list of sub-sections/lists)
//	| +-[node_li_sectionheader]-----------------------------------------------------------------------------+ |	  <li class="subsectioncontainer sectionheader roundedtopcorners8">	(section title header)
//	| |                                                                                                     | |
//	| +-----------------------------------------------------------------------------------------------------+ |
//	| +-[node_li_subsectioncontainer]-----------------------------------------------------------------------+ |	  <li id="[libuserrecno]" class="subsectioncontainer">			(container for a single subsection/messagelist)
//	| | +-[node_ul_messagelist]---------------------------------------------------------------------------+ | |	    <ul class="messagelist library">  					(created by another function ~ from here on, it's just like a normal single-list section)
//	| | | +-[node_li_subsection_header]-----------------------------------------------------------------+ | | |	      <li class="messagecell sublistheader roundedtopcorners8">
//	| | | |												    | | | |
//	| | | +---------------------------------------------------------------------------------------------+ | | |
//	| | | +-[node_li_messagecell]-----------------------------------------------------------------------+ | | |	      <li id="[favrecno]" class="messagecell librarymsg">
//	| | | | +-[node_div_iconwrapper]-+  +-[node_div_textwrapper]--------+  +-[node_div_actionwrapper]-+ | | | |		<div class="actionwrapper">...(action icons)...</div>		NOTE: This comes before icon and text wrappers, since we need to float it to the right of them.
//	| | | | | [node_img_icon]        |  | [node_div_namewrapper]        |  | [node_img_draghandle]    | | | | |		<div class="iconwrapper">...(main fav icon)...</div>
//	| | | | +------------------------+  | [node_div_descriptionwrapper] |  | [node_img_toggle]        | | | | |		<div class="textwrapper">...(text lines)...</div>
//	| | | |                             +-------------------------------+  +--------------------------+ | | | |
//	| | | | [node_div_clearfloats]                                                                      | | | |		<div class="clearfloats"></div>
//	| | | +---------------------------------------------------------------------------------------------+ | | |
//	| | +-------------------------------------------------------------------------------------------------+ | |
//	| +-----------------------------------------------------------------------------------------------------+ |
//	| (repeat node_li_subsectioncontainer as many times as needed)                                            |
//	+---------------------------------------------------------------------------------------------------------+
		//create the list node for the list-of-libraries (aka 'subsections') -- this will be the main node that this function returns, and will be used by the render function as it puts it into the contentwrapper div
printf("	var node_ul_subsectionlist = document.createElement('ul');");			//create a UL node for containing the list of various library sub-sections
printf("	    node_ul_subsectionlist.id = strListID.toString();");
printf("	    node_ul_subsectionlist.className = \"subsectionlist \"+strListClassName+\"\";");
		//create a special one-time list-item for the section's title
printf("	var node_li_subsectioncontainer = document.createElement('li');");
//printf("	    node_li_subsectioncontainer.className = \"subsectioncontainer sectionheader roundedtopcorners8\";");
printf("	    node_li_subsectioncontainer.className = \"sectionheader roundedtopcorners8\";");
printf("	    node_li_subsectioncontainer.innerHTML = \"%s\";", FAVS_SECTION_TITLE_SHARED_LIBRARIES);
//FUTURE-ENABLE (for all-libraries refreshes):
//		//create the generic node used for clearing floats (NOTE: be sure to do a "cloneNode()" on this, if re-used multiple times)
//printf("	var node_div_clearfloats = document.createElement('div');");		//create DIV node for clearing any float...
//printf("	    node_div_clearfloats.className = \"clearfloats\";");		//assign CLASS attribute/value
printf("	var node_img_refresh = document.createElement('img');");
printf("	    node_img_refresh.className = \"headericon\";");				//assign CLASS attribute/value
printf("	    node_img_refresh.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_REFRESH);
//printf("	    node_img_refresh.addEventListener('click', loadLibsAndMsgs, false);");	//DEV-NOTE: this seems to add an extra click (to focus??) before actually working, on iOS at least
printf("	    node_img_refresh.onclick = loadLibsAndMsgs;");
printf("	var node_img_minmax = document.createElement('img');");
printf("	    node_img_minmax.className = \"headericon minmax\";");			//assign CLASS attribute/value
printf("	    node_img_minmax.src = \"%s/icons/32x32/%s\";", cgi_icons, FAVS_ICON_MINIMIZE);//initialize with minimize icon (since section starts out maximized
//printf("	    node_img_minmax.addEventListener('click', toggleExpandCollapse_contentWrapper, false);");	//DEV-NOTE: this seems to add an extra click (to focus??) before actually working, on iOS at least
printf("	    node_img_minmax.onclick = toggleExpandCollapse_contentWrapper;");
printf("	node_li_subsectioncontainer.appendChild(node_img_refresh);");
printf("	node_li_subsectioncontainer.appendChild(node_img_minmax);");
//printf("	node_li_messagecell.appendChild(node_div_clearfloats.cloneNode());");
printf("	node_ul_subsectionlist.appendChild(node_li_subsectioncontainer);");		//go ahead and add that messagecell for subsection-title to the messagelist so it will be at the top
		//for each library, create a container
printf("	var i = 0;");
printf("	var numOfLibraries = objSublistData.length;");
printf("	for(i; i<numOfLibraries; i++){");
			//extract object-members from the main libraries array/object, and their data...
printf("		objLibUser = objSublistData[i].libUser;");					//get a reference to the lib-user data for this library
printf("		var libRecno = objLibUser.user_recno;");					//extract the lib-user's record number
printf("		var libPin = objLibUser.user_pin;");						//extract the lib-user's user-PIN, so we can use it to call the function that returns the subsection node for this library
			//build this subsection's container LI node and add it to the list that'll get returned
printf("		node_a_jumpScrollAnchor = document.createElement('a');");
printf("		node_a_jumpScrollAnchor.id = \"libraryAnchor_\"+libPin.trim();");
printf("		node_a_jumpScrollAnchor.name = \"libraryAnchor_\"+libPin.trim();");
printf("		node_a_jumpScrollAnchor.className = \"subsectionAnchor jumpEligible\";");
printf("		node_li_subsectioncontainer = document.createElement('li');");			//create an LI node (have to actually do the create method to avoid re-using the same node for each iteration)
printf("		node_li_subsectioncontainer.id = libRecno.toString();");
printf("		node_li_subsectioncontainer.className = \"subsectioncontainer\";");
printf("		if(FavScreen.get('attrBrowserSupports_dataset')){");				//acquire the message-template recno 
printf("			node_li_subsectioncontainer.dataset.userpin = libPin;");
printf("		}else{");
printf("			node_li_subsectioncontainer.setAttribute(\"data-userpin\", libPin);");
printf("		}");
printf("		node_li_subsectioncontainer.appendChild(node_a_jumpScrollAnchor);");
printf("		if(libPin.trim() == '%s') {", FAVS_LIB_USER_STDREPLIES_PIN);
printf("			node_li_subsectioncontainer.appendChild( createMessageListNode_libraryMsgs(objLibUser, objSublistData[i].rsLibMsgs, 'messagelist-library-'+libRecno, 'collapsed', 'libmsg') );");
printf("		}else{");
printf("			node_li_subsectioncontainer.appendChild( createMessageListNode_libraryMsgs(objLibUser, objSublistData[i].rsLibMsgs, \"messagelist-library-\"+libRecno, '', 'libmsg') );");
printf("		}");
printf("		node_ul_subsectionlist.appendChild(node_li_subsectioncontainer);");		//add the completed LI node for this library-section to the list
printf("	}");
		//if no messages existed for this section, round out the UL that the function will return
printf("	if(i==0){");									//if we didn't loop any (no messages exist)... we should make sure our returned UL node has at least one LI child to be completely valid HTML
printf("		node_li_empty = document.createElement('li');");			//create LI node for messagecell (that will contain nothing or some text indicating that to the user)...
printf("		node_ul_subsectionlist.appendChild(node_li_empty);");		//add the LI to the main UL
printf("	}");
printf("	return node_ul_subsectionlist;");
printf("}\n");//end function createMessageListNode_subsectionsLibraries()

//printf("var flashHeaderIntervalHandle;");
printf("function updateScreenStyle(e){");						// Update the visual look-and-feel of the screen to reflect the current mode (note: gets called by event listener for attrInteractionModeChange) 
printf("	var headerWrapper_backgroundColor = document.getElementById(\"headerwrapper\").style.backgroundColor;");
//printf("	var logotext = document.getElementById(\"logotext\");");
printf("	var pageSubtitle = document.getElementById(\"pagesubtitle\");");
printf("	var pageTitle = document.getElementById(\"pagetitle\");");
printf("	var pageTitleWrapper = document.getElementById(\"pagetitlewrapper\");");
printf("	var headerWrapper = document.getElementById(\"headerwrapper\");");
printf("	if(FavScreen.get('attrInteractionMode')==MODE_LAUNCHABLE){");		//if favorites screen is in click-to-launch mode..
printf("		headerWrapper.className = \"\";");					//this should be fine as long as there are no other classes we want to keep for this node
//printf("		pageTitle.innerHTML = \"My %s\";", FAVS_NAME);
printf("		pageTitle.innerHTML = \"%s\";", FAVS_NAME_SHORT);
printf("		pageSubtitle.style.display = \"inline\";");				//show the subtitle (it's a span, so inline)
//printf("		pageTitleWrapper.classList.add(\"withsubtitle\");");			//alternative method - update this later as need as things get more complex
printf("		pageTitleWrapper.className = \"withsubtitle\";");			//reposition pagetitle elements by adding 'withsubtitle' class
printf("		var node_btnDone = document.getElementById(\"btnDone\");");
printf("		node_btnDone.parentNode.removeChild(node_btnDone);");
printf("	}");
printf("	else if(FavScreen.get('attrInteractionMode')==MODE_EDITABLE){");	//else-if favorites screen is in editable mode...
printf("		headerWrapper.className = \"editmode\";");				//this should be fine as long as there are no other classes we want to keep for this node (otherwise, need to append with +=)
//printf("		headerWrapper.classList.add(\"editmode\");"); 				//alternative method - update to this later as needed as things get more complex
printf("		pageTitle.innerHTML = \"Editing...\";");
printf("		pageSubtitle.style.display = \"none\";");				//hide subtitle
//printf("		pageTitleWrapper.classList.remove(\"withsubtitle\");");			//alternative method - update this later as need as things get more complex
printf("		pageTitleWrapper.className = \"\";");					//reposition pagetitle elements by removing 'withsubtitle' class
printf("		if(document.getElementById('btnDone') === null) {");			//only add a btnDone node if one doesn't already exist
printf("			var node_btnDone = document.createElement('button');");
printf("			node_btnDone.id = \"btnDone\";");
printf("			node_btnDone.type = \"button\";");					//specify this to avoid the button triggering a submit to the server
printf("			node_btnDone.innerHTML = \"Done\";");
printf("			node_btnDone.onclick = function(e){e.preventDefault(); menuAction_launchMode();};");
printf("			pageTitleWrapper.parentNode.insertBefore(node_btnDone, pageTitleWrapper.nextSibling);");//add the button right after the pagetitlewrapper node (not inside it)
printf("		}");
printf("	}");
printf("	else if(FavScreen.get('attrInteractionMode')==MODE_DELETED){");		//else-if favorites screen is in deleted-favs mode...
//printf("		aux1headingText.innerHTML = \"Deleted %s\";", FAVS_NAME_PLURAL);
printf("	}");
printf("	else if(FavScreen.get('attrInteractionMode')==MODE_REPLYING){");	//else-if favorites screen is in replying mode...
printf("		headerWrapper.className = \"replyingmode\";");				//this should be fine as long as there are no other classes we want to keep for this node (otherwise, need to append with +=)
printf("		pageTitle.innerHTML = \"Replying...\";");
printf("		pageSubtitle.style.display = \"none\";");				//hide subtitle
printf("		pageTitleWrapper.className = \"\";");					//reposition pagetitle elements by removing 'withsubtitle' class
printf("		if(document.getElementById('btnDone') === null) {");			//only add a btnDone node if one doesn't already exist
printf("			var node_btnDone = document.createElement('button');");
printf("			node_btnDone.id = \"btnDone\";");
printf("			node_btnDone.type = \"button\";");					//specify this to avoid the button triggering a submit to the server
printf("			node_btnDone.innerHTML = \"Done\";");
printf("			node_btnDone.onclick = function(e){e.preventDefault(); menuAction_launchMode();};");
printf("			pageTitleWrapper.parentNode.insertBefore(node_btnDone, pageTitleWrapper.nextSibling);");//add the button right after the pagetitlewrapper node (not inside it)
printf("		}");
printf("	}");
printf("	if(typeof e === 'object') {");
printf("		if(e.prevVal == MODE_REPLYING) {");								//if reply mode is ending...
printf("			expandContainer('contentwrapper-inbox');");							//ensure the inbox section is expanded
printf("			collapseContainer('messagelist-library-'+getUserRecnoForStdReplies());");			//collapse the standard reply library subsection
printf("		}");
printf("		if(e.newVal == MODE_REPLYING) {");								//if reply mode is starting...
printf("			collapseContainer('contentwrapper-inbox');");							//ensure the inbox section is collapsed
printf("			expandContainer('messagelist-library-'+getUserRecnoForStdReplies());");				//epxand the standard reply library subsection
printf("			expandContainer('contentwrapper-libraries');");							//ensure the library section is expanded, so the discrete library above can be visible
//printf("			flashHeaderIntervalHandle = setInterval( function() {");
//printf("				flashHeaderWrapper('white');");
//printf("				}, );");
printf("		}");
printf("		if(e.newVal == MODE_EDITABLE) {");								//if edit mode is starting...
printf("			collapseContainer('contentwrapper-inbox');");							//ensure the inbox section is collapsed
printf("			collapseContainer('contentwrapper-libraries', false);");					//ensure the library section is collapsed (false means don't collapse if current user is a LIB user - true would force collapse, anyway)
printf("		}");
printf("		if(e.prevVal == MODE_EDITABLE) {");								//if edit mode is ending...
printf("			expandContainer('contentwrapper-inbox');");							//ensure the inbox section is expanded
printf("			expandContainer('contentwrapper-libraries');");							//ensure the library section is expanded
printf("		}");
printf("	}");
printf("}\n");

printf("</script>");
}


/***********************************************************************
* void add_favSupport_gridFormat(void)
*
* 	Supporting JavaScript functions to read/manage the YUI favorites  
* 	recordset and display it to the user in a grid format.
*
***********************************************************************/
void add_favSupport_gridFormat(void)
{
/* not developed yet */
printf("<script type=\"text/javascript\">FavScreen.log('info', \"Version note: grid display not yet available\", true);</script>");
}


/***********************************************************************
* void add_yuiInstance_inboxMsgRecordset(void)
*
* 	Generate initial inbox message data and render on the page, if exists.
*
***********************************************************************/
void add_yuiInstance_inboxMsgRecordset(void)
{
/* NOTE: we're not going to bother adding support here (like we do at the top of 'add_yuiInstance_favMsgRecordset'), since it's easier to just make sure that is called before this one */

/* Construct the inbox-message recordset
 * NOTE: This works, basically like the other main one. */
printf("<script type=\"text/javascript\">\n");

printf("YUI().use('recordset-base', function(Y){");								// Create a new YUI instance that will allow us to work with recordset stuff...
		// First we instantiate our RecordSet object...
printf("	FavScreen.rsInbox = new Y.Recordset();");								//initialize a new recordset into our global object

		// Then we tell it how to behave after it's ready to use, and after the initial set of data is added to it (which happens later)...
printf("	FavScreen.rsInbox.after('init', function(){");							//subscribe an initial "after init" event listner to the recordset object (just so we are absolutely certain we attach the next after-add event listener to a fully-initialized object)
printf("		FavScreen.log('log', \"YUI-RecordSet: FavScreen.rsInbox: Recordset initialized. Waiting for the addition of the initial set of inbox-message data...\", false);");

			// *** EVENT LISTENER NOTICE... Since the inbox is created with its nodes having explicit and direct
			// event listeners assigned, we don't need to worry about them not working whenever the node is
			// appended to its container. This is in contrast to other cloneNode types of situation, etc.

printf("		FavScreen.rsInbox.after('add', function(){");						//subscribe an initial "after add" event listner to the recordset object to render the inbox list as soon as possible (this will fire after our initial add of inboxMsgsFromDB, further below)
printf("			FavScreen.rsInbox.detachAll();");							//detach all initial event listeners, so we can seamlessly reattach other events later (like maybe for sorting, adding new, etc.)

printf("			FavScreen.log('log', \"YUI-RecordSet: FavScreen.rsInbox: Initial set of \"+this.size()+\" record(s) now populated into the 'rsInbox' recordset. Rendering a list node in the DOM...\", false);");
printf("			FavScreen.set('attrLastRefreshTimestamp_inboxMsgs',Date.now());");
printf("			FavScreen.node_ul_inboxMsgs = createMessageListNode_inboxMsgs(this, \"messagelist-inboxmsgs\", \"\", \"inboxmsg\");");//get a inbox-msgs node and save it as a member of the main class
printf("			var node_cw = document.getElementById(\"contentwrapper-inbox\");");
printf("			if(node_cw !== null) {");
printf("				node_cw.appendChild(FavScreen.node_ul_inboxMsgs);");
printf("				node_cw.style.visibility = \"visible\";");
printf("			}else{");
printf("				Favscreen.log('info',\"YUI-RecordSet: FavScreen.rsInbox: Node 'contentwrapper-inbox' not found in document. Could not render records.\",true);");
printf("			}");

printf("			FavScreen.rsInbox.after('add', function(e){");						//attach permanent after-add events (pertains to adding one/many records to the recordset)
printf("				FavScreen.log('log', \"YUI-RecordSet: FavScreen.rsInbox: After-add event fired... \"+this.size()+\" record(s) added. Updating DOM...\", true);");
printf("				FavScreen.node_ul_inboxMsgs = createMessageListNode_inboxMsgs(this, \"messagelist-inboxmsgs\", \"\", \"inboxmsg\");");//get a inbox-msgs node and save it to the main class
printf("				var node_cw = document.getElementById(\"contentwrapper-inbox\");");			//get a handle to the list's parent node
printf("				if(node_cw !== null) {");
printf("					if(node_cw.childNodes.length>0){");							//if there's a list
printf("						node_cw.removeChild(node_cw.childNodes[0]);");						//remove it from the DOM
printf("					}");
printf("					node_cw.appendChild(FavScreen.node_ul_inboxMsgs);");					//add the updated list
printf("				}else{");
printf("					Favscreen.log('info',\"YUI-RecordSet: FavScreen.rsInbox after-add: Node 'contentwrapper-inbox' not found in document. Could not render added records.\",true);");
printf("				}");
printf("			});");

printf("			FavScreen.rsInbox.after('empty', function(e){");					//attach permanent after-empty events (pertains to emptying the entire recordset)
printf("				if(Boolean(FavScreen.rsInbox_skipUpdateDOM_afterEmpty) ){");
printf("					FavScreen.log('log', \"YUI-RecordSet: FavScreen.rsInbox: After-empty event fired... recordset has been emptied of all records. NOT updating DOM, since skip flag is set... Done.\", true);");
printf("					return;");
printf("				}");
printf("				FavScreen.log('log', \"YUI-RecordSet: FavScreen.rsInbox: After-empty event fired... recordset has been emptied of all records. Updating DOM...\", true);");
printf("				FavScreen.node_ul_inboxMsgs = createMessageListNode_inboxMsgs(this, \"messagelist-inboxmsgs\", \"\", \"inboxmsg\");");//get a inbox-msgs node and save it to the main class
printf("				var node_cw = document.getElementById(\"contentwrapper-inbox\");");			//get a handle to the list's parent node
printf("				if(node_cw !== null) {");
printf("					if(node_cw.childNodes.length>0){");							//if there's a list
printf("						node_cw.removeChild(node_cw.childNodes[0]);");						//remove it from the DOM
printf("					}");
printf("					node_cw.appendChild(FavScreen.node_ul_inboxMsgs);");					//add the updated list back
printf("				}else{");
printf("					Favscreen.log('info',\"YUI-RecordSet: FavScreen.rsInbox after-empty: Node 'contentwrapper-inbox' not found in document. Could not render emptied records.\",true);");
printf("				}");
printf("			});");

printf("			FavScreen.rsInbox.after('remove', function(e){");					//attach permanent after-remove events (pertains to removing one/many records from the recordset)
printf("				FavScreen.log('log', \"YUI-RecordSet: FavScreen.rsInbox: After-remove event fired... record(s) removed. Updating DOM...\", true);");
printf("				FavScreen.node_ul_inboxMsgs = createMessageListNode_inboxMsgs(this, \"messagelist-inboxmsgs\", \"\", \"inboxmsg\");");//get a inbox-msgs node and save it to the main class
printf("				var node_cw = document.getElementById(\"contentwrapper-inbox\");");			//get a handle to the list's parent node
printf("				if(node_cw !== null) {");
printf("					if(node_cw.childNodes.length>0){");							//if there's a list
printf("						node_cw.removeChild(node_cw.childNodes[0]);");						//remove it from the DOM
printf("					}");
printf("					node_cw.appendChild(FavScreen.node_ul_inboxMsgs);");					//add the updated list back
printf("				}else{");
printf("					Favscreen.log('info',\"YUI-RecordSet: FavScreen.rsInbox after-remove: Node 'contentwrapper-inbox' not found in document. Could not render removed records.\",true);");
printf("				}");
printf("			});");

printf("			FavScreen.rsInbox.after('update', function(e){");					//attach permanent after-update events (pertains to updating one/many records in the recordset)
printf("				FavScreen.log('log', \"YUI-RecordSet: FavScreen.rsInbox: After-update event fired... record(s) updated. Updating DOM...\", true);");
printf("				FavScreen.node_ul_inboxMsgs = createMessageListNode_inboxMsgs(this, \"messagelist-inboxmsgs\", \"\", \"inboxmsg\");");//get a inbox-msgs node and save it to the main class
printf("				var node_cw = document.getElementById(\"contentwrapper-inbox\");");			//get a handle to the list's parent node
printf("				if(node_cw !== null) {");
printf("					if(node_cw.childNodes.length>0){");							//if there's a list
printf("						node_cw.removeChild(node_cw.childNodes[0]);");						//remove it from the DOM
printf("					}");
printf("					node_cw.appendChild(FavScreen.node_ul_inboxMsgs);");					//add the updated list back
printf("				}else{");
printf("					Favscreen.log('info',\"YUI-RecordSet: FavScreen.rsInbox after-update: Node 'contentwrapper-inbox' not found in document. Could not render updated records.\",true);");
printf("				}");
printf("			});");

printf("		});");//end add event listener subscription
printf("	});");//end init event listener subscription

		// Finally, we actually add our raw data to the recordset (thus, firing all the behaviors outlined above)...
printf("	FavScreen.rsInbox.add(inboxMsgsFromDB);");								//add our data to the recordset (which will fire the 'after add' stuff above, and actually render the results )

printf("});\n");//end .use recordset
printf("</script>");
}

/***********************************************************************
* void add_yuiInstance_librariesObjectAndRecordsets(void)
*
* 	Generate initial libraries message data and render on the page, if exists.
*
***********************************************************************/
void add_yuiInstance_librariesObjectAndRecordsets(void)
{
/* NOTE: we're not going to bother adding support here (like we do at the top of 'add_yuiInstance_favMsgRecordset'), since it's easier to just make sure that is called before this one */
//printf("<script type=\"text/javascript\">\n");
//printf("var objLibsMsgs = loadLibsAndMsgs();");	//note: initial load may not immediately populate this... the msgs recordset members may take a bit longer to populate since they're asynchronously dealt with
//printf("if(typeof objLibsMsgs === 'object') {");
//printf("	var numOfLibs = objLibsMsgs.length;");
//printf("	FavScreen.log('log',\"FavScreen.objLibsMsgs: Initializing primary set of \"+numOfLibs+\" libraries and their messages.\",false);");
//printf("	FavScreen.objLibsMsgs = objLibsMsgs;");
//printf("}else{");
//printf("	FavScreen.log('error',\"FavScreen.objLibsMsgs: Initial call to loadLibsAndMsgs() returned a '\"+typeof objLibsMsgs+\"' (\"+objLibsMsgs+\").\",false);");
//printf("	FavScreen.objLibsMsgs = objLibsMsgs;");
		//dev-note: show msgs unavailable in the libraries section?
//printf("}");
//printf("</script>");
}

/***********************************************************************
* void add_yuiInstance_favMsgRecordset(void)
*
* 	Generate initial favorited messages data and render on the page.
*
***********************************************************************/
void add_yuiInstance_favMsgRecordset(void)
{
add_favSupport_recordset();									//bring in supporting javascript functions for YUI recordset stuff (some of these are called from stuff brought in by the add_'s immediately below, so it's probably best to keep this load-order)
add_favSupport_listFormat();									//bring in supporting javascript functions for list-formatted favorite screen
//add_favSupport_gridFormat();									//bring in supporting javascript functions for grid-formatted favorite screen

#ifdef GET_FAVS_FROM_DATABASE									//if configured to use data from the favorites database...
generate_favData_forCurrentUser(TRUE);								//this function generates a data object from the actual favorites database
generate_inboxData_forCurrentUser(TRUE);								//this function generates a data object from the actual favorites database
#else												//else use test data for testing/debugging/developing
generate_favTestData(TRUE);									//this function generates a data object with static, hard-coded test-data
#endif

/* Construct the favorite-message recordset
 * NOTE: This little bit of code actually does quite a lot of important things, so here is a quick summary of what all happens...
 *  - Initialize a global YUI Recordset object, 
 *  - Attach initial (temporary) event listeners that listen for both, recordset initialization-completion and data-population-completion,
 *  - Once those events fire (and we're thus certain the Recordset data is complete), we create our sub-recordsets (non-sorted, deleted, etc.) and command the data to render on the page by calling the appropriate "renderMessageListSection..." functions */
printf("<script type=\"text/javascript\">\n");

printf("YUI().use('recordset-base', 'recordset-filter', 'recordset-sort', function(Y){");			// Create a new YUI instance that will allow us to work with recordset stuff...
printf("	if(typeof FavScreen==='undefined'){");								//if our global object isn't defined, then don't allow this function to continue
printf("		console.error(\"Initializing the original recordset requires that FavScreen be created, first!\");");
printf("		window.alert(\"Service unavailable. Try again.\");");
printf("		return false;");
printf("	}");

		// First we instantiate our RecordSet object...
printf("	FavScreen.rsOrig = new Y.Recordset();");								//initialize a new recordset into our global object
printf("	FavScreen.rsOrig.plug(Y.Plugin.RecordsetFilter);");							//plug-in the filter stuff (access its stuff from the .filter namespace... e.g. to filter: FavScreen.rsOrig.filter.filter([options]) )
printf("	FavScreen.rsOrig.plug(Y.Plugin.RecordsetSort);");							//plug-in the sort stuff (access its stuff from the .sort namespace... e.g. to sort: FavScreen.rsOrig.sort.sort([options]) )

		// Then we tell it how to behave after it's ready to use, and after the initial set of data is added to it (which happens later)...
printf("	FavScreen.rsOrig.after('init', function(){");								//subscribe an initial "after init" event listner to the recordset object (just so we are absolutely certain we attach the next after-add event listener to a fully-initialized object)
printf("		FavScreen.log('log', \"YUI-RecordSet: FavScreen.rsOrig: Recordset initialized. Waiting for the addition of the initial set of master favorites-data...\", false);");

printf("		FavScreen.rsOrig.after('add', function(){");							//subscribe an initial "after add" event listner to the recordset object to render the favorites list as soon as possible (this will fire after our initial add of favsFromDB, further below)
printf("			FavScreen.rsOrig.detachAll();");							//detach all initial event listeners, so we can seamlessly reattach other events later (like maybe for sorting, adding new, etc.)

printf("			FavScreen.log('log', \"YUI-RecordSet: FavScreen.rsOrig: Initial set of \"+this.size()+\" record(s) now populated into the master 'rsOrig' recordset. Extracting sub-recordsets and rendering on-screen...\", false);");
printf("			rs_extractRecordsToRecordsets('FavScreen.rsOrig');");

printf("			loadSections();");									//handle loading of major-section instances (note: this is smart enough not to do it again, if they're already instantiated)
printf("			initializeSections();");

/* ORIGINAL WAY...
printf("			var node_ul = createMessageListNode(FavScreen.rsOrig_sorted, \"messagelist-sorted\", \"\", \"sorted\");");//get sorted favs list node
printf("			var numSortedFavsDisplayed = renderMessageListSection_sorted(node_ul);");		//render the sorted favorites as a node, while returning the number of favorites that got rendered
printf("			FavScreen.set('attrNumSortedFavsDisplaying', numSortedFavsDisplayed);");		//inform the global attribute how many sorted favs should be showing on-screen (we'll check it next when we render un-sorted favs, to determine whether to show an unsorted here or not)
*/
/* NEW CLASS-BASED WAY... */
printf("			if(typeof MajorSection_critical === 'object') {");
printf("				MajorSection_critical.cfg.objYuiRS_messageData = FavScreen.rsOrig_sorted;");
printf("				MajorSection_critical.renderListInItsSection();");
printf("			}");
printf("			else {");
printf("				FavScreen.log('warn', \"YUI-RecordSet: FavScreen.rsOrig: The 'MajorSection_critical' instance does NOT exist! Invoking loadSections() now...\", true);");
printf("				loadSections();");		//redundant?
printf("				initializeSections();");	//redundant?
printf("				FavScreen.log('info', \"YUI-RecordSet: FavScreen.rsOrig: The 'MajorSection_critical' instance did NOT exist, but now may; so setting it to render after 1s...\", true);");
printf("				setTimeout( function() {");							//just to be safe and give it time to finish instantiating, if need-be
printf("					MajorSection_critical.cfg.objYuiRS_messageData = FavScreen.rsOrig_sorted;");
printf("					MajorSection_critical.renderListInItsSection();");
printf("					}, 1000);");//end setTimeout
printf("			}");
/* end new way */

/* ORIGINAL WAY...
printf("			node_ul = createMessageListNode(FavScreen.rsOrig_unsorted, \"messagelist-unsorted-1\", \"\", \"unsorted\");");//get unsorted favs list node
printf("			try{renderMessageListSection_unsorted(node_ul);}");
printf("			catch(err){");
printf("				alert(\"An problem occurred while trying to render %s on-screen.\\n\\nError Message:\\n\"+err.message+\"\\n\\nIf you encounter problems, please refresh your browser or restart the app.\");", FAVS_NAME_PLURAL);
printf("			}");
*/
/* NEW CLASS-BASED WAY... */
printf("			if(typeof MajorSection_dropbox === 'object') {");
printf("				MajorSection_dropbox.cfg.objYuiRS_messageData = FavScreen.rsOrig_unsorted;");
printf("				MajorSection_dropbox.renderListInItsSection();");
printf("			}");
printf("			else {");
printf("				FavScreen.log('error', \"YUI-RecordSet: FavScreen.rsOrig: The 'MajorSection_dropbox' instance does NOT exist! Invoking loadSections() now...\", true);");
printf("				loadSections();");		//redundant?
printf("				initializeSections();");	//redundant?
printf("				FavScreen.log('info', \"YUI-RecordSet: FavScreen.rsOrig: The 'MajorSection_dropbox' instance did NOT exist, but now may; so setting it to render after 1s...\", true);");
printf("				setTimeout( function() {");							//just to be safe and give it time to finish instantiating, if need-be
printf("					MajorSection_dropbox.cfg.objYuiRS_messageData = FavScreen.rsOrig_unsorted;");
printf("					MajorSection_dropbox.renderListInItsSection();");
printf("					}, 1000);");//end setTimeout
printf("			}");
/* end new way */

printf("			if(typeof MajorSection_personalLibs === 'object') {");
printf("				MajorSection_personalLibs.cfg.objYuiRS_messageData = FavScreen.rsOrig_personalLibs;");
printf("				MajorSection_personalLibs.renderListInItsSection();");
printf("			}");
printf("			else {");
printf("				FavScreen.log('error', \"YUI-RecordSet: FavScreen.rsOrig: The 'MajorSection_personalLibs' instance does NOT exist! Invoking loadSections() now...\", true);");
printf("				loadSections();");		//redundant?
printf("				initializeSections();");	//redundant?
printf("				FavScreen.log('info', \"YUI-RecordSet: FavScreen.rsOrig: The 'MajorSection_personalLibs' instance did NOT exist, but now may; so setting it to render after 1s...\", true);");
printf("				setTimeout( function() {");							//just to be safe and give it time to finish instantiating, if need-be
printf("					MajorSection_personalLibs.cfg.objYuiRS_messageData = FavScreen.rsOrig_personalLibs;");
printf("					MajorSection_personalLibs.renderListInItsSection();");
printf("					}, 1000);");//end setTimeout
printf("			}");

			/* note: I *think* we don't do section-renders below, because the routines that cause these to happen, do it instead? */
printf("			FavScreen.rsOrig.after('add', function(e){");						//attach permanent after-add events (pertains to adding one/many records to the recordset)
printf("				FavScreen.log('log', \"YUI-RecordSet: FavScreen.rsOrig: After-add event fired... \"+this.size()+\" record(s) added. Updating sub-recordsets\", true);");
printf("				rs_extractRecordsToRecordsets('FavScreen.rsOrig');");				//re-create any sub-recordsets that are based on this one
printf("			});");

printf("			FavScreen.rsOrig.after('empty', function(e){");						//attach permanent after-empty events (pertains to emptying the entire recordset)
printf("				FavScreen.log('log', \"YUI-RecordSet: FavScreen.rsOrig: After-empty event fired... recordset has been emptied of all records. Updating sub-recordsets...\", true);");
printf("				rs_extractRecordsToRecordsets('FavScreen.rsOrig');");				//re-create any sub-recordsets that are based on this one
printf("			});");

printf("			FavScreen.rsOrig.after('remove', function(e){");					//attach permanent after-remove events (pertains to removing one/many records from the recordset)
printf("				FavScreen.log('log', \"YUI-RecordSet: FavScreen.rsOrig: After-remove event fired... record(s) removed. Updating sub-recordsets...\", true);");
printf("				rs_extractRecordsToRecordsets('FavScreen.rsOrig');");				//re-create any sub-recordsets that are based on this one
printf("			});");

printf("			FavScreen.rsOrig.after('update', function(e){");					//attach permanent after-update events (pertains to updating one/many records in the recordset)
printf("				FavScreen.log('log', \"YUI-RecordSet: FavScreen.rsOrig: After-update event fired... record(s) updated. Updating sub-recordsets...\", true);");
printf("				rs_extractRecordsToRecordsets('FavScreen.rsOrig');");				//re-create any sub-recordsets that are based on this one
printf("				updateMessagecells();");
printf("			});");

printf("			Spinner.hide();");

printf("		});");//end add event listener subscription
printf("	});");//end init event listener subscription

		// Finally, we actually add our raw data to the recordset (thus, firing all the behaviors outlined above)...
printf("	FavScreen.rsOrig.add(favsFromDB);");									//add our data to the recordset (which will fire the 'after add' stuff above, and actually render the results on the page)

printf("});\n");//end .use recordset
printf("</script>");
}//end function add_yuiInstance_favMsgRecordset()


/***********************************************************************
* static void add_jsPageGlobals(void)
*
*	This function prints page-global JavaScript.
*	NOTE: This is a central component of the page that many things depend on, so it should be loaded before most other things.
*
***********************************************************************/
static void add_jsPageGlobals(void)
{
char dtsec[DTSEC_LENGTH];
char *httpUserAgentString = getenv("HTTP_USER_AGENT");        /* use this here instead of cgi_detect_browser() because we want more detailed info than just the few it offers */

get_dtsec(dtsec);

add_js_function_isLoadedInMobileApp();

printf("\n");
printf("<script type=\"text/javascript\">/* %s Globals */\n", FAVS_NAME_FULL);

/* Define "constants" (mainly to make the code easier to read, use and debug -- just make sure the assigned literal-values are globally unique)... */
printf("var MODE_LAUNCHABLE		= 'LaunchMode';\n");			//it's not really important what any of these values actually are, as long as they're globally unique...
printf("var MODE_EDITABLE		= 'EditMode';\n");
printf("var MODE_DELETED		= 'DeletedMode';\n");
printf("var MODE_REPLYING		= 'ResponseMode';\n");
printf("var MODE_JUMPNAV_UP		= 'JumpNavModeUp';\n");
printf("var MODE_JUMPNAV_DOWN		= 'JumpNavModeDown';\n");
printf("var LAYOUT_LIST			= 'ListLayout';\n");
printf("var LAYOUT_GRID			= 'GridLayout';\n");
printf("var ORIENTATION_LANDSCAPE	= 'LandscapeOrientation';\n");
printf("var ORIENTATION_PORTRAIT	= 'PortraitOrientation';\n");
printf("var DEVICETYPE_PHONE		= 'Phone';\n");
printf("var DEVICETYPE_TABLET		= 'Tablet';\n");
printf("var DEVICETYPE_PC		= 'PC';\n");
printf("var EXPANDED_STATE		= 'ExpandedState';\n");
printf("var COLLAPSED_STATE		= 'CollapsedState';\n");

/* Define "constants" that will help us scope C/CGI data into the JS space, so JS can run more independently of the server */
printf("var PRODUCT_MANUFACTURER			= \"%s\";\n", PRODUCT_MANUFACTURER);
printf("var PRODUCT_NAME				= \"%s\";\n", PRODUCT_NAME);
printf("var FAVS_NAME_FULL				= \"%s\";\n", FAVS_NAME_FULL);
printf("var FAVS_NAME_SHORT				= \"%s\";\n", FAVS_NAME_SHORT);
printf("var FAVS_NAME_PLURAL				= \"%s\";\n", FAVS_NAME_PLURAL);
printf("var FAVS_NAME_SINGULAR				= \"%s\";\n", FAVS_NAME_SINGULAR);
printf("var FAVS_FAVNAME_MAXLENGTH			= %d;\n", FAVS_FAVNAME_MAXLENGTH);
printf("var SERVER_VALUE_TRUE				= %d;\n", TRUE);
printf("var SERVER_VALUE_FALSE				= %d;\n", FALSE);
printf("var CGI_SERVER					= '%s';\n", cgi_server);				//define the cgi-server resource (e.g. what we POST to)
printf("var CURRENT_USER_PIN				= '%s';\n", CurrentUserPin);				//define the current user pin
printf("var CURRENT_USER_PIN_ENCODED			= '%s';\n", cgi_EncodeLoginPin(CurrentUserPin));	//define the encoded version of the user pin (used for authentication by SMCGI on the server ~ note: this is in plain text on forms, anyway, so... yeah)
printf("var CGI_IDENT_FIELD				= '%s';\n", cgi_identification_field);			//define the name of the authentation field (usually combined as the name/value pair with CURRENT_USER_PIN_ENCODED)
printf("var FAVS_LIB_USER_STDREPLIES_PIN		= '%s';\n", FAVS_LIB_USER_STDREPLIES_PIN);
printf("var FAVS_SPINNER_DELAY_HIDE			= parseInt(%d);\n", FAVS_SPINNER_DELAY_HIDE);

printf("var FAVS_POSITION_DELINEATE_TYPE		= '%s';", FAVS_POSITION_DELINEATE_TYPE);
printf("var FAVS_POSITION_DELINEATE_COORD		= '%s';", FAVS_POSITION_DELINEATE_COORD);
printf("var FAVS_SORTED_FLAG				= '%s';", FAVS_SORTED_FLAG);
printf("var FAVS_UNSORTED_FLAG				= '%s';", FAVS_UNSORTED_FLAG);
printf("var FAVS_LIBRARY_PERSONAL_FLAG			= '%s';", FAVS_LIBRARY_PERSONAL_FLAG);
printf("var FAVS_REMOVED_FLAG				= '%s';", FAVS_REMOVED_FLAG);
printf("var FAVS_DELETED_FLAG				= '%s';", FAVS_DELETED_FLAG);

printf("var FAVS_RECNO_FLAG_CREATE_SUBHEADER_PERSONALMSGS = %d;", FAVS_RECNO_FLAG_CREATE_SUBHEADER_PERSONALMSGS);
printf("var FAVS_RECNO_FLAG_CREATE_SUBHEADER_BLANKNEW 	= %d;", FAVS_RECNO_FLAG_CREATE_SUBHEADER_BLANKNEW);

printf("var FAVS_SECTION_TITLE_CRITICAL			= \"%s\";", FAVS_SECTION_TITLE_CRITICAL);
printf("var FAVS_SECTION_TITLE_PERSONAL_LIBRARIES	= \"%s\";", FAVS_SECTION_TITLE_PERSONAL_LIBRARIES);
printf("var FAVS_SECTION_TITLE_DROPBOX			= \"%s\";", FAVS_SECTION_TITLE_DROPBOX);

printf("var FAVS_SECTION_TITLE_PERSONAL_LIB_DEFAULT_FIRST	= \"%s\";", FAVS_SECTION_TITLE_PERSONAL_LIB_DEFAULT_FIRST);
printf("var FAVS_SECTION_TITLE_PERSONAL_LIB_DEFAULT_BLANKNEW	= \"%s\";", FAVS_SECTION_TITLE_PERSONAL_LIB_DEFAULT_BLANKNEW);

printf("var FAVS_ICON_PATH				= '%s/icons/32x32';\n", cgi_icons);
printf("var FAVS_ICON_PATH_CODED			= '%s/icons/32x32/coded';\n", cgi_icons);

printf("var FAVS_DEFAULT_UNSORTED_ICON_FILE		= \"%s\";", FAVS_DEFAULT_UNSORTED_ICON_FILE);
printf("var FAVS_ICON_DRAGHANDLE			= \"%s\";", FAVS_ICON_DRAGHANDLE);

printf("var FAVS_ICON_CLOSE_X				= '%s/icons/32x32/%s';\n", cgi_icons, FAVS_ICON_CLOSE_X);
printf("var FAVS_ICON_TOGGLE_CLOSE			= '%s/icons/32x32/%s';\n", cgi_icons, FAVS_ICON_TOGGLE_CLOSE);
printf("var FAVS_ICON_MINIMIZE				= '%s/icons/32x32/%s';\n", cgi_icons, FAVS_ICON_MINIMIZE);
printf("var FAVS_ICON_MAXIMIZE				= '%s/icons/32x32/%s';\n", cgi_icons, FAVS_ICON_MAXIMIZE);
printf("var FAVS_ICON_REFRESH				= '%s/icons/32x32/%s';\n", cgi_icons, FAVS_ICON_REFRESH);

printf("var ENCODED_RESPONSE_RULE_0 			= 'InitializedButNoCurrentRule';");			//Just an initialized value
printf("var ENCODED_RESPONSE_RULE_1 			= 'AltReplyDirBlank-and-ReplyMsgNameBlank';");		//If alt-reply-dir is blank AND reply-msg-name is blank, then continue with allowing them to reply using any message
printf("var ENCODED_RESPONSE_RULE_2 			= 'AltReplyDirBlank-and-ReplyMsgNameDefined';");	//If alt-reply-dir is blank AND reply-msg-name is specified, then they need to be presented with the legacy window in the iframe (if unresolve) or just allow reply to continue if resolved
printf("var ENCODED_RESPONSE_RULE_3 			= 'AltReplyDirDefined-and-ReplyMsgNameDefined';");	//If alt-reply-dir is specified AND reply-msg-name is specified, then they need to be presented with the legacy window in the iframe (but jump back to standard replies if they cancel that)
printf("var ENCODED_RESPONSE_RULE_4 			= 'AltReplyDirDefined-and-ReplyMsgNameBlank';");	//If alt-reply-dir is specified AND reply-msg-name is blank, then just ignore the alt-reply-dir

printf("var FAVS_DEFAULT_NOFAVSTODISPLAYHTML		= \"%s\";", FAVS_DEFAULT_NOFAVSTODISPLAYHTML);

printf("</script>");


/* Include any global external JS files... */
//printf("<script type=\"text/javascript\" async=\"async\" src=\"%s/~silentm/javascripts/favorites/integ.min.js\"></script>", cgi_base);
printf("<script type=\"text/javascript\" async=\"async\" src=\"%s/~silentm/javascripts/favorites/secur.min.js\"></script>", cgi_base);

printf("<script type=\"text/javascript\" async=\"async\" src=\"%s/~silentm/javascripts/favorites/zoom.min.js\"></script>", cgi_base);
printf("<script type=\"text/javascript\" async=\"async\" src=\"%s/~silentm/javascripts/favorites/winDoc.min.js\"></script>", cgi_base);
printf("<script type=\"text/javascript\" async=\"async\" src=\"%s/~silentm/javascripts/favorites/dialogs.min.js\"></script>", cgi_base);
printf("<script type=\"text/javascript\" async=\"async\" src=\"%s/~silentm/javascripts/favorites/dynamics.min.js\"></script>", cgi_base);

//printf("<script type=\"text/javascript\" async=\"async\" src=\"%s/~silentm/javascripts/favorites/ClassServerIO.js\"></script>", cgi_base);	//prototyping - not yet used

printf("<script type=\"text/javascript\" async=\"async\" src=\"%s/~silentm/javascripts/favorites/favscreen.min.js\"></script>", cgi_base);


printf("<script type=\"text/javascript\">\n");

printf("var safeToHideModalMask = true;");	//flag for letting any routine know whether it can hide the modal mask or not (since multiple things -e.g. menu, panel- may use it)... be sure to set/reset this as needed

printf("function getCurrentDtsec(){");		// Calculate and return the current client-provided dtsec (timestamp in seconds-accuracy... no milliseconds)
printf("	var ret = new Date/1E3|0;");
printf("	return parseInt(ret);");
printf("}\n");//end function
printf("function getCurrentDtsecMS(){");	// Calculate and return the current client-provided dtsec (timestamp in milli-seconds-accuracy)
printf("	var ret = new Date/1E3|0;");
printf("	return parseInt(ret);");
printf("}\n");//end function
printf("function getCurrentDtsec_serverEstimate(){");// Calculate and return the current estimated-server-provided dtsec (timestamp in seconds-accuracy... no milliseconds) NOTE: requires FavScreen-attributes, so must call this after ClassFavScreen instantiates
printf("	var ret = 0;");				//initialize a default return value
printf("	if(typeof FavScreen===\"undefined\"){");
printf("		console.error(\"getCurrentDtsec_serverEstimate() requires a ClassFavScreen instance. Aborting.\");");
printf("		return ret;");
printf("	}");
printf("	var dtsecAtLoad_server = parseInt(FavScreen.get('attrDtsec'));");
printf("	var dtsecAtLoad_client = parseInt(FavScreen.get('attrDtsecJS'));");
printf("	var clientServerOffset = dtsecAtLoad_client - dtsecAtLoad_server;");
printf("	ret = getCurrentDtsec() - clientServerOffset;");	//remember server dtsec is a smaller value than client dtsec; so to get server dtsec, we need to reduce the client dtsec by the difference
printf("	return ret;");
printf("}\n");//end function

printf("function parseAppVersionFromUA(optionalDefaultValueToReturn){");					//Parse and return the native app version from the useragent string - if none found, returns entire UA string or user-specified value
printf("	var ua = navigator.userAgent;");									//user agent string the client gives us
printf("	var expectedName = \"%s\";", FAVS_APP_USERAGENT);							//substring to search UA for
printf("	var expectedNamePositionInUA = ua.indexOf(expectedName);");						//zero-based character position of substring start
printf("	var expectedUuidPositionInUA = ua.indexOf(\"%s\");", FAVS_APP_USERAGENT_UUID_START);			//zero-based character position of our UUID substring start (which would indicate the end of app version info)
printf("	if(expectedNamePositionInUA>-1){");									//if expected substring exists in the UA (then we're rendered in a native app, so need to show app version)
printf("		var expectedNameLength = expectedName.length;");							//figure out the length of substring (so we can know where the version number should be)
printf("		var supposedLocationOfVersionNumber = expectedNamePositionInUA + expectedNameLength + 1;");		//figure out the supposed starting position of the version number (+1 to skip past the "/" delimiter that is common in UA syntax)
printf("		return ua.substring(supposedLocationOfVersionNumber,expectedUuidPositionInUA-1);");			//return what should be just the version number
printf("	}else{");												//else we must be rendered in just a normal browser of some sort, so don't need to show an app version
printf("		if(typeof optionalDefaultValueToReturn === \"undefined\") {");						//if default value to return wasn't specified, then just return the entire user agent string
printf("			return ua;");
printf("		}else{");												//else one was supplied, so return what was specified
printf("			return optionalDefaultValueToReturn;");
printf("		}");
printf("	}");
printf("}");//end functionion parseAppVersionFromUA()

/* The following takes care of setting up and using any of the webview javascript bridge stuff (how the JavaScript and native-app's Objective-C layers communicate with each other) */
if(isLoadedInMobileApp())
	{
	printf("function connectWebViewJavascriptBridge(callback){");			// Handle initializing a webview/javascript bridge... passing along what we want to happen with it, once it's initialized...
	printf("	try{FavScreen.log('verbose',\"connectWebViewJavascriptBridge(): Called.\",false);}catch(err){setTimeout(function(){FavScreen.log('verbose',\"connectWebViewJavascriptBridge(): Called (10 seconds ago).\",false);},10000);}");
	printf("	if(window.WebViewJavascriptBridge){");					//if the bridge exists, then execute whatever routine we specified in the callback argument
	printf("		try{FavScreen.log('verbose',\"connectWebViewJavascriptBridge():  WebViewJavascriptBridge exists and is ready to accept commands.\",false);}catch(err){setTimeout(function(){FavScreen.log('verbose',\"connectWebViewJavascriptBridge():  WebViewJavascriptBridge exists and is ready to accept commands (10 seconds ago).\",false);},10000);}");
	printf("		callback(WebViewJavascriptBridge);");
	printf("	}else{");								//else need to instantiate the bridge, and then (once it's ready) execute whatever routine we specified in the callback argument
	printf("		try{FavScreen.log('verbose',\"connectWebViewJavascriptBridge():  WebViewJavascriptBridge either does not exist or is not ready to accept commands. Listening for it to become ready...\",false);}catch(err){setTimeout(function(){FavScreen.log('verbose',\"connectWebViewJavascriptBridge():  WebViewJavascriptBridge either does not exist or is not ready to accept commands. Listening for it to become ready... (10 seconds ago)\",false);},10000);}");
	printf("		document.addEventListener('WebViewJavascriptBridgeReady', function(){");
	printf("			try{FavScreen.log('verbose',\"connectWebViewJavascriptBridge():   WebViewJavascriptBridge is ready.\",false);}catch(err){setTimeout(function(){FavScreen.log('verbose',\"connectWebViewJavascriptBridge():   WebViewJavascriptBridge is ready (10 seconds ago).\",false);},10000);}");
	printf("			callback(WebViewJavascriptBridge);");
	printf("			},false);");//end addEventListener
	printf("	}");
	printf("}\n");//end function connectWebViewJavascriptBridge()

	printf("if(parseAppVersionFromUA(\"0\") >= \"%s\"){", FAVS_APP_IOS_VER_HASJSBRIDGE);			//if the app version supports automatically pushing updates to the JS layer, then we won't need a timer to keep location data updated
	printf("    connectWebViewJavascriptBridge(function(bridge){");			// Connect to the bridge, with the following stuff to do with it (receiving messages from the native layer)...
	/*		Structure of data to receive from the ObjC side of the bridge...
	 *		 Ex:  "{command:'updateSingleAttributeValue', name:'attr1', value:'thevalue'}"
	 *		 Ex:  "{command:'updateMultipleAttributeValues', arrAttrVals:[ {name:'attr1', value:'thevalue'}, {name:'attr2', value:'anothervalue'}, ... ] }" */
	printf("	bridge.init(function(data, responseCallback){");			//this anonymous function will receive all messages sent from ObjC via [bridge send:(id)data] and [bridge send:(id)data responseCallback:(WVJBResponseCallback)responseCallback]... the responseCallback object will be defined if if ObjC sent the message with a WVJBResponseCallback block.
	printf("		var proceed = true;");
	printf("		var response = \"%s\";", FAVS_RESPONSE_CODE_PROCESSING_START);		//initialize a response string for possibly returning to the native layer in the event of it specifying a callback
	printf("		try{");
	printf("			var oData = eval(\"(\"+data+\")\");");				//try to convert the JSON string from the native app into a JS object of meaningful data
	printf("		}catch(err){");
	printf("			FavScreen.log('error',\"connectWebViewJavascriptBridge(anonymous): Error doing eval operation on data from native app layer...\",false);");
	printf("			FavScreen.log('verbose',\"connectWebViewJavascriptBridge(anonymous): Data received ( \"+data+\" ).\",false);");
	printf("			FavScreen.log('verbose',\"connectWebViewJavascriptBridge(anonymous): Error details ( \"+err.message+\" ).\",false);");
	printf("			proceed = false;");						//set abort flag if eval() failed because crap-data was received (should never happen, given the controlled/tested nature of what the native layer give us)
	printf("		}");
	printf("		if(proceed && (typeof oData.command !== \"undefined\")){");		//if it's ok to proceed and we got a valid command from ObjC...
//	printf("			FavScreen.log('log',\"App-JS Bridge: JS received valid cmd from native app...\",false);");
	printf("			switch(oData.command){");
	printf("				case \"updateSingleAttributeValue\":");				//command to update a single FavScreen custom attribute
	printf("					FavScreen.log('log',\"App-JS Bridge: Cmd to update single attr (\"+oData.name+\") w/value (\"+oData.value+\")...\",false);");
	printf("					if(typeof FavScreen.set(oData.name, oData.value) === \"object\"){");	//note: even if the attribute doesn't actually change from whatever it was previously, the 'set' method should still return an object - can improve resolution of response if needed later
	printf("						response += \"%s\";", FAVS_RESPONSE_CODE_SUCCESSFUL_ATTRSET);
	printf("					}else{");
	printf("						response += \"%s\";", FAVS_RESPONSE_CODE_ERROR_ATTRSET);
	printf("					}");
	printf("					break;");
	printf("				case \"updateMultipleAttributeValues\":");			//command to update multiple FavScreen custom attributes (payload of multiple values should be in an array in this data object)
	printf("					FavScreen.log('log',\"App-JS Bridge: Cmd to update multiple (\"+oData.arrAttrVals.length+\") attrs...\",false);");
	printf("					for(var i=0; i<oData.arrAttrVals.length; i++){");
//	printf("						FavScreen.log('log',\"App-JS Bridge: Updating attr#\"+i+\": \"+oData.arrAttrVals[i].name+\" = '\"+oData.arrAttrVals[i].value+\"'...\",false);");
	printf("						if(typeof FavScreen.set(oData.arrAttrVals[i].name, oData.arrAttrVals[i].value) === \"object\"){");
	printf("							response += \"%s\";", FAVS_RESPONSE_CODE_SUCCESSFUL_ATTRSET);
	printf("						}else{");
	printf("							response += \"%s (\"+oData.arrAttrVals[i].name+\")\";", FAVS_RESPONSE_CODE_ERROR_ATTRSET); //note in the response the attribute that failed to set
	printf("						}");
	printf("					}");//end for
	printf("					break;");
	printf("				default:");
	printf("					FavScreen.log('warn',\"App-JS Bridge: Unknown command from native layer. Not doing anything.\",false);");
	printf("					response += \"%s\";", FAVS_RESPONSE_CODE_ERROR_INVALID_COMMAND);
	printf("					break;");
	printf("			}");//end switch
	printf("		}");//end if valid command received
	printf("		else{"); 								//note: if proceed was false, it should still be alright to go into here.. same difference...
	printf("			FavScreen.log('warn',\"App-JS Bridge: The 'command' member was not received (or invalid JSON) from native app, so don't know what to do. Informing any native-level callback and aborting.\",false);");
	printf("			response += \"%s\";", FAVS_RESPONSE_CODE_ERROR_INVALID_DATA);
	printf("		}");//end else
	printf("		response += \"%s\";", FAVS_RESPONSE_CODE_FINISHED);
	printf("		if(responseCallback){");						//if the ObjC sent the message with a WVJBResponseCallback block... then tell it what it should do
	printf("			responseCallback(\"JS executed and responds with the following: '\"+response+\"'.\");");
	printf("		}");//end if
	printf("		});");//end init with anon fxn definition
	printf("	});");//end anonymous-fxn-arg definition for connectWebViewJavascriptBridge call
	printf("}");//end if appVer check

	//printf("connectWebViewJavascriptBridge( function(bridge){bridge.send();} );");
	}
/* END the webview javascript bridge stuff */

printf("function reloadDocument(){");		// Provide a hook for the native app, so we can trigger it to reload the document with fresh code from the server (on older app versions)... otherwise, just a regular function
if(isLoadedInMobileApp())
	{
	printf("var ver = parseAppVersionFromUA(\"0\");");			//the function might return the raw user agent string, so if it does, just use 0
	printf("if(ver >= \"%s\"){", FAVS_APP_IOS_VER_HASJSBRIDGECANRECEIVE);	//v1.8 of the native iOS app was the first to be able to support this bridge stuff that can receive commands we send from javascript
	printf("	if(typeof FavScreen===\"object\"){");
	printf("		FavScreen.log('log',\"getLocation(): Native app v%s+ is able to trigger a native document reload through the ObjC/JS bridge. This app's version appears to be \"+ver+\". Now sending bridge message...\",false);", FAVS_APP_IOS_VER_HASJSBRIDGECANRECEIVE);
	printf("	}");
	printf("	connectWebViewJavascriptBridge( function(bridge){");		//make a connection to the ObjC/JS bridge, with the intention to do the following...
	printf("		bridge.send('reloadDocument');");			//issue the command to send a message to the native app to reload the document
	printf("		});");
	printf("}else if(ver == \"1.7\"){");					//v1.7 of the native iOS app was had a broken ability to reload the document
	printf("	if(typeof FavScreen===\"object\"){");
	printf("		FavScreen.log('warn',\"reloadDocument(): Native app v1.7 is unable to reload the document due to a known bug. This app's version appears to be \"+ver+\".\",false);");
	printf("	}");
	printf("}else if(ver == \"%s\"){", FAVS_APP_IOS_VER_CANRELOADDOC);	//v1.6 of the native iOS app was the first to be able to trigger a reload (note: may not work in all iOS versions)
	//NOTE: Anything in this branch (really this whole function) would not even get executed if the native app successfully overrides this function, but try to log in case it broke
	printf("	if(typeof FavScreen===\"object\"){");
	printf("		FavScreen.log('warn',\"reloadDocument(): Native app v1.6 should not have executed this log entry. Either the app's version (\"+ver+\") is old or native app has some problem being triggered by this?\",false);");
	printf("	}");
	printf("}");
	}
else
	{
	printf("if(typeof FavScreen===\"object\"){");
	printf("	FavScreen.log('warn',\"reloadDocument(): Document can not be programatically reloaded.\",false);");
	printf("}else{");
	printf("	console.warn(\"reloadDocument(): Document can not be programatically reloaded.\");");
	printf("}");
	}
printf("}\n");//end function reloadDocument()

printf("function hideNativeSpinner(delay){");
if(isLoadedInMobileApp())
	{
	printf("var ver = parseAppVersionFromUA(\"0\");");				//the function might return the raw user agent string, so if it does, just use 0
	printf("if(ver >= \"%s\"){", FAVS_APP_IOS_VER_JSCANCONTROLNATIVESPINNER);	//v1.9.5 of the native iOS app was the first to be able to support this bridge stuff that can receive commands we send from javascript
	printf("	if(typeof FavScreen === 'object') {");								//check for a valid initial-loaded timestamp attribute in the FavScreen object...
	printf("		if(FavScreen.get('attrFinishedInitialLoading_timestamp') == 0) {");				//if it looks like the main application is not yet finished loading, then don't hide the spinner
	printf("			if(typeof FavScreen===\"undefined\"){console.info(instanceName+\".hide() is delaying execution due to incomplete initial load.\");}else{FavScreen.log('info',instanceName+\".hide() is delaying execution due to incomplete initial load.\",true);}");
	printf("			setTimeout(function(){hideNativeSpinner();}, 3000);");
	printf("		}");
	printf("	}");
	printf("	if(typeof delay === 'undefined') {");
	printf("		if(typeof FavScreen===\"object\"){");
	printf("			FavScreen.log('log',\"hideNativeSpinner(): Native app v%s+ is able to accept native-spinner commands through the ObjC/JS bridge. This app's version appears to be \"+ver+\". Now sending bridge message to hide the spinner...\",false);", FAVS_APP_IOS_VER_JSCANCONTROLNATIVESPINNER);
	printf("		}");
	printf("		connectWebViewJavascriptBridge( function(bridge){");			//make a connection to the ObjC/JS bridge, with the intention to do the following...
	printf("			bridge.send('hideNativeSpinner');");					//issue the command to send a message to the native app to hide its loading spinner
	printf("			});");
	printf("	} else {");
	printf("		delay = parseInt(delay);");
	printf("		if(typeof FavScreen===\"object\"){");
	printf("			FavScreen.log('log',\"hideNativeSpinner(): Native app v%s+ is able to accept native-spinner commands through the ObjC/JS bridge. This app's version appears to be \"+ver+\". Will send bridge message to hide the spinner in \"+delay+\"ms...\",false);", FAVS_APP_IOS_VER_JSCANCONTROLNATIVESPINNER);
	printf("		}");
	printf("		setTimeout(function(){");
	printf("			connectWebViewJavascriptBridge( function(bridge){");			//make a connection to the ObjC/JS bridge, with the intention to do the following...
	printf("				bridge.send('hideNativeSpinner');");					//issue the command to send a message to the native app to hide its loading spinner
	printf("				});");
	printf("			}, delay);");//end setTimeout
	printf("	}");
	printf("}else{");
	printf("	if(typeof FavScreen===\"object\"){");
	printf("		FavScreen.log('info',\"hideNativeSpinner(): Native app v%s+ is NOT able to accept native-spinner commands through the ObjC/JS bridge. This app's version appears to be \"+ver+\".\",false);", FAVS_APP_IOS_VER_JSCANCONTROLNATIVESPINNER);
	printf("	}");
	printf("}");
	}
else
	{
	printf("	FavScreen.log('info',\"hideNativeSpinner(): Not loaded in native app, so nothing to do here.\",false);");
	}
printf("}\n");//end function hideNativeSpinner()

printf("function showNativeSpinner(){");
if(isLoadedInMobileApp())
	{
	printf("var ver = parseAppVersionFromUA(\"0\");");				//the function might return the raw user agent string, so if it does, just use 0
	printf("if(ver >= \"%s\"){", FAVS_APP_IOS_VER_JSCANCONTROLNATIVESPINNER);	//v1.9.5 of the native iOS app was the first to be able to support this bridge stuff that can receive commands we send from javascript
	printf("	if(typeof FavScreen===\"object\"){");
	printf("		FavScreen.log('log',\"showNativeSpinner(): Native app v%s+ is able to accept native-spinner commands through the ObjC/JS bridge. This app's version appears to be \"+ver+\". Now sending bridge message to show the spinner...\",false);", FAVS_APP_IOS_VER_JSCANCONTROLNATIVESPINNER);
	printf("	}");
	printf("	connectWebViewJavascriptBridge( function(bridge){");			//make a connection to the ObjC/JS bridge, with the intention to do the following...
	printf("		bridge.send('showNativeSpinner');");					//issue the command to send a message to the native app to show its loading spinner
	printf("		});");
	printf("}else{");
	printf("	if(typeof FavScreen===\"object\"){");
	printf("		FavScreen.log('info',\"showNativeSpinner(): Native app v%s+ is NOT able to accept native-spinner commands through the ObjC/JS bridge. This app's version appears to be \"+ver+\".\",false);", FAVS_APP_IOS_VER_JSCANCONTROLNATIVESPINNER);
	printf("	}");
	printf("}");
	}
else
	{
	printf("if(typeof FavScreen===\"object\"){");
	printf("	FavScreen.log('info',\"showNativeSpinner(): Not loaded in native app, so nothing to do here.\",false);");
	printf("}");
	}
printf("}\n");//end function showNativeSpinner()

printf("function getLocation(){");										// The function that triggers the native app to set geolocation attributes
if(isLoadedInMobileApp())
	{
	printf("var ver = parseAppVersionFromUA(\"0\");");			//the function might return the raw user agent string, so if it does, just use 0
	printf("if(ver >= \"%s\"){", FAVS_APP_IOS_VER_HASJSBRIDGECANRECEIVE);	//v1.8 of the native iOS app was the first to be able to support this bridge stuff that can receive commands we send from javascript
	printf("	if(typeof FavScreen===\"object\"){");
	printf("		FavScreen.log('log',\"getLocation(): Native app v%s+ is able to trigger a native location update through the ObjC/JS bridge. This app's version appears to be \"+ver+\". Now sending bridge message...\",false);", FAVS_APP_IOS_VER_HASJSBRIDGECANRECEIVE);
	printf("	}");
	printf("	connectWebViewJavascriptBridge( function(bridge){");		//make a connection to the ObjC/JS bridge, with the intention to do the following...
	printf("		bridge.send('getLocation');");				//issue the command to send a message to the native app to perform a native location acquisition (it will then populate our attributes)
	printf("		});");
	printf("}else if(ver == \"1.7\"){");					//v1.7 of the native iOS app was had a broken ability to reload the document
	printf("	if(typeof FavScreen===\"object\"){");
	printf("		FavScreen.log('warn',\"getLocation(): Native app v1.7 is unable to trigger a native location update due to a known bug. This app's version appears to be \"+ver+\".\",false);");
	printf("	}");
	printf("}else if(ver == \"%s\"){", FAVS_APP_IOS_VER_NATIVEGEOLOC);	//v1.6 of the native iOS app was the first to be able to trigger a reload (note: may not work in all iOS versions)
	//NOTE: Anything in this branch (really this whole function) would not even get executed if the native app successfully overrides this function, but try to log in case it broke
	printf("	if(typeof FavScreen===\"object\"){");
	printf("		FavScreen.log('warn',\"getLocation(): Native app v1.6 should not have executed this log entry. Either this app's version (\"+ver+\") is old or native app has some problem being triggered by this?\",false);");
	printf("	}");
	printf("}");
	}
else
	{
	printf("if(typeof FavScreen===\"object\"){");
	printf("	FavScreen.log('warn',\"getLocation(): This function should only be called on an app-enabled device.\",false);");
	printf("}else{");
	printf("	console.warn(\"getLocation(): This function should only be called on an app-enabled device.\");");
	printf("}");
	}
printf("}\n");//end function getLocation()

printf("var geolocationUpdateIntervalHandle = false;\n");							// Declare a global for a geolocation-updating setInterval() handle
printf("function handleGeolocationAcquisition(updateIntervalSecs){");						// Handle populating/updating the geolocation data
printf("	var doSetInterval, updateIntervalMillisecs;");
printf("	if(typeof updateIntervalSecs===\"undefined\"");								//if no argument was provided, just default to doing a one-time geolocation update (wihout setting an interval)
printf("	   || isNaN(updateIntervalSecs)){");									//   or an argument was provided, but doesn't seem to be a valid number, default to doing a one-time geolocation update
printf("		if(typeof FavScreen===\"object\"){FavScreen.log('log',\"handleGeolocationAcquisition(): No/Invalid argument provided (\"+updateIntervalSecs+\"). Not going to set interval.\",true);}");
printf("		doSetInterval = false;");
printf("	}else{");												//else, apparently a valid argument was provided, so set (or reset) the interval for updating geolocation data
printf("		if(geolocationUpdateIntervalHandle!=false){");								//if an update interval has been set, then we need to clear it first
printf("			clearInterval(geolocationUpdateIntervalHandle);");							//do a standard clearing of the interval's handle
printf("			geolocationUpdateIntervalHandle = false;");								//just to be safe, also re-initialize it
printf("		}");
printf("		doSetInterval = true;");
printf("		updateIntervalMillisecs = parseInt(updateIntervalSecs)*1000;");						//figure out how many milliseconds, since that's the unit of measure that setInterval requires
printf("		if(typeof FavScreen===\"object\"){FavScreen.log('log',\"handleGeolocationAcquisition(): Update-interval will be set to \"+updateIntervalMillisecs+\" milliseconds.\",true);}");
printf("	}");//end determination of handling interval
printf("	if(isLoadedInMobileApp()){");										//if loaded in the mobile app... (DEV-NOTE: later adapt this to support Android, or make the Android app work with the getLocation method?)
printf("		var ver = parseAppVersionFromUA(\"0\");");								//the function might return the raw user agent string, so if it does, just use 0
printf("		if(ver >= \"%s\"){", FAVS_APP_IOS_VER_NATIVEGEOLOC);							//if the apple app version supports native geolocation, call the function to trigger that in addition to HTML5
printf("			if(ver >= \"%s\"){", FAVS_APP_IOS_VER_HASJSBRIDGE);								//if the native geolocation data can be sent via the JS bridge, call the function that triggers all that in the native layer
printf("				if(typeof FavScreen===\"object\"){FavScreen.log('log',\"handleGeolocationAcquisition(): Detected native Apple iOS app supports passing native geolocation via JS-bridge, calling getLocation().\",false);}");
printf("				getLocation();");
printf("				if(doSetInterval){geolocationUpdateIntervalHandle=setInterval(function(){getLocation();},updateIntervalMillisecs);}");
printf("			}else{");												//else ver 1.6 was a weird version where native wasn't really being passed to the JS right, so fall back to HTML method (even though it technically did native geolocation)
printf("				if(typeof FavScreen===\"object\"){FavScreen.log('log',\"handleGeolocationAcquisition(): Detected native Apple iOS app supports native geolocation but can't pass reliably, so calling setGeoLocationAttributes().\",false);}");
printf("				setGeoLocationAttributes();");
printf("				if(doSetInterval){geolocationUpdateIntervalHandle=setInterval(function(){setGeoLocationAttributes();},updateIntervalMillisecs);}");
printf("			}");
printf("		}");//end test for v1.6 / v1.7
printf("		else{");												//else exclude html5 method from newer apps, to prevent nagging "can we use your location" prompt.. but must use it prior to v1.6
printf("			if(typeof FavScreen===\"object\"){FavScreen.log('log',\"handleGeolocationAcquisition(): Calling setGeoLocationAttributes().\",false);}");
printf("			setGeoLocationAttributes();");
printf("			if(doSetInterval){geolocationUpdateIntervalHandle=setInterval(function(){setGeoLocationAttributes();},updateIntervalMillisecs);}");
printf("		}");
printf("	}else{");												//else not loaded in the mobile app, so use HTML5 method
printf("		if(typeof FavScreen===\"object\"){FavScreen.log('log',\"handleGeolocationAcquisition(): Detected browser may only support HTML5 geolocation, calling setGeoLocationAttributes().\",false);}");
printf("		setGeoLocationAttributes();");
printf("		if(doSetInterval){geolocationUpdateIntervalHandle=setInterval(function(){setGeoLocationAttributes();},updateIntervalMillisecs);}");
printf("	}");//end determination of which geolocation method to use
printf("}\n");//end function handleGeolocationAcquisition()

printf("function forceHideModalMask() {");
//printf("	var ret = false;");
printf("	var node_modalMask = document.getElementsByClassName(\"yui3-widget-mask\")[0];");
//printf("	if(node_modalMask.style.display != \"block\"){");		//if mask is visible, hide it and restore its position
printf("		node_modalMask.style.display = \"none\";");
printf("		node_modalMask.style.top = \"0px\";");
//printf("		ret = true;");
//printf("	}");
//printf("	return ret;");
printf("}\n");//end function forceHideModalMask()

/* Define our loading-spinner stuff... (goes here before the ClassFavScreen stuff, so it can call these functions) */
printf("function ClassSpinner(instanceName){");
printf("	this.timeLastShown = 0;");
printf("	this.handleForSetTimeout = undefined;");
printf("	this.handleForSetInterval = undefined;");
printf("	this.initialized = false;");
printf("	this.isVisible = false;");
printf("	var yuiPanel;");
printf("	var timeoutCheckIntervalSeconds = 3;");									//configure how often the timeout checking routine should do its thing
printf("	var maximumShowSeconds = 9;");										//configure the maximum number of seconds you want the spinner to show before it's automatically hidden
printf("	var minimumShowMilliseconds = 800;");									//configure the minimum amount of time the spinner should show (useful if you don't want it just quickly flashing)
printf("	if(parseAppVersionFromUA(\"0\") < \"%s\"){", FAVS_APP_IOS_VER_JSCANCONTROLNATIVESPINNER);		//v1.9.5 of the native iOS app was the first to be able to support this bridge stuff that can receive commands we send from javascript
printf("		var node_spinner_wrapper = document.createElement('div');");
printf("		var b = document.body || document.documentElement;");							//get a reference to the document body, so we can then use it to test for CSS3 animation capability
printf("		if(typeof b.style['animation'] === 'string' || typeof b.style['-webkit-animation'] === 'string'){");	//if the browser/client supports CSS3 animation, then use that instead of loading the animated GIF, else load the GIF
printf("			var node_spinner = document.createElement('div');");
printf("			node_spinner.className = \"spinner\";");
printf("			for(var i=0; i<8; i++){");
printf("				var node_spinner_line = document.createElement('div');");
printf("				node_spinner_line.id = \"spinnerline\" + i;");
printf("				node_spinner.appendChild(node_spinner_line);");
printf("			}");
printf("			node_spinner_wrapper.appendChild(node_spinner);");
printf("		}else{");												//else no CSS3 animateion support, so fall back to the animated GIF
printf("			var node_img = document.createElement('img');");
printf("			node_img.src = \"%s/loading.gif\";", cgi_icons);
printf("			if(navigator.userAgent.indexOf(\"IE 8\")>-1 || navigator.userAgent.indexOf(\"IE 7\")>-1 || navigator.userAgent.indexOf(\"IE 6\")>-1){");
printf("				node_img.style.filter = \"progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='#00000000',endColorstr='#00000000')\";"); //old IE must simulate rgba using gradient
printf("			}else{");
printf("				node_img.style.backgroundColor = \"rgba(0,0,0,0)\";");
printf("			}");
printf("			node_img.style.border = 0;");
printf("			node_spinner_wrapper = node_img;");
printf("		}");
printf("		YUI().use(\"panel\", function(Y){");
printf("			yuiPanel = new Y.Panel({");
printf("				headerContent	: null,");
printf("				footerContent	: null,");
printf("				buttons		: null,");
printf("				srcNode		: node_spinner_wrapper,");
printf("				width		: 128,");
printf("				maxWidth	: 128,");
printf("				zIndex		: 999,");
printf("				centered	: true,");
printf("				modal		: true,");
printf("				visible		: false,");
printf("				render		: true");
printf("				});");//end panel
printf("			yuiPanel.after('init', function(e){");
printf("				this.get('contentBox')._node.className = \"\";");					//cancel the default YUI SAM skinning for the IMG node
printf("				this.get('boundingBox')._node.style.outline = \"none\";");				//get rid of the faint outline on the DIV around the loading spinner IMG
printf("				eval(instanceName+\".initialized = true;\");");
printf("				});");//end after-init
printf("			yuiPanel.after('visibleChange', function(e){");
printf("				if(this.get('visible')){");								//if the panel is now visible, then...
printf("					if(typeof FavScreen===\"undefined\"){console.log(instanceName+\" now visible.\");}else{FavScreen.log('log',instanceName+\" now visible.\",true);}");
printf("				}else{");										//else the panel is now hidden, so...
printf("					if(typeof FavScreen===\"undefined\"){console.log(instanceName+\" now hidden.\");}else{FavScreen.log('log',instanceName+\" now hidden.\",true);}");
printf("				}");//end if-else
printf("				});");//end after-visibleChange
printf("			});");//end yui
printf("		this.show = function(){");
printf("			if(typeof yuiPanel!==\"undefined\" && !yuiPanel.get('visible')){");				//ensure we don't try to show the spinner panel if it's already been shown
printf("				safeToHideModalMask = false;");								//set the flag for not allowing customized modal mask hiding, since this panel requires it to be preserved
printf("				yuiPanel.show();");
printf("				this.timeLastShown = Date.now();");
printf("				clearInterval(this.handleForSetInterval);");
printf("				this.handleForSetInterval = undefined;");
printf("				this.handleForSetInterval = setInterval(function(){eval(instanceName+\".startTimeoutChecking();\");}, timeoutCheckIntervalSeconds*1000);");
printf("				this.isVisible = true;");
printf("				return true;");
printf("			}else{return false;}");
printf("			};");//end method definition for show()
printf("		this.showAfterDelay = function(intDelayMs){");
printf("			if(typeof intDelayMs===\"undefined\" || isNaN(intDelayMs)){");					//if no delay argument was provided or it is not a valid type, use a default delay...
printf("				intDelayMs = 200;");									//specify default delay in milliseconds
printf("			}");
printf("			if(typeof FavScreen===\"undefined\"){console.log(instanceName+\".showAfterDelay(\"+intDelayMs+\") method invoked...\");}else{FavScreen.log('log',instanceName+\".showAfterDelay(\"+intDelayMs+\") method invoked...\",true);}");
printf("			this.handleForSetTimeout = setTimeout(function(){");
printf("				if(!yuiPanel.get('visible')){");
printf("					if(typeof FavScreen===\"undefined\"){console.log(instanceName+\".showAfterDelay(\"+intDelayMs+\") method now becoming active. Showing spinner.\");}else{FavScreen.log('log',instanceName+\".showAfterDelay(\"+intDelayMs+\") method now becoming active. Showing spinner.\",true);}");
printf("					safeToHideModalMask = false;");							//set the flag for not allowing customized modal mask hiding, since this panel requires it to be preserved
printf("					yuiPanel.show();");
printf("					clearInterval(Spinner.handleForSetInterval);");
printf("					eval(instanceName+\".handleForSetInterval = undefined;\");");
printf("					eval(instanceName+\".timeLastShown = Date.now();\");");
printf("					eval(instanceName+\".handleForSetInterval = setInterval(function(){\"+instanceName+\".startTimeoutChecking();}, timeoutCheckIntervalSeconds*1000);\");");
printf("				}");//end if
printf("				},intDelayMs);");
printf("			};");//end method definition for showAfterDelay()
printf("		this.hide = function(intDelayMs){");
printf("			if(typeof FavScreen === 'object') {");								//check for a valid initial-loaded timestamp attribute in the FavScreen object...
printf("				if(FavScreen.get('attrFinishedInitialLoading_timestamp') == 0) {");				//if it looks like the main application is not yet finished loading, then don't hide the spinner
printf("					if(typeof FavScreen===\"undefined\"){console.info(instanceName+\".hide() is delaying execution due to incomplete initial load.\");}else{FavScreen.log('info',instanceName+\".hide() is delaying execution due to incomplete initial load.\",true);}");
printf("					setTimeout(function(){Spinner.hide();}, 3000);");
printf("				}");
printf("			}");
printf("			if(this.handleForSetTimeout){");								//if showAfterDelay has been set, cancel it
printf("				if(typeof FavScreen===\"undefined\"){console.log(instanceName+\".hide() is cancelling handleForSetTimeout.\");}else{FavScreen.log('log',instanceName+\".hide() is cancelling handleForSetTimeout.\",false);}");
printf("				clearTimeout(this.handleForSetTimeout);");
printf("				this.handleForSetTimeout = undefined;");
printf("			}");
printf("			if(Boolean(this.handleForSetInterval)){");							//if we're currently checking for automatic timeout/hide, cancel it
printf("				clearInterval(this.handleForSetInterval);");
printf("				this.handleForSetInterval = undefined;");
printf("			}");
printf("			if(typeof yuiPanel!==\"undefined\" && yuiPanel.get('visible')){");				//ensure we don't try to hide the spinner panel if it's already been hidden
//printf("				console.log(instanceName+\".hide method invoked.\");");
printf("				safeToHideModalMask = true;");								//reset the flag for allowing customized modal mask hiding, since this panel no longer requires it to be preserved
printf("				if(typeof intDelayMs===\"undefined\" || isNaN(intDelayMs)){");				//if no delay argument was provided, go ahead and hide the spinner
printf("					if(minimumShowMilliseconds>50){");							//if min config'd time is enough to mean anything, set a hide on delay for that time
printf("						setTimeout(function(){");
printf("							yuiPanel.hide();");
printf("							eval(instanceName+\".isVisible = false;\");");
printf("							}, minimumShowMilliseconds);");
printf("					}else{");										//else config'd time is meaningless, so just hide immediately (should never happen)
printf("						yuiPanel.hide();");
printf("						this.isVisible = false;");
printf("					}");
printf("				}");
printf("				else if(parseInt(intDelayMs)>50){");								//else-if delay argument is substantially long enough to have a chance of doing anything, set it to hide on delay
printf("					setTimeout(function(){");
printf("						yuiPanel.hide();");
printf("						eval(instanceName+\".isVisible = false;\");");
printf("						}, parseInt(intDelayMs));");
printf("				}");
printf("				else{");											//else all other unforseen cases, just hide it immediately
printf("					yuiPanel.hide();");
printf("					this.isVisible = false;");
printf("				}");
printf("				return true;");
printf("			}else{return false;}");
printf("			};");//end method definition for hide()
		//else native app that supports native spinner...
printf("	}else{");
printf("		this.show = function(){");
printf("			showNativeSpinner();");
printf("			this.timeLastShown = Date.now();");
printf("			clearInterval(this.handleForSetInterval);");
printf("			this.handleForSetInterval = undefined;");
printf("			this.handleForSetInterval = setInterval(function(){eval(instanceName+\".startTimeoutChecking();\");}, timeoutCheckIntervalSeconds*1000);");
printf("			this.isVisible = true;");
printf("			return true;");
printf("			};");//end method definition for show()
printf("		this.showAfterDelay = function(intDelayMs){");
printf("			if(typeof intDelayMs===\"undefined\" || isNaN(intDelayMs)){");					//if no delay argument was provided or it is not a valid type, use a default delay...
printf("				intDelayMs = 200;");									//specify default delay in milliseconds
printf("			}");
printf("			if(typeof FavScreen===\"undefined\"){console.log(instanceName+\".showAfterDelay(\"+intDelayMs+\") method invoked...\");}else{FavScreen.log('log',instanceName+\".showAfterDelay(\"+intDelayMs+\") method invoked...\",true);}");
printf("			this.handleForSetTimeout = setTimeout(function(){");
printf("				if(typeof FavScreen===\"undefined\"){console.log(instanceName+\".showAfterDelay(\"+intDelayMs+\") method now becoming active. Showing spinner.\");}else{FavScreen.log('log',instanceName+\".showAfterDelay(\"+intDelayMs+\") method now becoming active. Showing spinner.\",true);}");
printf("				safeToHideModalMask = false;");							//set the flag for not allowing customized modal mask hiding, since this panel requires it to be preserved
printf("				showNativeSpinner();");
printf("				clearInterval(Spinner.handleForSetInterval);");
printf("				eval(instanceName+\".handleForSetInterval = undefined;\");");
printf("				eval(instanceName+\".timeLastShown = Date.now();\");");
printf("				eval(instanceName+\".handleForSetInterval = setInterval(function(){\"+instanceName+\".startTimeoutChecking();}, timeoutCheckIntervalSeconds*1000);\");");
printf("				},intDelayMs);");
printf("			};");//end method definition for showAfterDelay()
printf("		this.hide = function(intDelayMs){");
printf("			if(typeof FavScreen === 'object') {");								//check for a valid initial-loaded timestamp attribute in the FavScreen object...
printf("				if(FavScreen.get('attrFinishedInitialLoading_timestamp') == 0) {");				//if it looks like the main application is not yet finished loading, then don't hide the spinner
printf("					if(typeof FavScreen===\"undefined\"){console.info(instanceName+\".hide() is delaying execution due to incomplete initial load.\");}else{FavScreen.log('info',instanceName+\".hide() is delaying execution due to incomplete initial load.\",true);}");
printf("					setTimeout(function(){Spinner.hide();}, 3000);");
printf("				}");
printf("			}");
printf("			if(this.handleForSetTimeout){");								//if showAfterDelay has been set, cancel it
printf("				if(typeof FavScreen===\"undefined\"){console.log(instanceName+\".hide() is cancelling handleForSetTimeout.\");}else{FavScreen.log('log',instanceName+\".hide() is cancelling handleForSetTimeout.\",false);}");
printf("				clearTimeout(this.handleForSetTimeout);");
printf("				this.handleForSetTimeout = undefined;");
printf("			}");
printf("			if(Boolean(this.handleForSetInterval)) {");								//if we're currently checking for automatic timeout/hide, cancel it
printf("				clearInterval(this.handleForSetInterval);");
printf("				this.handleForSetInterval = undefined;");
printf("			}");
//printf("			console.log(instanceName+\".hide method invoked.\");");
printf("			safeToHideModalMask = true;");								//reset the flag for allowing customized modal mask hiding, since this panel no longer requires it to be preserved
printf("			if(typeof intDelayMs===\"undefined\" || isNaN(intDelayMs)){");				//if no delay argument was provided, go ahead and hide the spinner
printf("				if(minimumShowMilliseconds>50){");							//if min config'd time is enough to mean anything, set a hide on delay for that time
printf("					setTimeout(function(){");
printf("						hideNativeSpinner();");
printf("						eval(instanceName+\".isVisible = false;\");");
printf("						}, minimumShowMilliseconds);");
printf("				}else{");										//else config'd time is meaningless, so just hide immediately (should never happen)
printf("					hideNativeSpinner();");
printf("					this.isVisible = false;");
printf("				}");
printf("			}");
printf("			else if(parseInt(intDelayMs)>50){");								//else-if delay argument is substantially long enough to have a chance of doing anything, set it to hide on delay
printf("				setTimeout(function(){");
printf("					hideNativeSpinner();");
printf("					eval(instanceName+\".isVisible = false;\");");
printf("					}, parseInt(intDelayMs));");
printf("			}");
printf("			else{");											//else all other unforseen cases, just hide it immediately
printf("				hideNativeSpinner();");
printf("				this.isVisible = false;");
printf("			}");
printf("			return true;");
printf("			};");//end method definition for hide()
printf("	}");
printf("	this.startTimeoutChecking = function(){");								//starts and handles timeout checking
printf("		var currentTime = Date.now();");
printf("		var secondsSinceShown = parseInt((currentTime-this.timeLastShown)/1000);");
printf("		if(typeof FavScreen===\"undefined\"){console.log(\"Spinner shown for \"+secondsSinceShown+\" seconds\");}else{FavScreen.log('info',\"Spinner shown for \"+secondsSinceShown+\" seconds\",true);}");
printf("		if(secondsSinceShown >= maximumShowSeconds){");
//printf("			var node_span = document.createElement('span');");
//printf("			var node_text = document.createTextNode('System is slow');");
//printf("			node_span.appendChild(node_text);");
printf("			if(typeof FavScreen===\"object\"){FavScreen.log('warn', \"Spinner will now automatically hide itself. Something probably failed to explicitly hide it, or server/network is very slow.\", true);}");
printf("			else{console.warn(\"Spinner will now automatically hide itself. Something probably failed to explicitly hide it.\");}");
printf("			try {");
printf("				clearInterval(this.handleForSetInterval);");
printf("				this.handleForSetInterval = undefined;");
printf("				this.hide();");
printf("			} catch(err) {");
printf("				if(typeof FavScreen===\"object\"){FavScreen.log('error', \"Spinner auto-hide failed (\"+err.message+\").\", true);}");
printf("				else{console.error(\"Spinner auto-hide failed (\"+err.message+\").\");}");
printf("			}");
printf("		}else{return false;}");
printf("		};");//end method definition for startTimeoutChecking()
printf("}\n");//end function ClassSpinner()
printf("var Spinner = new ClassSpinner(\"Spinner\");\n");

/* Define our custom notification modal panel stuff... */
/* NOTE: to convert rgba to MSIE: http://kimili.com/journal/rgba-hsla-css-generator-for-internet-explorer */
printf("function ClassModalNotification(instanceName, strNotificationText){");
printf("	if(typeof strNotificationText != \"string\"){");
printf("		console.warn(\"Creating an instance of ClassModalNotification requires a string argument (provided was: '\"+strNotificationText+\"').\");");
printf("		return false;");
printf("	}");
printf("	var yuiPanel;");
printf("	this.initialized = false;");
printf("	this.isVisible = false;");
printf("	YUI().use(\"panel\", function(Y){");
printf("		switch(strNotificationText.toString().toLowerCase()){");
printf("			case \"ok\":");
printf("				var node_div = document.createElement('div');");
printf("				node_div.innerHTML = \"OK\";");
printf("				node_div.style.font = \"normal normal bold 72px arial,sans-serif\";");		//CSS font shorthand -->  font-style font-variant font-weight font-size/line-height|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit
printf("				node_div.style.color = \"#ffffff\";");						//text color
printf("				if(YUI && (YUI.Env.UA.ie>0 && YUI.Env.UA.ie<9)){");
printf("					node_div.style.filter = \"progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='#cc80C880',endColorstr='#cc80C880')\";");
printf("				}else{");
printf("					node_div.style.backgroundColor = \"rgba(128,200,128,.9)\";");		//background color (slightly transparent green)
printf("				}");
printf("				node_div.style.width = \"60%%\";");
printf("				break;");
printf("			case \"saved\":");
printf("				var node_div = document.createElement('div');");
printf("				node_div.innerHTML = \"Saved\";");
printf("				node_div.style.font = \"normal normal bold 72px arial,sans-serif\";");		//CSS font shorthand -->  font-style font-variant font-weight font-size/line-height|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit
printf("				node_div.style.color = \"#ffffff\";");						//text color
printf("				if(YUI && (YUI.Env.UA.ie>0 && YUI.Env.UA.ie<9)){");
printf("					node_div.style.filter = \"progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='#cc7474E6',endColorstr='#cc7474E6')\";");
printf("				}else{");
printf("					node_div.style.backgroundColor = \"rgba(116,166,230,.85)\";");		//background color (slightly transparent blue)
printf("				}");
printf("				node_div.style.width = \"85%%\";");
printf("				break;");
printf("			case \"launchfailure\":");
printf("				var html1 = \"Send Failed\";");
printf("				var html2 = \"<div style='font:normal normal bold 30px arial,sans-serif'>Try Again or<br>Wait &amp; Try Again</div>\";");
printf("				var node_div = document.createElement('div');");
printf("				node_div.innerHTML = html1 + html2;");
printf("				node_div.style.font = \"normal normal bold 48px arial,sans-serif\";");		//CSS font shorthand -->  font-style font-variant font-weight font-size/line-height|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit
printf("				node_div.style.color = \"#ffffff\";");						//text color
printf("				if(YUI && (YUI.Env.UA.ie>0 && YUI.Env.UA.ie<9)){");
printf("					node_div.style.filter = \"progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='#D8695ABE',endColorstr='#D8695ABE')\";");
printf("				}else{");
printf("					node_div.style.backgroundColor = \"rgba(105,90,190,.85)\";");		//background color (slightly transparent purple-ish blue)
printf("				}");
printf("				node_div.style.width = \"85%%\";");
printf("				break;");
/*
printf("			case \"authenticationfailure\":");
printf("				var html1 = \"Session Not Authenticated\";");
printf("				var html2 = \"<div style='font:normal normal bold 30px arial,sans-serif'>Close &amp; Re-open<br>The App</div>\";");
printf("				var node_div = document.createElement('div');");
printf("				node_div.innerHTML = html1 + html2;");
printf("				node_div.style.font = \"normal normal bold 40px arial,sans-serif\";");		//CSS font shorthand -->  font-style font-variant font-weight font-size/line-height|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit
printf("				node_div.style.color = \"#ffffff\";");						//text color
printf("				if(YUI && (YUI.Env.UA.ie>0 && YUI.Env.UA.ie<9)){");
printf("					node_div.style.filter = \"progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='#D8695ABE',endColorstr='#D8695ABE')\";");
printf("				}else{");
printf("					node_div.style.backgroundColor = \"rgba(105,90,190,.85)\";");		//background color (slightly transparent purple-ish blue)
printf("				}");
printf("				node_div.style.width = \"85%%\";");
printf("				break;");
*/
printf("			case \"connectionlost\":");
printf("				var html1 = \"Connection Lost\";");
printf("				var html2 = \"<div style='font:normal normal bold 26px arial,sans-serif'>Close &amp; Reopen App</div>\";");
printf("				var node_div = document.createElement('div');");
printf("				node_div.innerHTML = html1 + html2;");
printf("				node_div.style.font = \"normal normal bold 34px arial,sans-serif\";");		//CSS font shorthand -->  font-style font-variant font-weight font-size/line-height|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit
printf("				node_div.style.color = \"#ffffff\";");						//text color
printf("				if(YUI && (YUI.Env.UA.ie>0 && YUI.Env.UA.ie<9)){");
printf("					node_div.style.filter = \"progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='#D8695ABE',endColorstr='#D8695ABE')\";");
printf("				}else{");
printf("					node_div.style.backgroundColor = \"rgba(105,90,190,.85)\";");		//background color (slightly transparent purple-ish blue)
printf("				}");
printf("				node_div.style.width = \"95%%\";");
printf("				break;");
printf("			case \"messageunavailable\":");
printf("				var node_div = document.createElement('div');");
printf("				node_div.innerHTML = \"Message Unavailable\";");
printf("				node_div.style.font = \"normal normal bold 36px arial,sans-serif\";");		//CSS font shorthand -->  font-style font-variant font-weight font-size/line-height|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit
printf("				node_div.style.color = \"#ffffff\";");						//text color
printf("				if(YUI && (YUI.Env.UA.ie>0 && YUI.Env.UA.ie<9)){");
printf("					node_div.style.filter = \"progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='#D8695ABE',endColorstr='#D8695ABE')\";");
printf("				}else{");
printf("					node_div.style.backgroundColor = \"rgba(105,90,190,.85)\";");		//background color (slightly transparent purple-ish blue)
printf("				}");
printf("				node_div.style.width = \"85%%\";");
printf("				break;");
printf("			case \"serviceunavailable\":");
printf("				var html1 = \"Service Unavailable\";");
printf("				var html2 = \"<div style='font:normal normal bold 30px arial,sans-serif'>Try Again or<br>Wait &amp; Try Again</div>\";");
printf("				var node_div = document.createElement('div');");
printf("				node_div.innerHTML = html1 + html2;");
printf("				node_div.style.font = \"normal normal bold 40px arial,sans-serif\";");		//CSS font shorthand -->  font-style font-variant font-weight font-size/line-height|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit
printf("				node_div.style.color = \"#ffffff\";");						//text color
printf("				if(YUI && (YUI.Env.UA.ie>0 && YUI.Env.UA.ie<9)){");
printf("					node_div.style.filter = \"progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='#D8695ABE',endColorstr='#D8695ABE')\";");
printf("				}else{");
printf("					node_div.style.backgroundColor = \"rgba(105,90,190,.85)\";");		//background color (slightly transparent purple-ish blue)
printf("				}");
printf("				node_div.style.width = \"85%%\";");
printf("				break;");
printf("			case \"geolocationprogress\":");
printf("				var node_div = document.createElement('div');");
printf("				node_div.innerHTML = \"Location Updated\";");
printf("				node_div.style.font = \"normal normal bold 36px arial,sans-serif\";");		//CSS font shorthand -->  font-style font-variant font-weight font-size/line-height|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit
printf("				node_div.style.color = \"#ffffff\";");						//text color
printf("				if(YUI && (YUI.Env.UA.ie>0 && YUI.Env.UA.ie<9)){");
printf("					node_div.style.filter = \"progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='#D8695ABE',endColorstr='#D8695ABE')\";");
printf("				}else{");
printf("					node_div.style.backgroundColor = \"rgba(105,90,190,.85)\";");		//background color (slightly transparent purple-ish blue)
printf("				}");
printf("				node_div.style.width = \"85%%\";");
printf("				break;");
printf("			case \"responsedisallowed\":");
printf("				var node_div = document.createElement('div');");
printf("				node_div.innerHTML = \"Responding With That Message Is Not Allowed\";");
printf("				node_div.style.font = \"normal normal bold 36px arial,sans-serif\";");		//CSS font shorthand -->  font-style font-variant font-weight font-size/line-height|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit
printf("				node_div.style.color = \"#ffffff\";");						//text color
printf("				if(YUI && (YUI.Env.UA.ie>0 && YUI.Env.UA.ie<9)){");
printf("					node_div.style.filter = \"progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='#c35900BE',endColorstr='#c35900BE')\";");
printf("				}else{");
printf("					node_div.style.backgroundColor = \"rgba(195,89,0,0.85)\";");		//background color (slightly transparent orange)
printf("				}");
printf("				node_div.style.width = \"85%%\";");
printf("				break;");
printf("			case \"alreadyclosed\":");
printf("				var node_div = document.createElement('div');");
printf("				node_div.innerHTML = \"Already Closed\";");
printf("				node_div.style.font = \"normal normal bold 36px arial,sans-serif\";");		//CSS font shorthand -->  font-style font-variant font-weight font-size/line-height|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit
printf("				node_div.style.color = \"#ffffff\";");						//text color
printf("				if(YUI && (YUI.Env.UA.ie>0 && YUI.Env.UA.ie<9)){");
printf("					node_div.style.filter = \"progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='#D8695ABE',endColorstr='#D8695ABE')\";");
printf("				}else{");
printf("					node_div.style.backgroundColor = \"rgba(105,90,190,.85)\";");		//background color (slightly transparent purple-ish blue)
printf("				}");
printf("				node_div.style.width = \"85%%\";");
printf("				break;");
printf("			case \"dropboxlaunch\":");
printf("				var node_div = document.createElement('div');");
printf("				node_div.innerHTML = \"Move Msg. Before Using\";");
printf("				node_div.style.font = \"normal normal bold 36px arial,sans-serif\";");		//CSS font shorthand -->  font-style font-variant font-weight font-size/line-height|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit
printf("				node_div.style.color = \"#ffffff\";");						//text color
printf("				if(YUI && (YUI.Env.UA.ie>0 && YUI.Env.UA.ie<9)){");
printf("					node_div.style.filter = \"progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='#D8695ABE',endColorstr='#D8695ABE')\";");
printf("				}else{");
printf("					node_div.style.backgroundColor = \"rgba(105,90,190,.85)\";");		//background color (slightly transparent purple-ish blue)
printf("				}");
printf("				node_div.style.width = \"85%%\";");
printf("				break;");
printf("			default:");
printf("				var node_div = document.createElement('div');");
printf("				node_div.innerHTML = strNotificationText.toString();");
printf("				node_div.style.font = \"normal normal bold 36px arial,sans-serif\";");		//CSS font shorthand -->  font-style font-variant font-weight font-size/line-height|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit
printf("				node_div.style.color = \"#ffffff\";");
printf("				if(YUI && (YUI.Env.UA.ie>0 && YUI.Env.UA.ie<9)){");
printf("					node_div.style.filter = \"progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='#cc808080',endColorstr='#cc808080')\";");
printf("				}else{");
printf("					node_div.style.backgroundColor = \"rgba(128,128,128,1)\";");
printf("				}");
printf("				node_div.style.width = \"95%%\";");
printf("				break;");
printf("		}");//end switch
printf("		yuiPanel = new Y.Panel({");
printf("			headerContent	: null,");
printf("			footerContent	: null,");
printf("			buttons		: null,");
printf("			srcNode		: node_div,");
printf("			width		: node_div.style.width,");
printf("			maxWidth	: node_div.style.width,");
printf("			zIndex		: 999,");
printf("			centered	: true,");
printf("			modal		: false,");
printf("			visible		: false,");
printf("			render		: true");
printf("			});");//end panel
printf("		yuiPanel.after('init', function(e){");
printf("			this.get('contentBox')._node.className = \"ModalNotification roundedcorners\";");	//cancel the default YUI SAM skinning for the IMG node
printf("			this.get('boundingBox')._node.style.outline = \"none\";");				//get rid of the faint outline on the DIV around the loading spinner IMG
printf("			eval(instanceName+\".initialized = true;\");");
printf("			});");//end after-init
printf("		});");//end yui
printf("	this.show = function(){");										//define method for showing
printf("		console.log(instanceName+\".show method invoked.\");");
printf("		yuiPanel.show();");
printf("		this.isVisible = true;");
printf("		return true;");
printf("		};");//end method definition for show()
printf("	this.hide = function(intDelayMs){");									//define method for hiding (if argument provided, hide will be delayed by that much)
printf("		console.log(instanceName+\".hide method invoked.\");");
printf("		if(typeof intDelayMs===\"undefined\" || isNaN(intDelayMs)){");						//if no delay argument was provided, go ahead and hide the spinner
printf("			yuiPanel.hide();");
printf("		}");
printf("		else if(parseInt(intDelayMs)>50){");									//else-if delay argument is substantially long enough to have a chance of doing anything, set it to hide on delay
printf("			setTimeout(function(){yuiPanel.hide()}, parseInt(intDelayMs));");
printf("		}");
printf("		else{");												//else all other unforseen cases, just hide it immediately
printf("			yuiPanel.hide();");
printf("		}");
printf("		this.isVisible = false;");
printf("		return true;");
printf("		};");//end method definition for hide()
printf("	this.showFor = function(intTimeoutMs){");								//define method for showing... if argument provided, it will automatically hide after that amount of time
printf("		console.log(instanceName+\".showFor method invoked. Showing it for \"+intTimeoutMs+\" milliseconds.\");");
printf("		yuiPanel.show();");
printf("		if(typeof intTimeoutMs===\"number\"){");								//if time argument was provided...
printf("			setTimeout(function(){yuiPanel.hide();}, intTimeoutMs);");					//set the panel to automatically hide after the specified time
printf("		}");
printf("		return true;");
printf("		};");//end method definition for show()
printf("}\n");//end function
printf("var ModalNotification_OK = new ClassModalNotification(\"ModalNotification_OK\", \"ok\");\n");
printf("var ModalNotification_Saved = new ClassModalNotification(\"ModalNotification_Saved\", \"saved\");\n");
printf("var ModalNotification_LaunchFailure = new ClassModalNotification(\"ModalNotification_LaunchFailure\", \"launchfailure\");\n");
//printf("var ModalNotification_AuthenticationFailure = new ClassModalNotification(\"ModalNotification_AuthenticationFailure\", \"authenticationfailure\");\n");
printf("var ModalNotification_ConnectionLost = new ClassModalNotification(\"ModalNotification_ConnectionLost\", \"connectionlost\");\n");
printf("var ModalNotification_MessageUnavailable = new ClassModalNotification(\"ModalNotification_MessageUnavailable\", \"messageunavailable\");\n");
printf("var ModalNotification_ServiceUnavailable = new ClassModalNotification(\"ModalNotification_ServiceUnavailable\", \"serviceunavailable\");\n");
printf("var ModalNotification_GeneralError = new ClassModalNotification(\"ModalNotification_GeneralError\", \"Unexpected problem...<br>Please try again\");\n");
printf("var ModalNotification_GeolocationProgress = new ClassModalNotification(\"ModalNotification_GeolocationProgress\", \"geolocationprogress\");\n");
printf("var ModalNotification_ResponseDisallowed = new ClassModalNotification(\"ModalNotification_ResponseDisallowed\", \"responsedisallowed\");\n");
printf("var ModalNotification_AlreadyClosed = new ClassModalNotification(\"ModalNotification_AlreadyClosed\", \"alreadyclosed\");\n");
printf("var ModalNotification_DropboxLaunch = new ClassModalNotification(\"ModalNotification_DropboxLaunch\", \"dropboxlaunch\");\n");

printf("function ClassUpdateSoftware(instanceName){");
printf("	var yuiPanel;");
printf("	this.initialized = false;");
printf("	var handle_setTimeout = undefined;");									//initialize a private handle for the setTimeout timer, so it can be cleared when they manually hide the panel
printf("	var handle_setInterval = undefined;");									//initialize a private handle for the setInterval timer, so it can be cleared when they manually hide the panel
printf("	this._countdown = 0;");											//declare/init a public variable for allowing setInterval to show a countdown, even after the showFor method executes (and presumably loses scope)...
printf("	this._nodeBtn_0 = undefined;");										//initialize a public variable to save a reference to the button
printf("	this._btnOrigText_0 = undefined;");									//initialize a public variable to save the original text of the button that the countdown will modify (public, in case the setInterval goes async on us)
printf("	function generateBodyNode(){");										//routine to create an iframe node...
printf("		var objNode = document.createElement('div');");							//	initialize a local iframe node that we'll later return
printf("		objNode.style.textAlign = \"center\";");
printf("		var p1 = document.createElement('p');");
printf("		var p2 = document.createElement('p');");
printf("		var p1Text = document.createTextNode(\"There is a new version of %s.\");", FAVS_NAME_FULL);
printf("		var p2Text;");
/* decide what instructional text to show... */
if(isLoadedInMobileApp()
	&& versionNumberOfMobileApp() >= atof(FAVS_APP_IOS_VER_CANRELOADDOC))	/* v1.6 of the native iOS app was the first to be able to support reloadDocument() */
	{
	printf("	p2Text = document.createTextNode(\"\");");
	}
else if(isLoadedInMobileApp())
	{
	printf("	var iosVer = parseInt(YUI.Env.UA.ios);");
	printf("	if(iosVer>=7){");
	printf("		p2Text = document.createTextNode(\"Double-click the Home button, find %s, swipe it up.\");", FAVS_NAME_SHORT);
	printf("	}");
	printf("	else if(iosVer>=6){");
	printf("		p2Text = document.createTextNode(\"Double-click the Home button, find %s, long-tap it, then tap the red '-' icon.\");", FAVS_NAME_SHORT);
	printf("	}");
	printf("	else{");
	printf("		p2Text = document.createTextNode(\"\");");
	printf("	}");
	}
else if(httpUserAgentString && 
	(  strstr(httpUserAgentString, "iPad")	//example: Mozilla/5.0 (iPad; CPU OS 7_0_6 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11B651 Safari/9537.53
	|| strstr(httpUserAgentString, "iPhone")
	|| strstr(httpUserAgentString, "iPod") 	//likely not needed, since iPod Touch seems to be caught by iPhone above, but can't hurt
	|| strstr(httpUserAgentString, "Android") ))
	{
	printf("	p2Text = document.createTextNode(\"To get it, close and then re-open %s, or tap your browser's reload icon.\");", FAVS_NAME_FULL);
	}
else
	{
	printf("	p2Text = document.createTextNode(\"To get it, close and then re-open %s, or press the F5 key to reload.\");", FAVS_NAME_FULL);
	}
printf("		p1.appendChild(p1Text);");
printf("		p2.appendChild(p2Text);");
printf("		objNode.appendChild(p1);");
printf("		objNode.appendChild(p2);");
printf("		return objNode;");
printf("	}");
printf("	YUI().use(\"panel\", function(Y){");
printf("		yuiPanel = new Y.Panel({");
printf("			id		: 'panelupdatesoftware',");
printf("			headerContent	: null,");
printf("			srcNode		: generateBodyNode(),");
printf("			footerContent	: null,");
printf("			buttons:[");
/* decide what buttons to show... */
if(isLoadedInMobileApp()
	&& versionNumberOfMobileApp() >= atof(FAVS_APP_IOS_VER_CANRELOADDOC))	/* v1.6 of the native iOS app was the first to be able to support reloadDocument() */
	{
	printf("			{");
	printf("			value	: 'Get it Now',");
	printf("			section	: Y.WidgetStdMod.FOOTER,");
	printf("			action	: function(e){");
	printf("				reloadDocument();");								//our custom trigger for the native app to reload the document (Connections Mobile/Favs)
	printf("				}");//end action
	printf("			},");//end reload button
	}
else if(httpUserAgentString && 
	(  strstr(httpUserAgentString, "iPad")	//example: Mozilla/5.0 (iPad; CPU OS 7_0_6 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11B651 Safari/9537.53
	|| strstr(httpUserAgentString, "iPhone")
	|| strstr(httpUserAgentString, "iPod") ))//likely not needed, since iPod Touch seems to be caught by iPhone above, but can't hurt
	{
	//don't show the 'close' button on these devices, since Apple won't allow it
	}
else if(httpUserAgentString &&
	(  strstr(httpUserAgentString, "Android")
	|| strstr(httpUserAgentString, "android") ))
	{
	//don't show the 'close' button on these devices?
	}
else
	{
	printf("			{");
	printf("			value	: 'Close Window',");
	printf("			section	: Y.WidgetStdMod.FOOTER,");
	printf("			action	: function(e){");
	printf("				window.close();");								//won't work on iOS - Apple will deny the app if we allow the user to do this
	printf("				}");//end action
	printf("			},");//end reload button
	}
printf("				{");
printf("				value	: 'Cancel',");
printf("				section	: Y.WidgetStdMod.FOOTER,");
printf("				action	: function(e){");
printf("					eval(instanceName+\".hide();\");");
printf("					}");//end action
printf("				}");//end Cancel button
printf("			],");//end buttons
printf("			width		: \"95%%\",");
printf("			zIndex		: 5,");
printf("			centered	: true,");
printf("			modal		: true,");
printf("			visible		: false,");
printf("			render		: true");
printf("			});");//end panel
printf("		yuiPanel.after('init', function(e){");									//listening for an initialization event...
printf("			eval(instanceName+\".initialized = true;\");");
printf("			eval(instanceName+\"._nodeBtn_0 = this.getButton(0).getDOMNode();\");");			//	save a public reference to the Close-Favs button
printf("			eval(instanceName+\"._btnOrigText_0 = \"+instanceName+\"._nodeBtn_0.innerHTML;\");");		//	save the Close-Favs button's text, so it can be restored if changed
printf("			FastClick.attach(document.getElementById('panelupdatesoftware'));");		//attach the fastclick override to this panel and any of its children (like buttons)
printf("			});");//end after-init
printf("		});");//end YUI().use
printf("	this.restoreButtons = function(){");									//define method for restoring button(s) to original text
printf("		var btnOrigText_0 = eval(instanceName+\"._btnOrigText_0\");");
printf("		eval(instanceName+\"._nodeBtn_0.innerHTML = btnOrigText_0;\");");
printf("		};");//end method definition for restoreButtons()
printf("	this.show = function(){");
printf("		if(typeof FavScreen===\"undefined\"){console.log(\"ClassUpdateSoftware.show method invoked.\");}else{FavScreen.log('log',\"ClassUpdateSoftware.show method invoked.\",false);}");
printf("		if(typeof FavScreen!==\"undefined\"){");
printf("			if(FavScreen.get('attrInteractionMode')==MODE_EDITABLE){");						//if in edit mode, prevent interruption
printf("				FavScreen.log('info',\"ClassUpdateSoftware.show aborting to avoid interrupting the user's edit session.\",false);");
printf("				return false;");
printf("			}");
printf("			if(FavScreen.get('attrInteractionMode')==MODE_REPLYING){");						//if in replying mode, prevent interruption
printf("				FavScreen.log('info',\"ClassUpdateSoftware.show aborting to avoid interrupting the user's edit session.\",false);");
printf("				return false;");
printf("			}");
printf("			if(typeof iframe===\"object\"){");									//if doing something in an iframe, prevent interruption
printf("				FavScreen.log('info',\"ClassUpdateSoftware.show aborting to avoid interrupting the user's iframe session.\",false);");
printf("				return false;");
printf("			}");
printf("		}");
printf("		if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
printf("		yuiPanel.show();");
printf("		return true;");
printf("		};");//end method definition for show()
printf("	this.hide = function(intDelayMs){");									//define method for hiding the YUI Panel
printf("		if(typeof FavScreen===\"undefined\"){console.log(\"ClassUpdateSoftware.hide method invoked.\");}else{FavScreen.log('log',\"ClassUpdateSoftware.hide method invoked.\",false);}");
printf("		if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
printf("		if(typeof handle_setInterval!==\"undefined\"){");							//if an auto-timeout countdown is active, clear it, since we've essentially cancelled the auto timeout at this point, and reset button
printf("			clearInterval(handle_setInterval);");
printf("			this.restoreButtons();");
printf("		}");//end if setInterval
printf("		if(typeof intDelayMs===\"undefined\" || isNaN(intDelayMs)){");						//if no delay argument was provided, go ahead and hide the panel
printf("			yuiPanel.hide();");
printf("		}");
printf("		else if(parseInt(intDelayMs)>50){");									//else-if delay argument is substantially long enough to have a chance of doing anything, set it to hide on delay
printf("			handle_setTimeout = setTimeout(function(){yuiPanel.hide()}, parseInt(intDelayMs));");
printf("		}");
printf("		else{");												//else all other unforseen cases, just hide it immediately
printf("			yuiPanel.hide();");
printf("		}");
printf("		return true;");
printf("		};");//end method definition for hide()
printf("	this.showFor = function(intTimeoutMs){");								//define method for showing for a certain amount of time... if argument provided, it will automatically hide after that amount of time; else, it will show and NOT automatically hide
printf("		if(typeof FavScreen===\"undefined\"){console.log(instanceName+\".showFor method invoked. Showing it for \"+intTimeoutMs+\" milliseconds.\");}else{FavScreen.log('log',instanceName+\".showFor method invoked. Showing it for \"+intTimeoutMs+\" milliseconds.\",false);}");
printf("		if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
printf("		if(typeof handle_setInterval!==\"undefined\"){clearInterval(handle_setInterval);}");			//if an auto-timeout countdown is active, clear it, since we've essentially cancelled the auto timeout at this point
printf("		var yp;");												//declare a variable to store reference to the yuiPanel that gets returned when we call the show method
printf("		if(typeof intTimeoutMs===\"number\"){");								//if time argument was provided...
printf("			this.countdown = Math.round(intTimeoutMs/1000);");
printf("			safeToHideModalMask = false;");									//set the flag for not allowing customized modal mask hiding, since this panel requires it to be preserved
printf("			yp = yuiPanel.show();");									//show the panel, remembering the yuiPanel reference it returns
printf("			handle_setInterval = setInterval( function(){");						//run the countdown logic every second...
printf("				if( eval(instanceName+\".countdown\")<=0 ){");						//if countdown is done, close/reload the window (depending on what the client supports)
if(isLoadedInMobileApp()
	&& versionNumberOfMobileApp() >= atof(FAVS_APP_IOS_VER_CANRELOADDOC))	/* v1.6 of the native iOS app was the first to be able to support reloadDocument() */
	{
	printf("				reloadDocument();");
	}
else if(httpUserAgentString && 
	(  strstr(httpUserAgentString, "iPad")	//example: Mozilla/5.0 (iPad; CPU OS 7_0_6 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11B651 Safari/9537.53
	|| strstr(httpUserAgentString, "iPhone")
	|| strstr(httpUserAgentString, "iPod") ))	//likely not needed, since iPod Touch seems to be caught by iPhone above, but can't hurt
	/* add android? */
	{
	printf("				yuiPanel.hide();");
	printf("				safeToHideModalMask = true;");							//reset the flag for allowing customized modal mask hiding, since this panel no longer requires it to be preserved
	}
else
	{
	printf("				window.close();");
	}
printf("				}else{");										//else countdown is still active, so update the button and decrement countdown
printf("					var btnOrigText = eval(instanceName+\"._btnOrigText_0\");");
printf("					var btnCountText = \" (\"+eval(instanceName+\".countdown\")+\")\";");
printf("					var btnWholeText = btnOrigText + btnCountText;");
printf("					eval(instanceName+\"._nodeBtn_0.innerHTML = btnWholeText;\");");
printf("					eval(instanceName+\".countdown--;\");");
printf("				}");
printf("				}, 1000);");//end setInterval
printf("		}");//end if
printf("		return yp;");												//method returns handle to the YUI Panel
printf("		};");//end method definition for showFor()
printf("}\n");//end function
printf("var UpdateSoftware = new ClassUpdateSoftware(\"UpdateSoftware\");\n");
/*
if(isLoadedInMobileApp())
	{
	printf("function ClassUpdateSoftware_AppleApp(instanceName){");
	printf("	var yuiPanel;");
	printf("	this.initialized = false;");
	printf("	var handle_setTimeout = undefined;");									//initialize a private handle for the setTimeout timer, so it can be cleared when they manually hide the panel
	printf("	var handle_setInterval = undefined;");									//initialize a private handle for the setInterval timer, so it can be cleared when they manually hide the panel
	printf("	this._countdown = 0;");											//declare/init a public variable for allowing setInterval to show a countdown, even after the showFor method executes (and presumably loses scope)...
	printf("	this._nodeBtn_0 = undefined;");										//initialize a public variable to save a reference to the button
	printf("	this._btnOrigText_0 = undefined;");									//initialize a public variable to save the original text of the button that the countdown will modify (public, in case the setInterval goes async on us)
	printf("	function generateBodyNode(){");										//routine to create an iframe node...
	printf("		var objNode = document.createElement('div');");							//	initialize a local iframe node that we'll later return
	printf("		objNode.style.textAlign = \"center\";");
	printf("		var p1 = document.createElement('p');");
	printf("		var p1Text = document.createTextNode(\"Please update to the latest version of the app in Apple's App-Store.\");");
	printf("		p1.appendChild(p1Text);");
	printf("		objNode.appendChild(p1);");
	printf("		return objNode;");
	printf("	}");
	printf("	YUI().use(\"panel\", function(Y){");
	printf("		yuiPanel = new Y.Panel({");
	printf("			headerContent	: null,");
	printf("			srcNode		: generateBodyNode(),");
	printf("			footerContent	: null,");
	printf("			buttons:[");
	printf("				{");
	printf("				value	: 'OK',");
	printf("				section	: Y.WidgetStdMod.FOOTER,");
	printf("				action	: function(e){");
	printf("					e.preventDefault();");
	printf("					eval(instanceName+\".hide();\");");
	printf("					}");//end action
	printf("				}");//end OK button
	printf("			],");//end buttons
	printf("			width		: \"80%%\",");
	printf("			zIndex		: 5,");
	printf("			centered	: true,");
	printf("			modal		: true,");
	printf("			visible		: false,");
	printf("			render		: true");
	printf("			});");//end panel
	printf("		yuiPanel.after('init', function(e){");									//listening for an initialization event...
	printf("			eval(instanceName+\".initialized = true;\");");
	printf("			eval(instanceName+\"._nodeBtn_0 = this.getButton(0).getDOMNode();\");");			//	save a public reference to the OK button
	printf("			eval(instanceName+\"._btnOrigText_0 = \"+instanceName+\"._nodeBtn_0.innerHTML;\");");		//	save the Close-Favs button's text, so it can be restored if changed
	printf("			});");//end after-init
	printf("		});");//end YUI().use
	printf("	this.restoreButtons = function(){");									//define method for restoring button(s) to original text
	printf("		var btnOrigText_0 = eval(instanceName+\"._btnOrigText_0\");");
	printf("		eval(instanceName+\"._nodeBtn_0.innerHTML = btnOrigText_0;\");");
	printf("		};");//end method definition for restoreButtons()
	printf("	this.show = function(){");
	printf("		console.log(\"ClassUpdateSoftware_AppleApp.show method invoked.\");");
	printf("		if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
	printf("		yuiPanel.show();");
	printf("		return true;");
	printf("		};");//end method definition for show()
	printf("	this.hide = function(intDelayMs){");									//define method for hiding the YUI Panel
	printf("		console.log(\"ClassUpdateSoftware_AppleApp.hide method invoked.\");");
	printf("		if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
	printf("		if(typeof handle_setInterval!==\"undefined\"){");							//if an auto-timeout countdown is active, clear it, since we've essentially cancelled the auto timeout at this point, and reset button
	printf("			clearInterval(handle_setInterval);");
	printf("			this.restoreButtons();");
	printf("		}");//end if setInterval
	printf("		if(typeof intDelayMs===\"undefined\" || isNaN(intDelayMs)){");						//if no delay argument was provided, go ahead and hide the panel
	printf("			yuiPanel.hide();");
	printf("		}");
	printf("		else if(parseInt(intDelayMs)>50){");									//else-if delay argument is substantially long enough to have a chance of doing anything, set it to hide on delay
	printf("			handle_setTimeout = setTimeout(function(){yuiPanel.hide()}, parseInt(intDelayMs));");
	printf("		}");
	printf("		else{");												//else all other unforseen cases, just hide it immediately
	printf("			yuiPanel.hide();");
	printf("		}");
	printf("		return true;");
	printf("		};");//end method definition for hide()
	printf("	this.showFor = function(intTimeoutMs){");								//define method for showing for a certain amount of time... if argument provided, it will automatically hide after that amount of time; else, it will show and NOT automatically hide
	printf("		console.log(instanceName+\".showFor method invoked. Showing it for \"+intTimeoutMs+\" milliseconds.\");");
	printf("		if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
	printf("		if(typeof handle_setInterval!==\"undefined\"){clearInterval(handle_setInterval);}");			//if an auto-timeout countdown is active, clear it, since we've essentially cancelled the auto timeout at this point
	printf("		var yp;");												//declare a variable to store reference to the yuiPanel that gets returned when we call the show method
	printf("		if(typeof intTimeoutMs===\"number\"){");								//if time argument was provided...
	printf("			this.countdown = Math.round(intTimeoutMs/1000);");
	printf("			safeToHideModalMask = false;");									//set the flag for not allowing customized modal mask hiding, since this panel requires it to be preserved
	printf("			yp = yuiPanel.show();");									//show the panel, remembering the yuiPanel reference it returns
	printf("			handle_setInterval = setInterval( function(){");						//run the countdown logic every second...
	printf("				if( eval(instanceName+\".countdown\")<=0 ){");						//if countdown is done, close/reload the window (depending on what the client supports)
	printf("					yuiPanel.hide();");
	printf("					safeToHideModalMask = true;");							//reset the flag for allowing customized modal mask hiding, since this panel no longer requires it to be preserved
	printf("				}else{");										//else countdown is still active, so update the button and decrement countdown
	printf("					var btnOrigText = eval(instanceName+\"._btnOrigText_0\");");
	printf("					var btnCountText = \" (\"+eval(instanceName+\".countdown\")+\")\";");
	printf("					var btnWholeText = btnOrigText + btnCountText;");
	printf("					eval(instanceName+\"._nodeBtn_0.innerHTML = btnWholeText;\");");
	printf("					eval(instanceName+\".countdown--;\");");
	printf("				}");
	printf("				}, 1000);");//end setInterval
	printf("		}");//end if
	printf("		return yp;");												//method returns handle to the YUI Panel
	printf("		};");//end method definition for showFor()
	printf("}\n");//end function
	printf("var UpdateSoftware_AppleApp = new ClassUpdateSoftware_AppleApp(\"UpdateSoftware_AppleApp\");\n");
	}
*/
printf("function ClassVersionInfo(instanceName){");
printf("	var yuiPanel;");											//declare private handle for the YUI Panel
printf("	this.initialized = false;");										//initialize public attribute for externally querying this class' initialized state
printf("	var handle_setTimeout = undefined;");									//initialize a private handle for the setTimeout timer, so it can be cleared when they manually hide the panel
printf("	var handle_setInterval = undefined;");									//initialize a private handle for the setInterval timer, so it can be cleared when they manually hide the panel
printf("	this._countdown = 0;");											//declare/init a public variable for allowing setInterval to show a countdown, even after the showFor method executes (and presumably loses scope)...
printf("	this._nodeBtn_0 = undefined;");										//initialize a public variable to save a reference to the button
printf("	this._btnOrigText_0 = undefined;");									//initialize a public variable to save the original text of the button that the countdown will modify (public, in case the setInterval goes async on us)
printf("	YUI().use(\"panel\", function(Y){");									//using a YUI Panel...
printf("		var strFav = \"<strong>%s</strong><br>Version %s<br>&nbsp;(build %s)\";", FAVS_NAME_FULL, FAVS_VERSION, FAVS_BUILD);										//mobile software info
printf("		var strYui = \"YUI Version \"+YUI.version;");																		//yui info
printf("		var strCon = \"<strong>%s</strong><br>Version %s<br>Built on %s at %s\";", cgi_product_name, SILENT_MESSENGER_VERSION, SILENT_MESSENGER_DATE_BUILD, SILENT_MESSENGER_TIME_BUILD);	//server software info
printf("		function parseBrowserInfoFromUA(){");									//parse and return some basic browser info and version from the useragent string
printf("			var objUA = YUI.Env.UA;");
printf("			var arrFilteredUA = [];");
printf("			for(var key in objUA){");									//go through YUI's UA object literal and save the objects that represent browser version numbers
printf("				var obj = objUA[key];");
printf("				if(parseInt(obj)!=NaN && obj>0){");							//if this object has a valid version number, we're getting hot
printf("					if(key.toLowerCase()!=\"webkit\"){");
printf("						return key+\" \"+obj;");
printf("					}");
printf("				}");
printf("			}");
printf("		}");
printf("		if(isLoadedInMobileApp()){");
printf("			var strApp = \"App Version \"+parseAppVersionFromUA();");
printf("		}else{");
printf("			var strApp = \"Browser is \"+parseBrowserInfoFromUA();");
printf("		}");
printf("		var str = strFav +\"<br>\"+strApp+\"<br>\"+strYui+\"<br><br>\"+ strCon;");				//assemble the HTML output to display
printf("		yuiPanel = new Y.Panel({");										//instantiate a new Panel object, configured with...
printf("			id		: 'panelversioninfo',");
printf("			headerContent	: null,");									//no header/title bar
printf("			bodyContent	: str,");									//body contains above-constructed string with version info
printf("			footerContent	: null,");									//no pre-specified footer (buttons will populate it instead, below)
printf("			buttons:[");											//configure buttons...
printf("				{");
printf("				value	: 'OK',");
printf("				section	: Y.WidgetStdMod.FOOTER,");
printf("				action	: function(e){");
printf("					e.preventDefault();");
printf("					eval(instanceName+\".hide();\");");
printf("					}");//end action
printf("				}");//end OK button
printf("			],");//end buttons
printf("			width		: \"70%%\",");
printf("			zIndex		: 5,");										//just high enough to ensure it's on top
printf("			centered	: true,");
printf("			modal		: true,");									//we want it modal, so it's the only interactive element while showing
printf("			visible		: false,");									//initially invisible
printf("			render		: true");									//go ahead and render in the DOM, so it comes up quick (after an instance of this class gets initialized, of course)
printf("			});");//end panel
printf("		yuiPanel.after('init', function(e){");									//listening for an initialization event...
printf("			eval(instanceName+\".initialized = true;\");");							//	set public init flag (must use eval so we can effect the specific instance... "this" inside a YUI sandbox refers to the YUI sandbox rather than this class)
printf("			eval(instanceName+\"._nodeBtn_0 = this.getButton(0).getDOMNode();\");");			//	save a public reference to the OK button
printf("			eval(instanceName+\"._btnOrigText_0 = \"+instanceName+\"._nodeBtn_0.innerHTML;\");");		//	save the OK button's text, so it can be restored if changed
printf("			FastClick.attach(document.getElementById('panelversioninfo'));");		//attach the fastclick override to this panel and any of its children (like buttons)
printf("			});");//end after-init
printf("		});");//end YUI().use
printf("	this.restoreButtons = function(){");									//define method for restoring button(s) to original text
printf("		var btnOrigText_0 = eval(instanceName+\"._btnOrigText_0\");");
printf("		eval(instanceName+\"._nodeBtn_0.innerHTML = btnOrigText_0;\");");
printf("		};");//end method definition for restoreButtons()
printf("	this.show = function(){");										//define method for showing the YUI Panel that we configured above...
printf("		console.log(\"ClassVersionInfo.show method invoked.\");");						//log to the global console
printf("		if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
printf("		yuiPanel.show();");											//invoke the YUI Panel method to actually show the panel on-screen
printf("		return yuiPanel;");											//return a reference to the panel that's now showing
printf("		};");//end method definition for show()
printf("	this.hide = function(intDelayMs){");									//define method for hiding the YUI Panel...
printf("		console.log(\"ClassVersionInfo.hide method invoked.\");");
printf("		if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
printf("		if(typeof handle_setInterval!==\"undefined\"){");							//if an auto-timeout countdown is active, clear it, since we've essentially cancelled the auto timeout at this point, and reset button
printf("			clearInterval(handle_setInterval);");
printf("			this.restoreButtons();");
printf("		}");//end if setInterval
printf("		if(typeof intDelayMs===\"undefined\" || isNaN(intDelayMs)){");						//if no delay argument was provided, go ahead and hide the panel
printf("			yuiPanel.hide();");
printf("		}");
printf("		else if(parseInt(intDelayMs)>50){");									//else-if delay argument is substantially long enough to have a chance of doing anything, set it to hide on delay
printf("			handle_setTimeout = setTimeout(function(){yuiPanel.hide()}, parseInt(intDelayMs));");
printf("		}");
printf("		else{");												//else all other unforseen cases, just hide it immediately
printf("			yuiPanel.hide();");
printf("		}");
printf("		return true;");
printf("		};");//end method definition for hide()
printf("	this.showFor = function(intTimeoutMs){");								//define method for showing for a certain amount of time... if argument provided, it will automatically hide after that amount of time; else, it will show and NOT automatically hide
printf("		console.log(instanceName+\".showFor method invoked. Showing it for \"+intTimeoutMs+\" milliseconds.\");");
printf("		if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
printf("		if(typeof handle_setInterval!==\"undefined\"){clearInterval(handle_setInterval);}");			//if an auto-timeout countdown is active, clear it, since we've essentially cancelled the auto timeout at this point
printf("		var yp;");												//declare a variable to store reference to the yuiPanel that gets returned when we call the show method
printf("		if(typeof intTimeoutMs===\"number\"){");								//if time argument was provided...
printf("			this.countdown = Math.round(intTimeoutMs/1000);");						//convert to seconds, for friendly-display
printf("			yp = yuiPanel.show();");									//show the panel, remembering the yuiPanel reference it returns
printf("			handle_setInterval = setInterval( function(){");						//run the countdown logic every second...
printf("				if( eval(instanceName+\".countdown\")<=0 ){");						//if countdown is done, hide the panel
printf("					safeToHideModalMask = true;");							//reset the flag for allowing customized modal mask hiding, since this panel no longer requires it to be preserved
printf("					eval(instanceName+\".hide();\");");
printf("				}else{");										//else countdown is still active, so update the button and decrement countdown
printf("					var btnOrigText = eval(instanceName+\"._btnOrigText_0\");");
printf("					var btnCountText = \" (\"+eval(instanceName+\".countdown\")+\")\";");
printf("					var btnWholeText = btnOrigText + btnCountText;");
printf("					eval(instanceName+\"._nodeBtn_0.innerHTML = btnWholeText;\");");
printf("					eval(instanceName+\".countdown--;\");");
printf("				}");
printf("				}, 1000);");//end setInterval
printf("		}");//end if
printf("		return yp;");												//method returns handle to the YUI Panel
printf("		};");//end method definition for showFor()
printf("}\n");//end function
printf("var VersionInfo = new ClassVersionInfo(\"VersionInfo\");\n");

/*
printf("function ClassPromptConfirmCloseMsg(instanceName){");
printf("	var yuiPanel;");
printf("	this.initialized = false;");
printf("	this.clickTargetId = undefined;");
printf("	var handle_setTimeout = undefined;");									//initialize a private handle for the setTimeout timer, so it can be cleared when they manually hide the panel
printf("	YUI().use(\"panel\", function(Y){");
printf("		yuiPanel = new Y.Panel({");
printf("			id		: 'panelconfirmclosemsg',");
printf("			headerContent	: null,");
printf("			bodyContent	: \"<div style='text-align:center; font-size:2em;'>Close Msg?</div>\",");
printf("			footerContent	: null,");
printf("			buttons:[");
printf("				{");
printf("				value	: 'Yes',");
printf("				classNames:'confirmclosemsgbtnyes confirmclosemsgbtn',");
printf("				section	: Y.WidgetStdMod.FOOTER,");
printf("				action	: function(e){");
printf("					eval(\"closeMessage(\"+instanceName+\".clickTargetId,true);\");");		//re-call the close-msg method, but this time skipping the pre-check stuff since it's already been done (which is how we got here)
printf("					this.hide();");
printf("					}");//end action
printf("				},");//end reload button
printf("				{");
printf("				value	: 'No',");
printf("				classNames:'confirmclosemsgbtn',");
printf("				section	: Y.WidgetStdMod.FOOTER,");
printf("				action	: function(e){");
printf("					this.hide();");
printf("					}");//end action
printf("				}");//end Cancel button
printf("			],");//end buttons
printf("			width		: \"250px\",");
printf("			zIndex		: 5,");
printf("			centered	: true,");
printf("			modal		: true,");
printf("			visible		: false,");
printf("			render		: true");
printf("			});");//end panel
printf("		yuiPanel.after('init', function(e){");
printf("			eval(instanceName+\".initialized = true;\");");
printf("			FastClick.attach(document.getElementById('panelconfirmclosemsg'));");		//attach the fastclick override to this panel and any of its children (like buttons)
printf("			});");//end after-init
printf("		var node_modalMask = document.getElementsByClassName(\"yui3-widget-mask\")[0];");		//get a reference to the modal mask (which, of course, is provided whenever a YUI-Panel reders)
printf("		var headerwrapperHeight = document.getElementById(\"headerwrapper\").offsetHeight;");		//get the calculated height of the headerwrapper area (including padding, etc.)
printf("		if(!(headerwrapperHeight>0)){headerwrapperHeight=60}");						//if for some reason we didn't get a valid value, then fallback to hard coded assumed height of 60px (this likely will never happen, though)
printf("		yuiPanel.after('visibleChange', function(e){");
printf("			if(this.get('visible')){");								//if the panel is now visible, then...
printf("				node_modalMask.style.display = \"block\";");						//show the modal mask
printf("				node_modalMask.style.top = headerwrapperHeight+\"px\";");				//position the modal mask so that the header area isn't masked
printf("			}else{");										//else the panel is now hidden, so...
printf("				node_modalMask.style.display = \"none\";");						//hide the modal mask
printf("				node_modalMask.style.top = \"0px\";");							//reset the modal mask's original position for masking the entire document
printf("			}");//end if-else
printf("			});");//end after-visibleChange
printf("		});");//end YUI().use
printf("	this.show = function(clickTargetId){");
printf("		if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
printf("		if(typeof clickTargetId===\"undefined\"){");
printf("			console.log(instanceName+\".show method invoked without clickTargetId provided. Aborting\");");
printf("			return false;");
printf("		}else{");
printf("			console.log(instanceName+\".show method invoked with clickTargetId=\"+clickTargetId+\".\");");
printf("			this.clickTargetId = clickTargetId;");
printf("			yuiPanel.show();");
printf("		}");
printf("		};");//end method definition for show()
printf("	this.hide = function(intDelayMs){");									//define method for hiding the panel (with optional timer for doing so)
printf("		console.log(instanceName+\".hide method invoked.\");");
printf("		if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
printf("		this.clickTargetId = undefined;");										//re-initialize clickTargetId to be safe for future calls to the show method
printf("		if(typeof intDelayMs===\"undefined\" || isNaN(intDelayMs)){");						//if no delay argument was provided, go ahead and hide the panel
printf("			yuiPanel.hide();");
printf("		}");
printf("		else if(parseInt(intDelayMs)>50){");									//else-if delay argument is substantially long enough to have a chance of doing anything, set it to hide on delay
printf("			handle_setTimeout = setTimeout(function(){yuiPanel.hide()}, parseInt(intDelayMs));");
printf("		}");
printf("		else{");												//else all other unforseen cases, just hide it immediately
printf("			yuiPanel.hide();");
printf("		}");
printf("		};");//end method definition for hide()
printf("	this.isVisible = function(){");										//define method for determining whether panel is currently showing
printf("		if(yuiPanel.get('visible')){");										//if the panel is now visible, then return true
printf("			return true;");
printf("		}else{");												//else the panel is now hidden, so return false
printf("			return false;");
printf("		}");//end if-else
printf("		};");//end method definition for isVisible()
printf("	this.showFor = function(clickTargetId, intTimeoutMs){");							//define method for showing for a certain amount of time... clickTargetId required... if 2nd argument provided, it will automatically hide after that amount of time; else, it will show and NOT automatically hide
printf("		if(typeof clickTargetId===\"undefined\"){");
printf("			console.log(instanceName+\".showFor method invoked without clickTargetId provided. Aborting\");");
printf("			return false;");
printf("		}else{");
printf("			console.log(instanceName+\".showFor method invoked. Showing it for \"+intTimeoutMs+\" milliseconds.\");");
printf("			if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
printf("			this.clickTargetId = clickTargetId;");
printf("			var yp;");												//declare a variable to store reference to the yuiPanel that gets returned when we call the show method
printf("			if(typeof intTimeoutMs===\"number\"){");								//if time argument was provided...
printf("				yp = yuiPanel.show(clickTargetId);");								//show the panel, remembering the yuiPanel reference it returns
printf("				handle_setTimeout = setTimeout(function(){yuiPanel.hide()}, parseInt(intTimeoutMs));");
printf("			}");//end if
printf("		}");//end else
printf("		return yp;");												//method returns handle to the YUI Panel
printf("		};");//end method definition for showFor()
printf("}\n");//end function
printf("var ConfirmCloseMsg = new ClassPromptConfirmCloseMsg(\"ConfirmCloseMsg\");\n");
*/

printf("function ClassInternalPopup(instanceName){");								// Define a class that can be used as an in-window "popup" to use instead of opening multiple windows
printf("	var yuiPanel;");											//declare private handle for the YUI Panel
printf("	this.initialized = false;");										//initialize public attribute for externally querying this class' initialized state
printf("	var handle_setTimeout = undefined;");									//initialize a private handle for the setTimeout timer, so it can be cleared when they manually hide the panel
printf("	var handle_setInterval = undefined;");									//initialize a private handle for the setInterval timer, so it can be cleared when they manually hide the panel
//printf("	this.currentWindow = null;");										//initialize a public handle for exposing the reference to the "popup window" that we're going to create
printf("	this.iframe = null;");											//initialize a public handle for exposing the reference to the iframe 
printf("	function generateIframeNode(){");									//routine to create an iframe node...
printf("		var objNode = document.createElement('iframe');");						//	initialize a local iframe node that we'll later return
printf("		objNode.id = \"internalPopupBodyContent\";");							//	give the iframe an id so we can work with it later
printf("		objNode.src = \"about:blank\";");								//	we don't want the iframe to try loading something
printf("		return objNode;");
printf("	}");
printf("	YUI().use(\"panel\", function(Y){");									//using a YUI Panel...
printf("		yuiPanel = new Y.Panel({");										//instantiate a new Panel object, configured with...
printf("			headerContent	: null,");									//no header/title bar
printf("			srcNode		: generateIframeNode(),");
printf("			footerContent	: null,");									//no pre-specified footer (buttons will populate it instead, below)
printf("			width		: \"90%%\",");
printf("			height		: \"70%%\",");
printf("			zIndex		: 5,");										//just high enough to ensure it's on top
printf("			centered	: true,");
printf("			modal		: true,");									//we want it modal, so it's the only interactive element while showing
printf("			visible		: false,");									//initially invisible
printf("			render		: true");									//go ahead and render in the DOM, so it comes up quick (after an instance of this class gets initialized, of course)
printf("			});");//end panel
printf("		yuiPanel.after('init', function(e){");									//listening for an initialization event, do stuff after it's initialized...
printf("			eval(instanceName+\".initialized = true;\");");							//	set public init flag (must use eval so we can effect the specific instance... "this" inside a YUI sandbox refers to the YUI sandbox rather than this class)
printf("			eval(instanceName+\".iframe = Y.one('#internalPopupBodyContent').getDOMNode();\");");		//	save a public reference to the iframe DOM node
printf("			eval(instanceName+\".iframe.onload = function(){");						//	each time the iframe changes state (document reload, form submission, etc.), we may need to re-specify some things we don't want lost, for legacy code to work
printf("				\"+instanceName+\".iframe.contentWindow.opener = FavScreen.get('objPopupOpener');");		//re-specify the opener, so new documents can reference it to plug form values back in, etc.
printf("				\"+instanceName+\".iframe.contentWindow.close = function(){\"+instanceName+\".hide();};");	//re-specify the close method override to simply hide the YUI-Panel (since close() won't work)
printf("				\"+instanceName+\".iframe.contentWindow.document.body.style.zoom = FavScreen.get('attrZoom');");//specify the preferred zoom level
printf("				};\");");//end eval-onload
printf("			});");//end after-init
printf("		yuiPanel.after('visibleChange', function(e){");								//define what happens whenever the menu's visibility changes...
printf("			var node_modalMask = document.getElementsByClassName(\"yui3-widget-mask\")[0];");		//get a reference to the modal mask (which, of course, is provided whenever a YUI-Panel reders)
printf("			var headerwrapperHeight = document.getElementById(\"headerwrapper\").offsetHeight;");		//get the calculated height of the headerwrapper area (including padding, etc.)
printf("			if(!(headerwrapperHeight>0)){headerwrapperHeight=60}");						//if for some reason we didn't get a valid value, then fallback to hard coded assumed height of 60px (this likely will never happen, though)
printf("			if(this.get('visible')){");									//if panel (and thus mask) is showing...
printf("				node_modalMask.style.top = headerwrapperHeight+\"px\";");					//position the modal mask so that the header area isn't masked
printf("			}else{");
printf("				node_modalMask.style.top = \"0px\";");								//reset the modal mask's original position for masking the entire document
printf("			}");
printf("			});");//end after-init
printf("		});");//end YUI().use
printf("	this.showWith = function(objDoc){");									//define method for showing the YUI Panel that we configured above...
printf("		console.log(\"ClassInternalPopup.showWith method invoked.\");");					//log to the global console
printf("		if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
printf("		var node_iframe = false;");
printf("		YUI().use('node', function(Y){");
printf("			node_iframe = Y.one(\"#internalPopupBodyContent\").getDOMNode();");				//get a DOM reference to the panel's iframe node, using YUI
printf("			});");
printf("		node_iframe.style.display = \"block\";");
//printf("		this.currentWindow = node_iframe.contentWindow;");							//expose the iframe's window through this class-instance member
printf("		var node_iframeDocument = node_iframe.contentWindow.document || node_iframe.contentDocument;");		//get a reference to the panel's iframe's document (this assignment method should help support different browsers)
printf("		var objXml = new XMLSerializer;");									//instantiate XMLSerializer, in preparation to convert the document object into a string representing the document
printf("		var str_objDoc = objXml.serializeToString(objDoc.documentElement);");					//convert the document object into a string, so we can use the write() method...  DEV-NOTE: test with IE to make sure it supports this method
printf("		node_iframeDocument.open();");										//open the document stream for writing
printf("		node_iframeDocument.write(str_objDoc);");								//write the document contents to the document
printf("		node_iframeDocument.close();");										//close the document stream for writing
//NOTE: each document may submit its own form, so need to detect this and re-specify opener, etc. each time
//printf("node_iframe.contentWindow.onunload = function(){console.warn('onunload')};");
printf("		yuiPanel.show();");											//invoke the YUI Panel method to actually show the panel on-screen
printf("		setTimeout(function(){try{hideNativeSpinner();}catch(err){console.warn('ClassInternalPopup: Delayed hideNativeSpinner call did not succeed.');}}, 20000);");
printf("		return yuiPanel;");											//return a reference to the panel that's now showing
printf("		};");//end method definition for show()
printf("	this.hide = function(intDelayMs){");									//define method for hiding the YUI Panel...
printf("		console.log(\"ClassInternalPopup.hide method invoked.\");");
printf("		if(typeof handle_setTimeout!==\"undefined\"){clearTimeout(handle_setTimeout);}");			//if an auto-timeout hide is active, clear it, since we've essentially cancelled the auto timeout at this point
printf("		if(typeof handle_setInterval!==\"undefined\"){");							//if an auto-timeout countdown is active, clear it, since we've essentially cancelled the auto timeout at this point, and reset button
printf("			clearInterval(handle_setInterval);");
//printf("			this.restoreButtons();");
printf("		}");//end if setInterval
printf("		var node_iframe = false;");
printf("		YUI().use('node', function(Y){");
printf("			node_iframe = Y.one(\"#internalPopupBodyContent\").getDOMNode();");				//get a DOM reference to the panel's iframe node, using YUI
printf("			});");
printf("		if(typeof intDelayMs===\"undefined\" || isNaN(intDelayMs)){");						//if no delay argument was provided, go ahead and hide the panel
printf("			node_iframe.style.display = \"none\";");
printf("			yuiPanel.hide();");
printf("		}");
printf("		else if(parseInt(intDelayMs)>50){");									//else-if delay argument is substantially long enough to have a chance of doing anything, set it to hide on delay
printf("			handle_setTimeout = setTimeout(function(){");
printf("				node_iframe.style.display = \"none\";");
printf("				yuiPanel.hide();");
printf("				}, parseInt(intDelayMs));");//end settimeout function
printf("		}");
printf("		else{");												//else all other unforseen cases, just hide it immediately
printf("			node_iframe.style.display = \"none\";");
printf("			yuiPanel.hide();");
printf("		}");
printf("		hideNativeSpinner();");
//printf("		this.currentWindow = null;");										//clear the exposed window reference
printf("		return true;");
printf("		};");//end method definition for hide()
printf("}\n");//end function
/*
printf("function ClassReusableYuiPanel(instanceName, objButtons){");
printf("	YUI().use('panel', function(Y){");
printf("		var dialog = new Y.Panel({");
printf("			contentBox	: Y.Node.create('<div id=\"popupPanelContentBox\"></div>'),");
printf("			bodyContent	: '<div class=\"bodyContents\"></div>',");
printf("			width		: '95%%',");
printf("			zIndex		: 6,");
printf("			centered	: true,");
printf("			modal		: false,");
printf("			render		: '.example',");
printf("			visible		: false,");		//make visible explicitly with .show()
//printf("			buttons		: {");
//printf("				footer: [");
//printf("				{");
//printf("				name	: 'cancel',");
//printf("				label	: 'Cancel',");
//printf("				action	: 'onCancel'");
//printf("				},{");
//printf("				name	: 'proceed',");
//printf("				label	: 'OK',");
//printf("				action	: 'onOk'");
//printf("				}]}");
printf("			buttons		: objButtons");
printf("			});");//end new Y.Panel
printf("		dialog.onCancel = function(e){");
printf("			e.preventDefault();");
printf("			this.hide();");
printf("			this.callback = false;");		//the callback is not executed, and its callback reference is removed so it won't persist
printf("			};");//end onCancel
printf("		dialog.onOk = function(e){");
printf("			e.preventDefault();");
printf("			this.hide();");
printf("			if(this.callback){");			//code that executes the user-confirmed action goes here...
printf("				this.callback();");
printf("			}");
printf("			this.callback = false;");		//the callback reference is removed so it won't persist
printf("			};");//end onOk
printf("		");
printf("		");
printf("		");
printf("		});");//end YUI.use
printf("	");
*/
/*
Y.one('.btn-show').on('click', function(){
    // set the content you want in the message
    Y.one('#popupPanelContentBox .bodyContents').setHTML('Are you sure you want to [take some action]?');
    
    // set the callback to reference a function
    dialog.callback = doSomething; 
    
    dialog.show();
});
*/
/*
printf("	");
printf("}\n");//end function
printf("var objExampleConfirmDialog_buttons = {footer:[{name:'cancel',label:'Cancel',action:'onCancel'},{name:'proceed',label:'OK',action:'onOk'}]};");
printf("var ExampleConfirmDialog = new ClassReusableYuiPanel(\"ExampleConfirmDialog\", objExampleConfirmDialog_buttons);");
*/
printf("function CreateAlternateSession_oldWayFromFavs(session_only_or_recno, alt_directory_recno, form_state, secondary_form_state, proxy_pin_sort_recno, alt_directory_reply_mode){");
printf("	if(isLoadedInMobileApp()){ if(FavScreen.initialized){FavScreen.log('info',\"CreateAlternateSession...() not allowed in mobile app. Aborting.\",false);} return false; }");	//if loaded in mobile app, abort this function
printf("	if(typeof FavScreen===\"object\"){FavScreen.log('log',\"CreateAlternateSession popping new window for full system.\",false);}");
printf("	var win_id = new Date();");
printf("	var win_str = 'SMAltSession'+win_id.getTime();");
printf("	onload_auto_submit = \"%s\";", NEW_WINDOW_ONLOAD_DELAY_SUBMIT);
printf("	win = window.open('', win_str, '%s,height=600,width=800,%s');", window_options, HTML_WINDOW_OPEN_LOCATION);
CGI_CHECK_VALID_WINDOW_JAVASCRIPT;
printf("	str = '<HTML>';");
CGI_POP_WINDOW_STYLE;
printf("	str+='<BODY bgcolor=\"%s\" onLoad=\"'+onload_auto_submit+'\">';", main_bgcolor);
printf("	str+='<FORM action=%s method=post>';", cgi_server);
printf("	str+='<INPUT type=\"hidden\" name=\"loadAltSession\" value=\"\"></INPUT>';");
printf("	str+='<INPUT type=\"hidden\" name=\"session_only_or_recno\" value=\"'+session_only_or_recno+'\"></INPUT>';");
printf("	str+='<INPUT type=\"hidden\" name=\"alt_directory_reply_record\" value=\"'+alt_directory_recno+'\"></INPUT>';");
printf("	str+='<INPUT type=\"hidden\" name=\"form_state\" value=\"'+form_state+'\"></INPUT>';");
printf("	str+='<INPUT type=\"hidden\" name=\"alt_session_form_state\" value=\"'+form_state+'\"></INPUT>';");
printf("	str+='<INPUT type=\"hidden\" name=\"alt_session_secondary_form_state\" value=\"'+secondary_form_state+'\"></INPUT>';");
printf("	str+='<INPUT type=\"hidden\" name=\"alt_session_proxy_pin_sort_recno\" value=\"'+proxy_pin_sort_recno+'\"></INPUT>';");
printf("	str+='<input type=\"hidden\" name=\"disableCheckForIP_favorites\" value=\"'+determineShouldIgnoreChangeInIP()+'\">';");
printf("	if(document.forms[0].personal_page_stream_record)");
printf("		str+='<INPUT type=\"hidden\" name=\"personal_page_stream_record\" value=\"'+document.forms[0].personal_page_stream_record.value+'\"></INPUT>';");
printf("	if(document.forms[0].personal_page_stream_archive_number)");
printf("		str+='<INPUT type=\"hidden\" name=\"personal_page_stream_archive_number\" value=\"'+document.forms[0].personal_page_stream_archive_number.value+'\"></INPUT>';");
printf("	if(document.forms[0].alt_directory_reply_mode)");
printf("		str+='<INPUT type=\"hidden\" name=\"alt_directory_reply_mode\" value=\"'+document.forms[0].alt_directory_reply_mode.value+'\"></INPUT>';");
//if(notjustspace(proxy_hold_current_user_pin, PIN_LENGTH))
//	{
//	printf("	str+='<INPUT type=\"hidden\" name=\"%s\" value=\"%s\"></INPUT>';", cgi_identification_field, cgi_EncodeLoginPin(proxy_hold_current_user_pin));
//	}
//else
//	{
	printf("	str+='<INPUT type=\"hidden\" name=\"%s\" value=\"%s\"></INPUT>';", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
//	}
printf("	str+='Loading New Session...';");
printf("	str+='</FORM>';");
printf("	str+='</BODY>';");
printf("	str+='</HTML>';");
printf("	win.document.write(str);");
printf("	win.document.close();");
printf("	return false;");
printf("}\n");//end function CreateAlternateSession_oldWayFromFavs()

printf("var setGeoLocationAttributes_maxRetries = 10;");							//set the max number of retries, in case the client can't get geolocation data for some reason (usually because it's a normal PC browser or something)
printf("function setGeoLocationAttributes(){");									// Call the geolocation API and try to set the geolocation attributes in the FavScreen class 
printf("	if(navigator.geolocation){");										//test whether the browser supports geolocation...
printf("		var geoGetLoc_success = function(pos){");
printf("			if(typeof FavScreen===\"undefined\"){");							//if our class doesn't exist, then we can't save our attributes
printf("				console.warn(\"setGeoLocationAttributes(): The 'FavScreen' class isn't instantiated, so cannot save geolocation attributes. Aborting function.\");");
printf("				return false;");
printf("			}");
printf("			if(typeof pos===\"undefined\"){");								//probably not necessary, but just to be safe
printf("				FavScreen.log('warn',\"setGeoLocationAttributes(): getCurrentPosition returned 'undefined'. Client cannot give us geolocation data.\",false);");
printf("			}else{");
printf("				FavScreen.log('log',\"setGeoLocationAttributes(): Success... now setting attrGeoLocation attributes with '\"+JSON.stringify(pos)+\"'.\",false);");
printf("				FavScreen.set('attrGeoLocation_last', pos);");							//set attribute with the Geoposition object returned by the call back to here
printf("				FavScreen.set('attrGeoLocation_lastUpdated', new Date(pos.timestamp));");			//set attribute with the Geoposition object's timestamp (full-length, gorey detail version) 
printf("				FavScreen.set('attrGeoLocation_lastLongitude', pos.coords.longitude);");			//set attribute with Geoposition's longitude value (an integer)
printf("				FavScreen.set('attrGeoLocation_lastLatitude', pos.coords.latitude);");				//set attribute with Geoposition's latitude value (an integer)
printf("				FavScreen.set('attrGeoLocation_lastAltitude', pos.coords.altitude);");				//set attribute with Geoposition's altitude value (an integer)
printf("				FavScreen.set('attrGeoLocation_lastAccuracy', pos.coords.accuracy);");				//set attribute with Geoposition's accuracy value (an integer)
printf("			}");
printf("			};");//end geoGetLoc definition
printf("		var geoGetLoc_error = function(err){");
printf("			switch(err.code){");
printf("				case err.PERMISSION_DENIED:");
printf("					FavScreen.log('info',\"setGeoLocationAttributes(): User denied the request for Geolocation. Also cancelling any interval-based retries that may exist...\",false);");
printf("					if(geolocationUpdateIntervalHandle!=false){");
printf("						FavScreen.log('info',\"setGeoLocationAttributes(): Permission Denied. Maximum retries reached, clearing interval.\",true);");
printf("						clearInterval(geolocationUpdateIntervalHandle);");
printf("						geolocationUpdateIntervalHandle = false;");						//just to be safe, also re-initialize it
printf("					}");
printf("					break;");
printf("				case err.POSITION_UNAVAILABLE:");
printf("					FavScreen.log('info',\"setGeoLocationAttributes(): Location information is unavailable from the client.\",false);");
printf("					setGeoLocationAttributes_maxRetries--;");
printf("					if(setGeoLocationAttributes_maxRetries<1){");
printf("						FavScreen.log('info',\"setGeoLocationAttributes(): Location Unavailable. Maximum retries reached, clearing interval.\",true);");
printf("						clearInterval(geolocationUpdateIntervalHandle);");
printf("						geolocationUpdateIntervalHandle = false;");						//just to be safe, also re-initialize it
printf("					}");
printf("					break;");
printf("				case err.TIMEOUT:");
printf("					FavScreen.log('warn',\"setGeoLocationAttributes(): The request to get user location timed out.\",false);");
printf("					setGeoLocationAttributes_maxRetries--;");
printf("					if(setGeoLocationAttributes_maxRetries<1){");
printf("						FavScreen.log('info',\"setGeoLocationAttributes(): Timeout. Maximum retries reached, clearing interval.\",true);");
printf("						clearInterval(geolocationUpdateIntervalHandle);");
printf("						geolocationUpdateIntervalHandle = false;");						//just to be safe, also re-initialize it
printf("					}");
printf("					break;");
printf("				case err.UNKNOWN_ERROR:");
printf("				default:");
printf("					FavScreen.log('error',\"setGeoLocationAttributes(): An unknown error occurred.\",false);");
printf("					setGeoLocationAttributes_maxRetries--;");
printf("					if(setGeoLocationAttributes_maxRetries<1){");
printf("						FavScreen.log('info',\"setGeoLocationAttributes(): Unknown Error. Maximum retries reached, clearing interval.\",true);");
printf("						clearInterval(geolocationUpdateIntervalHandle);");
printf("						geolocationUpdateIntervalHandle = false;");						//just to be safe, also re-initialize it
printf("					}");
printf("					break;");
printf("				}");//end switch
printf("			};");//end geoGetLoc_error definition
printf("		var geoGetLoc_options = {");
printf("			enableHighAccuracy:false,");										//boolean to indicate whether to receive the best possible results (note, this could result in high battery drain in some cases)
printf("			timeout:10000,");											//maximum length of time (in milliseconds) the device is allowed to take in order to return a position (default is infinity)
printf("			maximumAge:11000");											//maximum age (in milliseconds) of a possible cached position that is acceptable to return
printf("			};");//end geoGetLoc_options definition
printf("		try{");
printf("			navigator.geolocation.getCurrentPosition(geoGetLoc_success, geoGetLoc_error, geoGetLoc_options);");
printf("			navigator.geolocation.getHighlyAccurateCurrentPosition(geoGetLoc_success, geoGetLoc_error, function(){return}, {desiredAccuracy:80, maxWait:15000});");
printf("		}catch(err){");
printf("			FavScreen.log('error',\"setGeoLocationAttributes(): Error calling getCurrentPosition... \"+err,true);");
printf("			return false;");
printf("		}");
printf("	}");
printf("	else{");
printf("		FavScreen.log('warn', \"Geolocation is not supported by this browser.\", true);");
printf("		return false;");
printf("	}");
printf("}\n");//end function setGeoLocationAttributes()

/* Setup array structure and support for tracking/handling toggle data... */
/*
printf("var arrToggleData = [];");	//initialize the global array (will be two-dimensional)
printf("var atdFavRecno = 0;");		//define field index for favorite-template-recno
printf("var atdActiveCopyRecno = 1;");	//define field index for active-copy-recno
printf("var atdToggleDuration = 2;");	//define field index for defined toggle duration
printf("var atdLaunchDtsec = 3;");	//define field index for when the message was launched
printf("function arrToggleData_add(fr,acr,td,ld){");	// Add an element to the array (e.g. whenever a toggle-able message is launched)... if matching fav exists, update it with new active-copy data
printf("	if(isNaN(fr)){");			//should always be represented as a number
printf("		FavScreen.log('warn',\"arrToggleData_add(): required parameter, favorite-recno, is invalid or missing.\",false);");
printf("		return false");
printf("	}else if(acr.toString().length<2){");	//no value should be length of 0, minimal possible value would be length of 2 (e.g. "1,")
printf("		FavScreen.log('warn',\"arrToggleData_add(): required parameter, active-copy-recno, is invalid or missing.\",false);");
printf("		return false");
printf("	}else if(isNaN(td)){");			//stored as an integer representing seconds
printf("		FavScreen.log('warn',\"arrToggleData_add(): required parameter, toggle-duration, is invalid or missing.\",false);");
printf("		return false");
printf("	}else if(isNaN(ld)){");			//stored as a string of numbers
printf("		FavScreen.log('warn',\"arrToggleData_add(): required parameter, launch-date/timestamp, is invalid or missing.\",false);");
printf("		return false");
printf("	}else{");
printf("		var arr = [parseInt(fr), acr.toString(), parseInt(td), ld.toString()];");
printf("		var len=arrToggleData.length;");
printf("		if(len<arrToggleData.push(arr)){");				//if original array length was less than the new length (now that we've appended the new data), then add was successful (push method returns new length value after append)
printf("			FavScreen.log('log',\"arrToggleData_add(): new toggle data (\"+arr+\") added to array.\",false);");
printf("			return true;");
printf("		}else{");
printf("			FavScreen.log('error',\"arrToggleData_add(): push() method apparently failed to append new toggle data (\"+arr+\") to array.\",false);");
printf("			return false;");
printf("		}");
printf("	}");
printf("}\n");//end function arrToggleData_add()
printf("function arrToggleData_remove(fr){");		// Remove an element from the array (e.g. whenever a toggle-able message is ended)
printf("	if(isNaN(fr)){");
printf("		FavScreen.log('warn',\"arrToggleData_remove(): required parameter is invalid or missing.\",false);");
printf("		return false");
printf("	}else{");
printf("		if(arrToggleData.length>0){");
printf("			fr=parseInt(fr);");
printf("			for(var i=0, len=arrToggleData.length; i<len; i++){");	//loop with length-caching (makes faster)
printf("				if(arrToggleData[i][atdFavRecno]==fr){");
printf("					arrToggleData.splice(i,1);");		//remove the element from the array, in-place, and reindex it
printf("					FavScreen.log('log',\"arrToggleData_remove(): removed element #\"+i+\" from the array (fav recno \"+fr+\").\",false);");
printf("					return true;");
printf("				}");//end if
printf("			}");//end for
printf("		}else{");
printf("			FavScreen.log('info',\"arrToggleData_remove(): arrToggleData is empty, nothing to do.\",false);");
printf("			return false");
printf("		}");//end else
printf("	}");//end else
printf("}\n");//end function arrToggleData_remove()
printf("function arrToggleData_load(){");		// Load the array with current active-copy information from the   DEV-NOTE: need to initially call from first load of recordset... then on subsequent refresh calls
printf("	if(typeof FavScreen===\"undefined\"){");		//if our main class doesn't exist...
printf("		console.error(\"arrToggleData_load(): FavScreen object does not exist, aborting.\");");
printf("		return false;");
printf("	}else if(typeof FavScreen.rsOrig===\"undefined\"){");	//if our main recordset doesn't exist...
printf("		FavScreen.log('error',\"arrToggleData_load(): FavScreen.rsOrig does not exist, aborting.\",true);");
printf("		return false;");
printf("	}else{");
printf("		var fr,acr,td,ld;");					//declare vars so we don't have to with each loop iteration later
printf("		if(typeof FavScreen.rsRecentDB===\"undefined\"){");	//if rsRecentDB doesn't exist, then this might be an initial load so use rsOrig's data to load the array
printf("			var rs = rs_getRecordsetOf_favsWithActiveCopies(FavScreen.rsOrig);");
printf("		}else{");						//else use the most recent data from rsRecentDB
printf("			var rs = rs_getRecordsetOf_favsWithActiveCopies(FavScreen.rsRecentDB);");
printf("		}");
printf("		var numSuccessfullyAdded = 0;");			//initialize a var for tracking how many records were successfully added to the array (so we have something meaningful to both test for and return
printf("		for(var i=0, len=rs.size(); i<len; i++){");		//for each favorite record in the recordset, load the array with appropriate data
printf("			fr = rs.item(i).getValue('recno_fav');");
printf("			acr = rs.item(i).getValue('active_copies');");
printf("			td = rs.item(i).getValue('toggle_duration');");
printf("			ld = rs.item(i).getValue('dtsec');");
printf("			if(arrToggleData_add(fr,acr,td,ld)){");		//if successfully appended this record's data to the array
printf("				");
printf("				numSuccessfullyAdded++;");
printf("			}else{");					//else failed to append this record's data to the array
printf("				FavScreen.log('error',\"arrToggleData_load(): failure to successfully complete call to arrToggleData_add() for favorite recno \"+fr+\".\",true);");
printf("			}");
printf("		}");
printf("		return numSuccessfullyAdded;");
printf("	}");
printf("}\n");//end function arrToggleData_load()
printf("function arrToggleData_check(){");		// Go through the array and see whether any have ended... take care of updating, if so. DEV-NOTE: consider recursion?
//printf("	");
printf("}\n");//end function arrToggleData_remove()
*/

/* Define a method of handling what should be standard server responses */
//printf("function handleStandardServerResponses(strResponse){");
// TO-DO
//printf("}");

/* Create our custom Class... */
printf("var FavScreen;\n");											// Declare a global for the class we'll create next
printf("YUI().use(\"attribute\", \"node\", \"event\", \"io\", \"io-base\", function(Y){");			// Get a YUI instance (so we can setup a class object for this page's configuration, etc.)

printf("	function ClassFavScreen(strInstanceName, cfg){\n");						// Define/configure our custom class... (in JavaScript, this is synonymous with a standard function - it's just called differently --- with the 'new" keyword (see below))
printf("		var attrs={\n");										//define an object-literal of what will become initial attributes
printf("			'attrYuiUA'					:{value: YUI.Env.UA.userAgent},\n");		//attribute for storing the YUI-derived UA string
printf("			'attrIsMobileDevice'				:{value: isLoadedInMobileApp()},\n");		//attribute for storing whether this is loaded on a mobile device or not
printf("			'attrMobileDeviceType'				:{value: YUI.Env.UA.mobile},\n");		//attribute for storing the type of mobile device this may be loaded on (PC is null, iOS is "Apple", Android is "Android")
printf("			'attrDeviceType'				:{value: undefined},\n");			//attribute for storing the type of device this may be loaded on (phone, tablet, pc, etc.) -- used for confirmSend checking
printf("			'attrBrowserSupports_dataset' 			:{value: false},\n");				//attribute for storing whether the browser supports dataset
printf("			'attrBrowserSupports_scrollY' 			:{value: false},\n");				//attribute for storing whether the browser supports scrollY
printf("			'attrInteractionMode'				:{value: MODE_LAUNCHABLE},\n");			//attribute for the favorite screen's modality (intially set to a mode that allows immediate click/tap to launch)
printf("			'attrInteractionMode_prev'			:{value: undefined},\n");			//attribute for the favorite screen's previous modality
printf("			'attrLayoutMode'				:{value: LAYOUT_LIST},\n");			//attribute for the favorite screen's layout (intially set to the list-style layout)
printf("			'attrDeviceOrientation'				:{value: undefined},\n");			//attribute for storing device/screen orientation
printf("			'attrWindowWidth'				:{value: window.innerWidth},\n");		//attribute for storing window width (minus any browser toolbars, scrollbars, etc.)
printf("			'attrWindowHeight' 				:{value: window.innerHeight},\n");		//attribute for storing window height (minus any browser toolbars, scrollbars, etc.)
printf("			'attrHeaderWrapperHeight' 			:{value: undefined},\n");			//attribute for storing the height of the headerwrapper node
printf("			'attrBodyWrapperHeight' 			:{value: undefined},\n");			//attribute for storing the height of the bodywrapper node (gets calculated from window height minus header and wrapper)
printf("			'attrFooterWrapperHeight' 			:{value: undefined},\n");			//attribute for storing the height of the footerwrapper node
printf("			'attrCurrentScrollPositionPixelY' 		:{value: 0},\n");				//attribute for storing current scroll position in Y-axis pixels
printf("			'attrPreviousScrollPositionPixelY' 		:{value: 0},\n");				//attribute for storing a previous scroll position in Y-axis pixels (useful for jumping back to a previous position after some other action)
printf("			'attrNumSortedFavsDisplaying'			:{value: -1},\n");				//attribute for storing currently-showing-on-screen sorted favs
printf("			'attrNumUnsortedFavsDisplaying'			:{value: -1},\n");				//attribute for storing currently-showing-on-screen unsorted favs
printf("			'attrNumDeletedFavsDisplaying'			:{value: -1},\n");				//attribute for storing currently-showing-on-screen deleted favs 
printf("			'attrIsCurrentlyVisible_sorted'			:{value: false},\n");				//attribute for storing current rendered state of sorted favorites
printf("			'attrIsCurrentlyVisible_unsorted'		:{value: false},\n");				//attribute for storing current rendered state of non-sorted favorites 
printf("			'attrIsCurrentlyVisible_deleted'		:{value: false},\n");				//attribute for storing current rendered state of deleted favorites
printf("			'attrNumOfLibrariesAvailable'			:{value: 0},\n");				//attribute for storing the number of libraries available in the system (the server's number of LIB-users)... used in order to determine whether we've read all in and rendering can start
printf("			'attrNumOfLibrariesMsgSetsReadIn'		:{value: 0},\n");				//attribute for counting how many libraries' message-sets have been read-in at load time (or refresh, etc.)... so we know when to render
printf("			'attrGeoLocation_last'				:{value: undefined},\n");			//attribute for storing the html-ascertained last geolocation (object) of the device (if supported)... "last," because if they move w/out reloading, it will have changed
printf("			'attrGeoLocation_lastUpdated'			:{value: undefined},\n");			//attribute for storing the html-ascertained last geolocation (timestamp) of the device (if supported)... "last," because if they move w/out reloading, it will have changed
printf("			'attrGeoLocation_lastLongitude'			:{value: 0},\n");				//attribute for storing the html-ascertained last longitude of the device (if supported)... "last," because if they move w/out reloading, it will have changed
printf("			'attrGeoLocation_lastLatitude'			:{value: 0},\n");				//attribute for storing the html-ascertained last latitude of the device (if supported)... "last," because if they move w/out reloading, it will have changed
printf("			'attrGeoLocation_lastAltitude'			:{value: 0},\n");				//attribute for storing the html-ascertained last altitude of the device (if supported)... "last," because if they move w/out reloading, it will have changed
printf("			'attrGeoLocation_lastAccuracy'			:{value: 0},\n");				//attribute for storing the html-ascertained last accuracy of the device (if supported)... "last," because if they move w/out reloading, it will have changed
printf("			'attrGeoLocation_native_last'			:{value: undefined},\n");			//attribute for storing the natively-ascertained last geolocation (object) of the device (if supported)... last, because if they move w/out reloading, it will have changed
					//iOS string ex: "-+39.96121422,-86.12488932> +/- 65.00m (speed -1.00 mps / course -1.00) @ 11/18/14, 8:46:58 AM Eastern Standard Time"
printf("			'attrGeoLocation_native_lastUpdated'		:{value: undefined},\n");			//attribute for storing the natively-ascertained last geolocation (timestamp) of the device (if supported)... last, because if they move w/out reloading, it will have changed
printf("			'attrGeoLocation_native_lastLongitude'		:{value: 0},\n");				//attribute for storing the natively-ascertained last longitude of the device (if supported)... last, because if they move w/out reloading, it will have changed
printf("			'attrGeoLocation_native_lastLatitude'		:{value: 0},\n");				//attribute for storing the natively-ascertained last latitude of the device (if supported)... last, because if the move w/out reloading, it will have changed
printf("			'attrGeoLocation_native_lastAltitude'		:{value: 0},\n");				//attribute for storing the natively-ascertained last altitude of the device (if supported)... last, because if the move w/out reloading, it will have changed
printf("			'attrGeoLocation_native_lastAccuracyCoord'	:{value: 0},\n");				//attribute for storing the natively-ascertained last latitudinal/longitudinal accuracy of the device (if supported)... last, because if they move w/out reloading, it will have changed
printf("			'attrGeoLocation_native_lastAccuracyAlt'	:{value: 0},\n");				//attribute for storing the natively-ascertained last altitude accuracy of the device (if supported)... last, because if they move w/out reloading, it will have changed
printf("			'attrExecuteJavaScriptOnChange'			:{value: false},\n");				//special attribute for triggering some action... value should be a string version of whatever JavaScript you want to execute
printf("			'attrLastFocused_window'			:{value: Date.now()},\n");			//attribute for storing the timestamp of most recent focus state change (note: affects window clicks intended to re-focus a window)
printf("			'attrLastFocused_native'			:{value: \"\"},\n");				//attribute for storing the timestamp of most recent focus state change as provided by the native app
printf("			'attrWindowLastLoadedTimestamp'			:{value: Date.now()},\n");			//attribute for storing the timestamp of when the document was last loaded
printf("			'attrZoom'					:{value: \"100%%\"},\n");			//attribute for storing the user-specified zoom level
printf("			'attrLastRefreshTimestamp'			:{value: 0},\n");				//attribute for storing the last timestamp that a refreshRecordset operation ocurred
printf("			'attrLastRefreshTimestamp_inboxMsgs'		:{value: 0},\n");				//attribute for storing the last timestamp that a refreshRecordset_inboxMsgs operation ocurred
printf("			'attrLastRefreshTimestamp_stdReplyLibMsgs'	:{value: 0},\n");				//attribute for storing the last timestamp that a refreshRecordset_stdReplyLibMsgs operation ocurred
//printf("			'attrLastRefreshTimestamp_stdLibMsgs'		:{value: 0},\n");				//attribute for storing the last timestamp that a refreshRecordset_stdLibMsgs operation ocurred
printf("			'attrJumpScrollToTopLastTimestamp'		:{value: 0},\n");				//attribute for storing the last timestamp that the user did a jump to top operation
printf("			'attrJumpScrollToAux1LastTimestamp'		:{value: 0},\n");				//attribute for storing the last timestamp that the user did a jump to top of aux-1 operation
printf("			'attrJumpNavLastPressedTimestamp'		:{value: 0},\n");				//attribute for storing the last timestamp that the user pressed a jump-navigation button
printf("			'attrLastScrolledTimestamp'			:{value: 0},\n");				//attribute for storing the last timestamp that the user scrolled
printf("			'attrFinishedInitialLoading_timestamp'		:{value: 0},\n");				//attribute for storing the timestamp that we believe the initial-load should have finished at
printf("			'attrDtsec'					:{value: \"%s\"},\n", dtsec);			//attribute for the approximate server-provided dtsec in which the favorite screen was loaded (may be required by some legacy smcgi logic)
printf("			'attrDtsecJS'					:{value: new Date/1E3|0},\n");			//attribute for the client-provided dtsec in which the favorite screen was loaded
printf("			'attrDtsecJS_current_15s'			:{value: new Date/1E3|0},\n");			//attribute for the client-provided dtsec, where we'll keep the current elapsing time (with 15-second resolution) ~ intended to be kept "current" via setInterval updates
printf("			'attrVersion'					:{value: \"%s\"},\n", FAVS_VERSION);		//attribute for the Favorites' version number
printf("			'attrBuild'					:{value: \"%s\"},\n", FAVS_BUILD);		//attribute for the Favorites' build (not C-compiler based, but ready for it - like JS-stable or ready-to-compile)
printf("			'attrJumpNavMode'				:{value: MODE_JUMPNAV_DOWN},\n");		//attribute for the favorite screen's present jump-navigation modality (up or down)
printf("			'attrCurrentResponseRule'			:{value: ENCODED_RESPONSE_RULE_0},\n");		//attribute for storing an encoded response rule
printf("			'objPopupOpener'				:{value: undefined},\n");			//space for saving a window object referencing the window that opens a popup (see below...)
printf("			'objPopupWindow'				:{value: undefined},\n");			//space for saving a window-like object that was originally meant to be a popup window (needs to go here, so we can listen for changes and fire a substitute YUI Panel instead of popup)
printf("			'objPopupDocument'				:{value: undefined}\n");			//space for saving a document object that was originally meant to populate a popup window (needs to go here, so we can listen for changes and fire a substitute YUI Panel instead of popup)
printf("			};");
printf("		this.addAttrs(attrs, cfg);\n");									//instruct to add the above attrs (and anything passed in through cfg, if applicable) to our custom class

printf("		this.sessionLog = [];\n");									//declare an array that will be used for storing session log information

printf("		this.log = function(t,s,c){");									//define a method, log(), for logging stuff... requires type ('verbose'|'log'|'info'|'warn'|'error'), message string to log, and whether to output to console (defaults to false)
printf("			var forceConsoleLogOutput = Boolean(%d);", FORCE_CONSOLE_LOGGING_ON);					//NOTE: turn this on/off in the smcgi_favorites.h file
printf("			cfg_disableLogging_verbose = Boolean(%d);", configuration_lookup_integer(DB_PATH_LOCATION, "SMCGI_FAVS_DISABLE_LOGGING_LEVEL_VERBOSE", 1));
printf("			cfg_disableLogging_log = Boolean(%d);", configuration_lookup_integer(DB_PATH_LOCATION, "SMCGI_FAVS_DISABLE_LOGGING_LEVEL_LOG", 1));
printf("			cfg_disableLogging_info = Boolean(%d);", configuration_lookup_integer(DB_PATH_LOCATION, "SMCGI_FAVS_DISABLE_LOGGING_LEVEL_INFO", 1));
printf("			cfg_disableLogging_warn = Boolean(%d);", configuration_lookup_integer(DB_PATH_LOCATION, "SMCGI_FAVS_DISABLE_LOGGING_LEVEL_WARN", 0));
printf("			cfg_disableLogging_error = Boolean(%d);", configuration_lookup_integer(DB_PATH_LOCATION, "SMCGI_FAVS_DISABLE_LOGGING_LEVEL_ERROR", 0));
printf("			var overrideServerConfiguredLoggingFlags = true;");	//NOTE: update this later
printf("			if(overrideServerConfiguredLoggingFlags) {");
printf("				cfg_disableLogging_verbose = false;");
printf("				cfg_disableLogging_log = false;");
printf("				cfg_disableLogging_info = false;");
printf("				cfg_disableLogging_warn = false;");
printf("				cfg_disableLogging_error = false;");
printf("			}");
printf("			if(typeof t===\"undefined\" || typeof s===\"undefined\"){");					//validate required method arguments
printf("				console.warn('ClassFavScreen.log() method requires two arguments.');");
printf("				return false;");
printf("			}");
printf("			t = t.toUpperCase();");										//standardize log-type to upper case (no particular reason, really, just looks nicer)
printf("			if(t!=\"VERBOSE\" && t!=\"LOG\" && t!=\"INFO\" && t!=\"WARN\" && t!=\"ERROR\"){");		//validate log-type argument
printf("				console.warn(\"ClassFavScreen.log() method requires valid log-type argument. '\"+t+\"' != VERBOSE|LOG|INFO|WARN|ERROR\");");
printf("				return false;");
printf("			}");
printf("			if(t=='VERBOSE' && cfg_disableLogging_verbose) {");
printf("				return false;");
printf("			}");
printf("			if(t=='LOG' && cfg_disableLogging_log) {");
printf("				return false;");
printf("			}");
printf("			if(t=='INFO' && cfg_disableLogging_info) {");
printf("				return false;");
printf("			}");
printf("			if(t=='WARN' && cfg_disableLogging_warn) {");
printf("				return false;");
printf("			}");
printf("			if(t=='ERROR' && cfg_disableLogging_error) {");
printf("				return false;");
printf("			}");
printf("			c = Boolean(c);");										//ensure argument value is boolean
printf("			if(forceConsoleLogOutput) {c = true;}");
printf("			var newEntryIndex = this.sessionLog.length;");							//.length is 1-based, so it can serve as the new entry's index in the 0-based array
printf("			var d = new Date();");										//grab a snapshot of the current date-time
printf("			function lz1(s){if(s<10){return '0'+s.toString();}else{return s.toString();}}");		//add up to 1 leading zero
printf("			function lz2(s){if(s<10){return '00'+s.toString();}else if(s<100){return '0'+s.toString();}else{return s.toString();}}");//add up to 2 leading zeros
printf("			var ds = d.getFullYear()+'.'+lz1(d.getMonth()+1)+'.'+lz1(d.getDate())+'-'+lz1(d.getHours())+':'+lz1(d.getMinutes())+':'+lz1(d.getSeconds())+':'+lz2(d.getMilliseconds());");//construct data-timestamp string to be logged
printf("			this.sessionLog[newEntryIndex] = {");								//create a new log entry object
printf("				date: ds,");										//log the formatted date and time info
printf("				type: t,");										//log the type of log entry
printf("				desc: s");										//log the desc of log entry (this is the 'meat' of the log)
printf("				};");//end log entry object
/* Rob's method for exposing JavaScript console logging to UIWebView's console... */
//printf("var xhr = new XMLHttpRequest();");
//printf("xhr.open('GET', \"http://debugger/\"+encodeURIComponent(s));");
//printf("xhr.send(null);");
printf("			if(c){");											//if we should output to console
printf("				try{");
printf("					var sr = s.replace(/\"/g,\"`\");");
printf("					var sr = sr.replace(/'/g,\"`\");");
printf("					if(t==\"VERBOSE\" || t==\"LOG\"){");
printf("						console.log(sr);");
printf("					}else if(t==\"INFO\"){");
printf("						console.info(sr);");
printf("					}else if(t==\"WARN\"){");
printf("						console.warn(sr);");
printf("					}else if(t==\"ERROR\"){");
printf("						console.error(sr);");
printf("					}");
printf("				}");
printf("				catch(err){");
printf("					console.warn(\"ClassFavScreen.log() method could not output to the console (\"+err.message+\").\");");
printf("				}");
printf("			}");
printf("			return this.sessionLog[newEntryIndex];");							//return the logged entry
printf("			};\n");//end .log method definition

printf("		this.logDumpToConsole = function(){");									//define a method to output the complete log history to the client console
printf("			try{");
printf("				for(var i=0; i<this.sessionLog.length; i++){");
printf("					var s = this.sessionLog[i].desc;");
printf("					if(typeof s===\"object\"){s=JSON.stringify(s);}");
printf("					var sr = s.replace(/\"/g,\"`\");");
printf("					var sr = sr.replace(/'/g,\"`\");");
printf("					var t = this.sessionLog[i].type;");
printf("					var d = this.sessionLog[i].date;");
printf("					var so = d+' - '+sr;");
printf("					if(t==\"LOG\"){");
printf("						console.log(so);");
printf("					}else if(t==\"INFO\"){");
printf("						console.info(so);");
printf("					}else if(t==\"WARN\"){");
printf("						console.warn(so);");
printf("					}else if(t==\"ERROR\"){");
printf("						console.error(so);");
printf("					}");
printf("				}");//end for
printf("			}");//end try
printf("			catch(err){");
printf("				console.warn(\"ClassFavScreen.logDumpToConsole() method error: \"+err.message);");
printf("			}");//end catch
printf("			return \"End ClassFavScreen.logDumpToConsole()\";");
printf("			};\n");//end .logDumpToConsole method definition

printf("		this.logSaveToFile = function(){");									//define a method to save the session log to a file (only works on PC browsers?)
printf("			try{");
printf("				var filename = \"FavoritesClientSessionLog.txt\";");
printf("				data = JSON.stringify(FavScreen.sessionLog, undefined, 4);");
printf("				var blob = new Blob([data], {type: 'text/json'});");
printf("				var e = document.createEvent('MouseEvents');");
printf("				var a = document.createElement('a');");
printf("				a.download = filename;");
printf("				a.href = window.URL.createObjectURL(blob);");
printf("				a.dataset.downloadurl =  ['text/json', a.download, a.href].join(':');");
printf("				e.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);");
printf("				a.dispatchEvent(e);");
printf("			}");//end try
printf("			catch(err){");
printf("				console.warn(\"ClassFavScreen.logSaveToFile() method error: \"+err.message);");
printf("			}");//end catch
printf("			};\n");//end .logSaveToFile method definition

printf("		this.logSaveToServer = function(){");
printf("			FavScreen.log('log', \"ClassFavScreen.logSaveToServer(): Save log to server...\", true);");
				//various functions to reduce the data that gets logged to the server's browser/smcgi log...
printf("			function stripObjMemberLabels_fromJsonStringified(str) {");
printf("				var regex_date = new RegExp('{\"date\":', 'g');");	//regular expression to find all "date" labels		NOTE: if you migrate this to a JS file, remember to remove the backslash escape characters before the double-quote characters.
printf("				var regex_type = new RegExp(',\"type\":', 'g');");	//regular expression to find all "type" labels		NOTE: if you migrate this to a JS file, remember to remove the backslash escape characters before the double-quote characters.
printf("				var regex_desc = new RegExp(',\"desc\":', 'g');");	//regular expression to find all "desc" labels		NOTE: if you migrate this to a JS file, remember to remove the backslash escape characters before the double-quote characters.
printf("				str = str.replace(regex_date, '{');");
printf("				str = str.replace(regex_type, ',');");
printf("				str = str.replace(regex_desc, ',');");
printf("				return str;");
printf("			}");
printf("			function shortenTypes_fromJsonStringified(str) {");
printf("				var regex_verbose = new RegExp('\"VERBOSE\"', 'g');");	//regular expression to find all "VERBOSE" strings	NOTE: if you migrate this to a JS file, remember to remove the backslash escape characters before the double-quote characters.
printf("				var regex_log = new RegExp('\"LOG\"', 'g');");		//regular expression to find all "LOG" strings		NOTE: if you migrate this to a JS file, remember to remove the backslash escape characters before the double-quote characters.
printf("				var regex_info = new RegExp('\"INFO\"', 'g');");	//regular expression to find all "INFO" strings		NOTE: if you migrate this to a JS file, remember to remove the backslash escape characters before the double-quote characters.
printf("				var regex_warn = new RegExp('\"WARN\"', 'g');");	//regular expression to find all "WARN" strings		NOTE: if you migrate this to a JS file, remember to remove the backslash escape characters before the double-quote characters.
printf("				var regex_error = new RegExp('\"ERROR\"', 'g');");	//regular expression to find all "ERROR" strings	NOTE: if you migrate this to a JS file, remember to remove the backslash escape characters before the double-quote characters.
printf("				str = str.replace(regex_verbose, '\"V\"');");
printf("				str = str.replace(regex_log, '\"L\"');");
printf("				str = str.replace(regex_info, '\"I\"');");
printf("				str = str.replace(regex_warn, '\"W\"');");
printf("				str = str.replace(regex_error, '\"E\"');");
printf("				return str;");
printf("			}");
printf("			function stripObjMemberQuotes_fromJsonStringified(str) {");
printf("				var regex_quoteFirst = new RegExp('{\"', 'g');");	//regular expression to find each entry's first quotation mark		NOTE: if you migrate this to a JS file, remember to remove the backslash escape characters before the double-quote characters.
printf("				var regex_quoteBetween = new RegExp('\",\"', 'g');");	//regular expression to find the quotation marks between labels		NOTE: if you migrate this to a JS file, remember to remove the backslash escape characters before the double-quote characters.
printf("				var regex_quoteLast = new RegExp('\"}', 'g');");	//regular expression to find each entry's last quotation mark		NOTE: if you migrate this to a JS file, remember to remove the backslash escape characters before the double-quote characters.
printf("				str = str.replace(regex_quoteFirst, '{');");
printf("				str = str.replace(regex_quoteBetween, '|');");
printf("				str = str.replace(regex_quoteLast, '}');");
printf("				return str;");
printf("			}");
printf("			function improveCallStackReadability(str) {");
printf("				var regex_callPath = new RegExp('(@http).*?(~silentm\\\\/)', 'gi');");	//regular expression to find all substrings beginning with "http" and ending with "~silentm/" (w/any chars in between)	NOTE: if you migrate this to a JS file, remember to remove two backslash escape chars after silentm
printf("				var regex_newLine = new RegExp('\\\\\\\\n', 'g');");			//regular expression to find all new-line control chars		NOTE: if you migrate this to a JS file, remember to remove some backslash escape chars before the n
printf("				var regex_extraAt = new RegExp('(    at )', 'g');");			//regular expression to find all substrings matching "    at "
printf("				var regex_extraPath = new RegExp('( http).*?( <-)', 'gi');");		//regular expression to find all substrings beginning with " http" and ending with " <-" (w/any chars in between)
printf("				var regex_extraPath2 = new RegExp('(http).*?(~silentm\\\\/)', 'g');");	//regular expression to find all substrings beginning with " http" and ending with "~silentm/" (w/any chars in between)
printf("				str = str.replace(regex_callPath, '@');");				//shorten the call path (strips the protocol and server name/address, leaving just the webserver relative path to script)
printf("				str = str.replace(regex_newLine, ' <- ');");				//help better show what called what, with arrows
printf("				str = str.replace(regex_extraAt, '');");				//remove the extra unneeded "at"
printf("				str = str.replace(regex_extraPath, '');");				//remove the extra unneeded extra path
printf("				str = str.replace(regex_extraPath2, '');");				//shorten any other call path (strips the protocol and server name/address, leaving just the webserver relative path to script)
printf("				return str;");
printf("			}");
printf("			var sessionLog_stringified = JSON.stringify(FavScreen.sessionLog);");
printf("			var sessionLog_stringifiedAndProcessed = stripObjMemberLabels_fromJsonStringified(sessionLog_stringified);");
printf("			sessionLog_stringifiedAndProcessed = shortenTypes_fromJsonStringified(sessionLog_stringifiedAndProcessed);");
printf("			sessionLog_stringifiedAndProcessed = stripObjMemberQuotes_fromJsonStringified(sessionLog_stringifiedAndProcessed);");
//printf("			sessionLog_stringifiedAndProcessed = improveCallStackReadability(sessionLog_stringifiedAndProcessed);");		//clean-up call stack log entries
printf("			YUI().use(\"io\", function(Y){");
printf("				var objResponse;");
printf("				var handleStart = function(ioId, o){");								//what should happen when the io txn starts
printf("					FavScreen.log('verbose', \"ClassFavScreen.logSaveToServer(): YUI-IO: Starting txn to save log to server... YUI-IO txn ID# will be: \"+ioId+\".\", true);");
printf("				};");
printf("				var handleSuccess = function(ioId, o){");							//response HTTP status resolves to 2xx
printf("					FavScreen.log('log', \"ClassFavScreen.logSaveToServer(): YUI-IO:   Txn #\"+ioId+\" succeeded.\", true);");
printf("				};");
printf("				var handleFailure = function(ioId, o){");							//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("					FavScreen.log('error', \"ClassFavScreen.logSaveToServer(): YUI-IO:   Txn #\"+ioId+\" failed or timed-out. ResponseText returned by server... (next log entry)\", true);");
printf("					FavScreen.log('verbose', o.responseText, false);");
printf("					ModalNotification_ServiceUnavailable.showFor(4000);");
printf("				};");
printf("				var cfg ={");											//setup a standard YUI configuration object for our transaction
printf("					on:{");
printf("						start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("						success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("						failure:handleFailure");							//subscribe the above custom failure handler to IO's global failure event
printf("						},");
printf("					method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("					data:{");										//whatever fields/data that CGI gets to parse...
printf("						'favoritesLogSaveToServer':'true',");						//smcgi command flag
printf("						'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("						'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP(),");
//printf("						'sessionLogJSON':JSON.stringify(FavScreen.sessionLog)");			//raw client log data straight from the client's logging object
printf("						'sessionLogJSON':sessionLog_stringifiedAndProcessed");				//minified client log data (non-destructive)
printf("						},");
printf("					headers:{");
printf("						'Content-Type':'application/x-www-form-urlencoded'");
printf("						},");
printf("					sync:false,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("					timeout:10000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("				};");//end cfg
printf("				var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("				objResponse = Y.io(sUrl, cfg);");
printf("				});");//end YUI().use
printf("			};\n");//end .logSaveToServer method definition

printf("		this.initialized = false;");										//initialize an 'initialized' flag (to get set to true once instantiated)
printf("		this.init = function(){");										//define what should happen when this class gets initialized - NOTE: best to keep this at the very end of the class definition!
printf("			this.initialized = true;");
printf("			this.log('log', \"ClassFavScreen: An object of this class is now initialized as '\"+strInstanceName+\"'.\", true);");
printf("			this.log('log', \"ClassFavScreen: User-agent string = '\"+this.get('attrYuiUA')+\"'.\", false);");
printf("			this.log('log', \"ClassFavScreen: %s web-app version \"+this.get('attrVersion')+\".\", true);", FAVS_NAME_FULL);
printf("			if(window.withFullSystem){CreateAlternateSession_oldWayFromFavs(0,0,0,0,0,0);}");
if(httpUserAgentString && 
	(  strstr(httpUserAgentString, "iPad")	//example: Mozilla/5.0 (iPad; CPU OS 7_0_6 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11B651 Safari/9537.53
	|| strstr(httpUserAgentString, "iPhone")
	|| strstr(httpUserAgentString, "iPod")	//likely not needed, since iPod Touch seems to be caught by iPhone above, but can't hurt
	|| strstr(httpUserAgentString, "Android") ))	//example: Mozilla/5.0 (Linux; Android 4.2.2; en-us; SAMSUNG SCH-I545 Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Version/1.0 Chrome/18.0.1025.308 Mobile Safari/535.19
	{
	printf("		var w = window.innerWidth;");
	printf("		var h = window.innerHeight;");
	printf("		this.log('log',\"ClassFavScreen: Setting initial screen geometry attributes (width=\"+w+\", height=\"+h+\")...\",false);");
	printf("		if(w > h){");
	printf("			this.set('attrDeviceOrientation', ORIENTATION_LANDSCAPE);");
	printf("		}");
	printf("		else if((w < h) || (w == h)){");
	printf("			this.set('attrDeviceOrientation', ORIENTATION_PORTRAIT);");
//	printf("			document.getElementById('logotext').style.display = \"none\";");			//remove the logotext from display
	printf("			document.getElementById('pagetitle').style.left = \"70px\";");
	printf("		}");
	printf("		else{");
	printf("			this.log('log',\"ClassFavScreen: Setting initial screen geometry attributes FAILED (width=\"+w+\", height=\"+h+\").\",false);");
	printf("		}");
	printf("		setTimeout(function(){window.scrollTo(0,1);},500);");						//DEV-NOTE: detect older and use this only on older, as newer standards work instead
	printf("		if(typeof document.documentElement.requestFullscreen!==\"undefined\"){");
	printf("			document.documentElement.requestFullscreen();");					//DEV-NOTE: not sure whether this is really needed... doesn't seem to hurt anything having it here though
	printf("		}");
	}
printf("			setInterval(function(){FavScreen.set('attrDtsecJS_current_15s',new Date/1E3|0);},15*1000);");	//set a 15-second update interval for the 15-second current dtsec update attribute
printf("			setTimeout( function(){");									//set the various heights (giving enough time for them to render and for clientsize to run)
printf("				FavScreen.set('attrHeaderWrapperHeight', document.getElementById('headerwrapper').clientHeight);");
printf("				FavScreen.set('attrFooterWrapperHeight', document.getElementById('footerwrapper').clientHeight);");
printf("				FavScreen.set('attrBodyWrapperHeight', FavScreen.get('attrWindowHeight') - ( FavScreen.get('attrHeaderWrapperHeight') + FavScreen.get('attrFooterWrapperHeight') ));");
printf("				}, 1);");
//------------------------------Load libraries and their messages---------------------------------------------------------------------------------------
printf("			this.log('log',\"ClassFavScreen: Init routine now loading libraries and their messages...\",true);");
printf("			loadLibsAndMsgs();");
printf("			if(typeof FavScreen.objLibsMsgs === 'object') {");
printf("				var numOfLibs = FavScreen.objLibsMsgs.length;");
printf("				FavScreen.log('log',\"FavScreen.objLibsMsgs: Initializing primary set of \"+numOfLibs+\" libraries (and then their messages, asynchronously, after their recordsets initialize and data added).\",true);");
printf("			}else{");
printf("				FavScreen.log('error',\"FavScreen.objLibsMsgs: Initial call to loadLibsAndMsgs() resulted in FavScreen.objLibsMsgs having a type of '\"+typeof FavScreen.objLibsMsgs+\"' (\"+JSON.stringify(FavScreen.objLibsMsgs)+\").\",true);");
					//dev-note: show msgs unavailable in the libraries section?
printf("			}");

printf("			};\n");//end method definition for init()
//printf("		this.init();\n");												//call the method that says "hey, I'm initialized!" (this only runs once the class has been initialized, so this is the way to do it)

printf("	}\n");//end class definition function

printf("	Y.augment(ClassFavScreen, Y.Attribute);\n");							// Augment our custom class definitin with all methods, etc. from YUI-Attribute

printf("	FavScreen = new ClassFavScreen('FavScreen');\n");							// Create a new instance of our custom class, assigning it back to our globally scoped variable-object, "FavScreen"
if(isLoadedInMobileApp())
	{
	printf("setTimeout(function(){FavScreen.init();}, 1000);\n");							//call the method that says "hey, I'm initialized!" (this only runs once the class has been initialized, so this is the way to do it)
	}
else
	{
	printf("setTimeout(function(){FavScreen.init();}, 200);\n");							//call the method that says "hey, I'm initialized!" (this only runs once the class has been initialized, so this is the way to do it)
	}

//printf("	load_yuiPanel_loadingIndicator();");								// Load the loading-spinner stuff (this has to be done after the class is created)

printf("	FavScreen.after('attrInteractionModeChange', function(e){");					// Subscribe after-change event listener to the interactionMode attribute, and define what happens after its value changes
printf("		this.log('log', \"FavScreen: attrInteractionMode's after-change event fired... before was '\"+e.prevVal+\"', but now it's '\"+e.newVal+\"'.\", true);");
printf("		this.set('attrInteractionMode_prev', e.prevVal);");
printf("		loadModeSpecificAssets();");									//make sure the appropriate mode-appropriate assets (e.g. panels, data-sets, etc.) are loaded into memory. This helps make things more efficient loading them "on-demand" like this rather than on initial page load.
printf("		if(this.node_bodywrapper!==null || this.node_bodywrapper!==undefined) {");			//if the saved bodywrapper-node exists (then we might be showing a legacy document's iframe and should not run certain routines that depend on it being rendered in the DOM)
printf("			this.log('log',\"FavScreen: attrInteractionModeChange: Saved node_bodywrapper member not detected in FavScreen (so assuming it's rendered in the DOM), running various appropriate routines...\",false);");
printf("			updateMessagecells();");									//update messagecells and contents for the interaction mode chosen (e.g. showing/hiding drag handles, etc.)
//printf("			attachActionListenersToMessageCells(\"ul#messagelist-critical\");");
//printf("			attachActionListenersToMessageCells(\"ul#messagelist-dropbox\");");
printf("			attachActionListenersToMessageCells(\"ul#\" + window.objConfig_MajorSection_critical.str_sectionDomID);");
printf("			attachActionListenersToMessageCells(\"ul#\" + window.objConfig_MajorSection_personalLibs.str_sectionDomID);");
printf("			attachActionListenersToMessageCells(\"ul#\" + window.objConfig_MajorSection_dropbox.str_sectionDomID);");
printf("			attachActionListenersToMessageCells_allSubsectionsInSection(\"subsectionlist-libraries\");");
printf("		}");
printf("		else {");//DEV-NOTE: not yet needed, but might later
printf("			this.log('log',\"FavScreen: attrInteractionModeChange: Saved node_bodywrapper member detected in FavScreen, not running certain routines that depend on it actually being rendered in the DOM.'\",false);");
printf("		}");
//printf("		updateMenu();");										//update menu options to be consistent with what should be showing while in edit mode
printf("		updateScreenStyle(e);");									//change the visual feel of the page to reflect it's in edit mode
printf("		handleSaveChanges();");										//check whether there may have been any changes that need saved (e.g. if coming from edit mode or something)
printf("		handleAutoEndEditMode_setOrReset();");								//handle the edit-mode auto-change stuff
//printf("		handleAutoEndResponsePanel_setOrReset(0);");							//immediately end any reply panel session
printf("		handleAutoEndResponseMode_setOrReset();");							//handle the reply-mode auto-change stuff
printf("		if(e.prevVal == MODE_REPLYING) {");								//if changing from reply-mode...
printf("			this.set('attrCurrentResponseRule', ENCODED_RESPONSE_RULE_0);");				//reinitialize
printf("			this.objMsgData_replyTo = undefined;");								//reinitialize (note: using undefined instead of {}, so potential tests don't fail)
printf("			this.objMsgData_replyWith = undefined;");							//reinitialize (note: using undefined instead of {}, so potential tests don't fail)
//printf("			refreshRecord");
//printf("			setTimeout(function(){jumpScrollTo(\"bodywrapperInboxAnchor\");}, 1000);");
printf("			setTimeout(function(){");									//handle doing our potential jump back to inbox (depending on what was happening to change the mode from reply)
printf("				scrollTo_animated(document.body, FavScreen.get('attrPreviousScrollPositionPixelY'), 150);");	//return to the previous scroll position (from where they hit respond on the inbox msg)
printf("				}, 4000);");
printf("		}");
printf("		});\n");//end after-change

/* currently unused...
printf("	FavScreen.after('attrLayoutModeChange', function(e){");						// Subscribe after-change event listener to the layoutMode attribute, and define what happens after its value changes
printf("		this.log('log', \"FavScreen: attrLayoutMode's after-change event fired... its new value = \"+this.get('attrLayoutMode'), true);");
printf("		});\n");//end after-change
*/

printf("	FavScreen.after('attrDeviceOrientationChange', function(e){");					// Subscribe after-change event listener to the deviceOrientation attribute, and define what happens after its value changes
printf("		if(!YUI.Env.UA.touchEnabled){return false;}");							//if presumably on PC (non-mobile device), don't do anything
printf("		this.log('log', \"FavScreen: attrDeviceOrientation's after-change event fired... its new value = \"+this.get('attrDeviceOrientation'), false);");
//printf("		var node_divLogotext = document.getElementById(\"logotext\");");				//get a handle for the logo text's node
//printf("		var node_divPagetitle = document.getElementById('pagetitle');");				//get a handle for the page title's node
//printf("		if(this.get('attrDeviceOrientation')==ORIENTATION_PORTRAIT){");					//if device/screen orientation is portrait (the screen, especially iPhone, is too skinny to show too much across the top), then...
//printf("			node_divPagetitle.style.left = \"70px\";");						//move the text over (since it was absolutely positioned)
//printf("			node_divLogotext.style.display = \"none\";");						//don't display logo text (actually, remove it from the document's rendering/flow)
//printf("		}else{");											//else, landscape mode should offer plenty of horizontal real estate, so...
//printf("			node_divPagetitle.style.left = \"155px\";");						//move the text over (since it was absolutely positioned)
//printf("			node_divLogotext.style.display = \"inline\";");						//display logo text in a way suitable for this line (i.e. inline with anything else)
//printf("		}");
printf("		if(this.menu && this.menu.get('visible')){");							//if the menu exists and is currently showing...
printf("			this.menu.reposition(Y.one('#menuicon').ancestor());");					//reposition the menu to the menuicon anchor area
printf("		}");
//printf("		if(this.get('attrDeviceOrientation')==ORIENTATION_LANDSCAPE){");				//do anything special that may be needed for landscape mode
//printf("			document.body.style.webkitTextSizeAdjust = this.get('attrZoom');");				//override mobile Safari's scaling with either the default or what the user wants
//printf("			document.getElementById(\"bodywrapper\").style.webkitTextSizeAdjust = this.get('attrZoom');");	//override mobile Safari's scaling with either the default or what the user wants
//printf("		}else if(this.get('attrDeviceOrientation')==ORIENTATION_PORTRAIT){");				//do anything special that may be needed for portrait mode
//printf("			document.body.style.webkitTextSizeAdjust = this.get('attrZoom');");				//override mobile Safari's scaling with either the default or what the user wants
//printf("			document.getElementById(\"bodywrapper\").style.webkitTextSizeAdjust = this.get('attrZoom');");	//override mobile Safari's scaling with either the default or what the user wants
//printf("		}else{");											//else (some kind of unexpected error)
//printf("			this.log('warn',\"FavScreen: attrDeviceOrientation changed to a non-valid value ('\"+this.get('attrDeviceOrientation')+\"').\",false);");
//printf("		}");
printf("		document.getElementById(\"bodywrapper\").style.webkitTextSizeAdjust = this.get('attrZoom');");	//override mobile Safari's scaling with either the default or what the user wants
printf("		forceCssRepaint();");
printf("		});\n");//end after-change

printf("	FavScreen.after('attrWindowWidthChange', function(e){");					// Subscribe after-change event listener to the WindowWidth attribute, and define what happens after its value changes
printf("		this.log('log', \"FavScreen: attrWindowWidth's after-change event fired... its new value = \"+this.get('attrWindowWidth'), false);");
//printf("		var node_divLogotext = document.getElementById(\"logotext\");");				//get a handle for the logo text's node
//printf("		var node_divPagetitle = document.getElementById('pagetitle');");				//get a handle for the page title's node
//printf("		if(e.newVal < 350){");
//printf("			node_divPagetitle.style.left = \"70px\";");						//move the text over (since it was absolutely positioned)
//printf("			node_divLogotext.style.display = \"none\";");
//printf("			this.log('log', \"FavScreen:  hiding node_divLogotext due to window being too narrow.\", false);");
//printf("		}");
//printf("		else{");
//printf("			node_divPagetitle.style.left = \"155px\";");						//move the text over (since it was absolutely positioned)
//printf("			node_divLogotext.style.display = \"inline\";");
//printf("		}");
//printf("		forceCssRepaint();");
printf("		});\n");//end after-change
printf("	FavScreen.after('attrWindowHeightChange', function(e){");					// Subscribe after-change event listener to the WindowHeight attribute, and define what happens after its value changes
printf("		var newValue = e.newVal;");
printf("		this.log('log', \"FavScreen: attrWindowHeight's after-change event fired... its new value = \"+this.get('attrWindowHeight'), false);");
printf("		this.set('attrBodyWrapperHeight', newValue - ( this.get('attrHeaderWrapperHeight') + this.get('attrFooterWrapperHeight') ));");
printf("		});\n");//end after-change

/* currently unused...
printf("	FavScreen.after('attrIsCurrentlyVisible_sortedChange', function(e){");				// Subscribe after-change event listener to the sorted-currently-visible attribute, and define what happens after its value changes
printf("		this.log('log', \"FavScreen: attrIsCurrentlyVisible_sorted's after-change event fired... its new value = \"+this.get('attrIsCurrentlyVisible_sorted'), false);");
printf("		});\n");//end after-change

printf("	FavScreen.after('attrIsCurrentlyVisible_unsortedChange', function(e){");			// Subscribe after-change event listener to the unsorted-currently-visible attribute, and define what happens after its value changes
printf("		this.log('log', \"FavScreen: attrIsCurrentlyVisible_unsorted's after-change event fired... its new value = \"+this.get('attrIsCurrentlyVisible_unsorted'), false);");
printf("		});\n");//end after-change

printf("	FavScreen.after('attrIsCurrentlyVisible_deletedChange', function(e){");				// Subscribe after-change event listener to the deleted-currently-visible attribute, and define what happens after its value changes
printf("		this.log('log', \"FavScreen: attrIsCurrentlyVisible_deleted's after-change event fired... its new value = \"+this.get('attrIsCurrentlyVisible_deleted'), false);");
printf("		});\n");//end after-change
*/

printf("	FavScreen.after('attrExecuteJavaScriptOnChangeChange', function(e){");				// Subscribe after-change event listener to the special event triggering attribute, and define what happens after its value changes
printf("		this.log('log', \"FavScreen: attrExecuteJavaScriptOnChange's after-change event fired... its new value (JS to execute) = '\"+this.get('attrExecuteJavaScriptOnChange')+\"'\", true);");
printf("		if(typeof this.get('attrExecuteJavaScriptOnChange') !== 'undefined'){");			//if the attribute's value seems valid...
printf("			eval(this.get('attrExecuteJavaScriptOnChange'));");					//perform eval on it (to hopefully execute it)
printf("		}");
printf("		});\n");//end after-change

/* currently unused...
printf("	FavScreen.after('attrDeviceTypeChange', function(e){");						// Subscribe after-change event listener to the device type attribute, and define what happens after its value changes
printf("		this.log('log', \"FavScreen: attrDeviceType's after-change event fired... its new value = \"+this.get('attrDeviceType'), false);");
printf("		});\n");//end after-change
*/

printf("	FavScreen.after('attrZoomChange', function(e){");						// Subscribe after-change event listener to the zoom attribute, and define what happens after its value changes
printf("		var z = e.newVal;");
printf("		if(isNaN(parseInt(z))){");									//if value is something strange, use default 100% value (this bug happens on first load where no zoom is specified in the hardware record)
printf("			z = \"100%%\";");
printf("			this.log('warn',\"FavScreen: attrZoomChange: attrZoom has an invalid value (\"+z+\"). Resetting to \"+z+\".\",false);");
printf("		}");
printf("		this.log('log', \"FavScreen: attrZoom's after-change event fired... its new value = \"+z+\". Calling function to do zoom...\", false);");
printf("		zoomControls_doZoom(z);");									//actually do the visual zoom operation
printf("		try{");												//try setting a cookie to save the user's preferred zoom for next time they load favorites (trying for mobile device, too ~ which is why we do this regardless of conditions)
printf("			var ey = 10;");											//specify how many years cookie should live for
printf("			var d1 = new Date;");
printf("			var d2 = new Date;");
printf("			var expiry = d2.setFullYear(d1.getFullYear()+ey);");						//calculate expiration date, using current date plus however many years we specified above (results in dtsec type number, e.g. 1401395215684)
printf("			expiry = new Date(expiry).toString();");							//convert that number into a standard cookie-acceptable string (e.g. "Thu May 29 2014 16:27:56 GMT-0400 (EDT)")
printf("			document.cookie=\"favzoomlevel=\"+z+\"; expires=\"+expiry;");					//set the cookie (will update if one already exists)
printf("			this.log('log', \"FavScreen: Cookie set for zoom level \"+z+\" for \"+ey+\" years (expires \"+expiry+\").\", false);");
printf("		}");//end try
printf("		catch(err){");											//if setting the cookie failed for some reason, log the error
printf("			this.log('error', \"FavScreen: A problem occurred while trying to save zoom to a cookie. Following, is the error...\", false);");
printf("			this.log('log', err.message+\" -- \"+err.description, false);");
printf("		}");//end catch
if(isLoadedInMobileApp())												//if we're in the mobile app (thus, hardware device record exists), then handle saving zoom data to that record
	{
	printf("	var objResponse;");
	printf("	var handleStart = function(ioId, o){");								//what should happen when the io txn starts
	printf("		FavScreen.log('log',\"FavScreen: attrZoomChange: YUI-IO: Starting txn to update mobile app hardware record... YUI-IO txn ID# will be: \"+ioId+\".\",false);");
	printf("		};");
	printf("	var handleSuccess = function(ioId, o){");							//response HTTP status resolves to 2xx
	printf("		var rt = o.responseText;");
	printf("		FavScreen.log('log',\"FavScreen: attrZoomChange: YUI-IO:   Txn #\"+ioId+\" succeeded. (Server response next log entry).\",false);");
	printf("		FavScreen.log('log',rt, false);");
	printf("		if(rt.indexOf(\"%s\")>-1){", FAVS_RESPONSE_CODE_FINISHED_STUFFDONE);
	printf("			FavScreen.log('log',\"FavScreen: attrZoomChange:           Server responded with success!\",false);");
	printf("		}");
	printf("		else if(rt.indexOf(\"%s\")>-1){", FAVS_RESPONSE_CODE_ERROR_DB_WRITE);
	printf("			FavScreen.log('warn',\"FavScreen: attrZoomChange:           Server responded with database-write-error.\",false);");
	printf("		}");
	printf("		else if(rt.indexOf(\"%s\")>-1){", FAVS_RESPONSE_CODE_ERROR);
	printf("			FavScreen.log('warn',\"FavScreen: attrZoomChange:           Server responded with error. Perhaps mobile-app record not found or invalid zoom data was posted.\",false);");
	printf("		}");
	printf("		else if(rt.indexOf(\"%s\")>-1){", FAVS_RESPONSE_CODE_FINISHED_STUFFNOTDONE);
	printf("			FavScreen.log('warn',\"FavScreen: attrZoomChange:           Server responded with finished, but stuff not done for some reason.\",false);");
	printf("		}");
	printf("		else{");
	printf("			FavScreen.log('warn',\"FavScreen: attrZoomChange:           Server responded with something unexpected. Data may not have been saved.\",false);");
	printf("		}");
	printf("		};");
	printf("	var handleFailure = function(ioId, o){");							//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
	printf("		FavScreen.log('log',\"FavScreen: attrZoomChange: YUI-IO:   Txn #\"+ioId+\" failed or timed-out.\",false);");
	printf("		FavScreen.log('verbose',\"FavScreen: attrZoomChange: YUI-IO:   Txn #\"+ioId+\"'s responseText returned by server = '\"+o.responseText+\"'\",false);");
	printf("		};");
	printf("	var cfg ={");											//setup a standard YUI configuration object for our transaction
	printf("		on:{");
	printf("			start:handleStart,");								//subscribe the above custom start handler to IO's global start event
	printf("			success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
	printf("			failure:handleFailure");							//subscribe the above custom failure handler to IO's global failure event
	printf("			},");
	printf("		method:\"POST\", ");									//method will default to GET unless we specify POST here
	printf("		data:{");										//whatever fields/data that CGI gets to parse...
	printf("			'favoritesUpdateDeviceRecordWithZoom':'true',");				//smcgi command flag
	printf("			'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
	printf("			'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP(),");
	printf("			'uuid':parseUuidFromUA(),");							//uuid string
	printf("			'zoomLevel':parseInt(z)");							//zoom level as a pure integer value
	printf("			},");
	printf("		headers:{");
	printf("			'Content-Type':'application/x-www-form-urlencoded'");
	printf("			},");
	printf("		sync:false,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete (DEV-NOTE: this value allows Spinner and is fast)
	printf("		timeout:10000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
	printf("		};");//end cfg
	printf("	var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
	printf("	objResponse = Y.io(sUrl, cfg);");
	}
printf("		});\n");//end after-change

printf("	FavScreen.after('attrGeoLocation_lastChange', function(e){");					// Subscribe after-change event listener to the attrGeoLocation_last attribute, and define what happens after its value changes
printf("		this.log('verbose',\"FavScreen: Attribute changed: attrGeoLocation_last='\"+JSON.stringify(e.newVal)+\"'\",false);");
printf("		});\n");//end after-change
printf("	FavScreen.after('attrGeoLocation_lastAccuracyChange', function(e){");				// Subscribe after-change event listener to the attrGeoLocation_lastAccuracy attribute, and define what happens after its value changes
printf("		var val = parseInt(e.newVal);");
printf("		this.log('log',\"FavScreen: Attribute changed: attrGeoLocation_lastAccuracy=\"+val,false);");
printf("		if(val>%d){", FAVS_GEOLOCATION_ACCURACY_CRITICAL);
printf("			this.log('warn',\"FavScreen: Attribute 'attrGeoLocation_lastAccuracy' accuracy critical! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_CRITICAL);
printf("		}else if(val>%d){", FAVS_GEOLOCATION_ACCURACY_WARNING);
printf("			this.log('warn',\"FavScreen: Attribute 'attrGeoLocation_lastAccuracy' accuracy warning! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_WARNING);
printf("		}else if(val>%d){", FAVS_GEOLOCATION_ACCURACY_NOTICE);
printf("			this.log('info',\"FavScreen: Attribute 'attrGeoLocation_lastAccuracy' accuracy notice! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_NOTICE);
printf("		}");
printf("		});\n");//end after-change

printf("	FavScreen.after('attrGeoLocation_native_lastChange', function(e){");				// Subscribe after-change event listener to the attrGeoLocation_native_last attribute, and define what happens after its value changes
printf("		this.log('verbose',\"FavScreen: Attribute changed: attrGeoLocation_native_last='\"+e.newVal+\"'\",false);");
printf("		this.set('attrGeoLocation_native_lastUpdated', this.get('attrGeoLocation_native_last').substr(e.newVal.indexOf(\"@\")+2));");	//extract timestamp and save to its own attribute
printf("		});\n");//end after-change
printf("	FavScreen.after('attrGeoLocation_native_lastAccuracyCoordChange', function(e){");		// Subscribe after-change event listener to the attrGeoLocation_native_last attribute, and define what happens after its value changes
printf("		var val = parseInt(e.newVal);");
printf("		this.log('log',\"FavScreen: Attribute changed: attrGeoLocation_native_lastAccuracyCoord=\"+val,false);");
printf("		if(val>%d){", FAVS_GEOLOCATION_ACCURACY_CRITICAL);
printf("			this.log('warn',\"FavScreen: Attribute 'attrGeoLocation_native_lastAccuracyCoord' accuracy critical! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_CRITICAL);
printf("		}else if(val>%d){", FAVS_GEOLOCATION_ACCURACY_WARNING);
printf("			this.log('warn',\"FavScreen: Attribute 'attrGeoLocation_native_lastAccuracyCoord' accuracy warning! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_WARNING);
printf("		}else if(val>%d){", FAVS_GEOLOCATION_ACCURACY_NOTICE);
printf("			this.log('info',\"FavScreen: Attribute 'attrGeoLocation_native_lastAccuracyCoord' accuracy notice! (>\"+%d+\" meters)\",false);", FAVS_GEOLOCATION_ACCURACY_NOTICE);
printf("		}");
printf("		});\n");//end after-change

/* currently unused...
printf("	FavScreen.after('attrLastFocused_windowChange', function(e){");				// Subscribe after-change event listener to the attrLastFocused_window attribute, and define what happens after its value changes
printf("		this.log('log',\"FavScreen: Attribute changed: attrLastFocused_window=\"+e.newVal,false);");
printf("		});\n");//end after-change
*/

printf("	FavScreen.after('attrLastFocused_nativeChange', function(e){");					// Subscribe after-change event listener to the attrGeoLocation_native_last attribute, and define what happens after its value changes (NOTE: only works in iOS v1.7 and later)
printf("		this.log('log',\"FavScreen: Attribute changed: attrLastFocused_native=\"+e.newVal,false);");
printf("		handleGeolocationAcquisition();"); 								//update the geolocation data (so hopefully it will be ready when/if they launch a msg
printf("		var dtsecDiffSinceLastInForeground = (new Date/1E3|0) - this.get('attrDtsecJS_current_15s');");	//calculate the number of seconds now elapsed since app was last in the foreground
//printf("		var cfg_secsToAllowNonLaunchMode = 30;");
printf("		var cfg_secsToAllowNonLaunchMode = 0;");
printf("		if(dtsecDiffSinceLastInForeground >= cfg_secsToAllowNonLaunchMode){");				//if the above-configured amount of time has passed since app was last in the foreground, then we should automatically return to launch mode...
printf("			this.log('log',\"FavScreen: App has entered foreground after \"+dtsecDiffSinceLastInForeground+\" seconds have elapased since it was last in the foreground... now ensuring that launch-mode is ready.\",false);");
printf("			if(this.get('attrInteractionMode')==MODE_EDITABLE){");						//if we're in edit-mode...
printf("				handleAutoEndEditPanel_setOrReset(0);");							//immediately end the edit panel session (in case it existed)
printf("				this.set(\"attrInteractionMode\",MODE_LAUNCHABLE);");						//change the page's mode
printf("			}");
printf("			else if(this.get('attrInteractionMode')==MODE_REPLYING){");					//if we're in reply-mode...
printf("				handleAutoEndResponsePanel_setOrReset(0);");							//immediately end the reply panel session (in case it existed)
printf("				this.set(\"attrInteractionMode\",MODE_LAUNCHABLE);");						//change the page's mode
printf("			}");
printf("		}");
printf("		try {");
printf("			if(FavScreen.node_bodywrapper!==null && FavScreen.node_bodywrapper!==undefined) {");		//if no bodywrapper node is rendered or exists (then we might be showing a legacy document's iframe and should restore the bodywrapper)
printf("				this.log('log',\"FavScreen: App has entered foreground while an iframe exists. Now trying to restore saved bodywrapper node...\",false);");
//printf("				Popup.hide();");
printf("				restoreSavedNode_fromLegacyIframe();");								//restore the saved bodywrapper node, replacing the iframe with it
printf("				if(ModalNotification_ConnectionLost.isVisible){ModalNotification_ConnectionLost.hide();}");	//if legacy smcgi showed this, hide it now, so the user can continue using the page
printf("			}");
printf("			else {");											//else the main bodywrapper node should be rendered/visible, so we can safely do refresh operations, etc...
printf("				var delayToExecute = 200;");									//specify execution delay in milliseconds
printf("				this.log('log',\"FavScreen: App has entered foreground and will now refresh recordsets after \"+delayToExecute+\"ms...\",false);");
printf("				setTimeout( function() {");									//do any final tasks (e.g. refreshing data, updating screen, etc.) -- do on a timeout to help ensure it won't hold this routine up and things done here finish (and are ready) before refresh ops
printf("					refreshRecordset(\"%s\",true,false,false,true);", CurrentUserPin);				//refresh to make sure we're showing current data on-screen (should also trigger any needed toggle udpates)
printf("					Spinner.hide();");										//refresh starts a spinner on a delay, so cancel it (we don't want the spinner to show on native re-focus)
printf("					refreshRecordset_inboxMsgs(\"%s\",false,false);", CurrentUserPin);				//make sure we have the latest inbox data
//printf("					attachActionListenersToMessageCells_allSubsectionsInSection(\"subsectionlist-libraries\");");	//just make sure if still in reply mode to attach the reply listeners to the STD REPLY section.
printf("					}, delayToExecute);");
printf("			}");
printf("		} catch(err) {");
				//NOTE: this can sometimes happen if a bodywrapper node hasn't been logically handled yet -- it's OK
printf("			this.log('info',\"FavScreen: attrLastFocused_native-change: Non-critical error was caught: '\"+err.message+\"'.\",false);");
printf("		}");
printf("		});\n");//end after-change

/* currently unused...
printf("	FavScreen.after('objPopupOpenerChange', function(e){");						// Subscribe after-change event listener to the objPopupOpener attribute, and define what happens after its value changes
printf("		var objWin = this.get('objPopupOpener');");							//get local window object
printf("		this.log('log', \"FavScreen: objPopupOpener change detected.\", true);");
printf("		});\n");//end after-change

printf("	FavScreen.after('objPopupWindowChange', function(e){");						// Subscribe after-change event listener to the objPopupWindow attribute, and define what happens after its value changes
printf("		var objWin = this.get('objPopupWindow');");							//get local window object
printf("		this.log('log', \"FavScreen: objPopupWindow change detected.\", true);");
printf("		});\n");//end after-change
*/

printf("	FavScreen.after('objPopupDocumentChange', function(e){");					// Subscribe after-change event listener to the objPopupDocument attribute, and define what happens after its value changes
printf("		var objDoc = this.get('objPopupDocument');");							//get local document object
printf("		this.log('log', \"FavScreen: objPopupDocument change detected.\", true);");
printf("		if(typeof Popup===\"object\"){");
//printf("			objDoc.forms[0].submit = function(){alert('submit');};");
printf("			Popup.showWith(objDoc);");								//call the routine to create a YUI Panel "popup"
printf("		}else{");
printf("			this.log('error', \"FavScreen: objPopupDocumentChange routine cannot reference a 'Popup' instance.\", true);");
printf("		}");
printf("		});\n");//end after-change

/* currently unused...
printf("	FavScreen.after('attrHeaderWrapperHeightChange', function(e){");
printf("		this.log('log',\"FavScreen: attrHeaderWrapperHeight change detected (\"+e.newVal+\").\",true);");
printf("		});\n");//end after-change
printf("	FavScreen.after('attrFooterWrapperHeightChange', function(e){");
printf("		this.log('log',\"FavScreen: attrFooterWrapperHeight change detected (\"+e.newVal+\").\",true);");
printf("		});\n");//end after-change
printf("	FavScreen.after('attrBodyWrapperHeightChange', function(e){");
printf("		this.log('log',\"FavScreen: attrBodyWrapperHeight change detected (\"+e.newVal+\").\",true);");
printf("		});\n");//end after-change
*/

printf("	FavScreen.after('attrLastRefreshTimestamp_inboxMsgsChange', function(e){");
printf("		this.log('log',\"FavScreen: attrLastRefreshTimestamp_inboxMsgs change detected (\"+e.newVal+\").\",true);");
printf("		if(this.get('attrInteractionMode') != MODE_REPLYING) {");
printf("			expandContainer('contentwrapper-inbox');");							//ensure the inbox section is expanded
printf("		}");
printf("		});\n");//end after-change

printf("	FavScreen.after('attrJumpNavModeChange', function(e){");
printf("		var newValue = e.newVal;");
printf("		var oldValue = e.prevVal;");
printf("		this.log('log',\"FavScreen: attrJumpNavMode change detected ('\"+oldValue+\"' -> '\"+newValue+\"').\",true);");
printf("		updateJumpNavIconsForMode(newValue);");//update jump-nav buttons to be consistent with the new value
printf("		});\n");//end after-change

//printf("	FavScreen.after('attrPreviousScrollPositionPixelYChange', function(e){");
//printf("		this.log('log',\"FavScreen: attrPreviousScrollPositionPixelY change detected (\"+e.newVal+\").\",true);");
//printf("		});\n");//end after-change

printf("	FavScreen.after('attrFinishedInitialLoading_timestampChange', function(e){");
printf("		this.log('log',\"FavScreen: attrFinishedInitialLoading_timestamp change detected (\"+e.prevVal+\" -> \"+e.newVal+\").\",true);");
printf("		});\n");//end after-change

printf("	if(typeof document.createElement('span').dataset===\"object\"){");				//test whether browser supports dataset (alternative is getAttribute but must manually prefix with "data-")
printf("		FavScreen.set('attrBrowserSupports_dataset',true);");
printf("		FavScreen.log('log', \"FavScreen: Browser supports 'dataset.'\", false);");
printf("	}");
printf("	if(typeof window.scrollY===\"number\"){");							//test whether browser supports scrollY (possible alternatives include document.documentElement.scrollTop)
printf("		FavScreen.set('attrBrowserSupports_scrollY',true);");
printf("		FavScreen.log('log', \"FavScreen: Browser supports 'scrollY.'\", false);");
printf("	}");
printf("	if(typeof window.document.body.style.zoom===\"string\"){");					//test whether browser supports CSS zoom (alternative might be CSS transform = "scale()")
printf("		FavScreen.set('attrBrowserSupports_css_zoom',true);");
printf("		FavScreen.log('log', \"FavScreen: Browser supports CSS 'zoom.'\", false);");
printf("	}");

printf("	if(FavScreen.get('attrMobileDeviceType') != null){");
printf("		FavScreen.set('attrIsMobileDevice', true);");
printf("	}else{");
printf("		FavScreen.set('attrIsMobileDevice', false);");
printf("	}");

printf("	var YUA = YUI.Env.UA;");									//determine what type of device we're on
printf("	if(YUA.android){");
printf("		FavScreen.set('attrDeviceType', DEVICETYPE_PHONE);");
printf("	}else if(YUA.iphone || YUA.ipod){");
printf("		FavScreen.set('attrDeviceType', DEVICETYPE_PHONE);");
printf("	}else if(YUA.ipad){");
printf("		FavScreen.set('attrDeviceType', DEVICETYPE_TABLET);");
printf("	}else{");
printf("		FavScreen.set('attrDeviceType', DEVICETYPE_PC);");
printf("	}\n");

printf("	FavScreen.applyCookieZoom = function(){");							//try to read and then apply the zoom value stored in the cookie
printf("		var cookie_favzoomlevel = document.cookie.replace(/(?:(?:^|.*;\\s*)favzoomlevel\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\");");//extract the zoom level percentage as a string
printf("		if(cookie_favzoomlevel.length>0){");
printf("			FavScreen.log('log', \"FavScreen: applyCookieZoom(): 'favzoomlevel' cookie exists, so automatically setting zoom to its value (\"+cookie_favzoomlevel+\").\", true);");
printf("			FavScreen.set('attrZoom',\"100%%\");");							//set initial to default, so the on change event listener will fire, next
printf("			FavScreen.set('attrZoom',cookie_favzoomlevel);");
printf("			return true;");
printf("		}else{return false;}");
printf("		};\n");//end applyCookieZoom method definition
printf("	FavScreen.applyDatabaseZoom = function(){");							//try to read and then apply the zoom value stored in the database hardware record for the mobile app
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");								//what should happen when the io txn starts
printf("			FavScreen.log('log',\"FavScreen: applyDatabaseZoom(): YUI-IO: Starting txn to get mobile app hardware record's zoom value... YUI-IO txn ID# will be: \"+ioId+\".\",false);");
printf("			};");
printf("		var handleSuccess = function(ioId, o){");							//response HTTP status resolves to 2xx
printf("			var rt = o.responseText;");
printf("			FavScreen.log('log',\"FavScreen: applyDatabaseZoom(): YUI-IO:   Txn #\"+ioId+\" succeeded. (Server response next log entry).\",false);");
printf("			FavScreen.log('log',rt, false);");
printf("			if(isNaN(parseInt(rt))){");								//if value is something strange, abort and attempt DB repair (by updating with a default value)
printf("				FavScreen.log('warn',\"FavScreen: applyDatabaseZoom(): Server returned an invalid value (\"+rt+\"). Aborting setting of client zoom/attribute.\",true);");
printf("				FavScreen.log('info',\"FavScreen: applyDatabaseZoom(): Since server returned an invalid value, we'll now try to repair it by setting an explicit default value.\",true);");
printf("				FavScreen.set('attrZoom',\"100%%\");");							//this may or may not trigger a database update (depending on whether attribute actually changes
printf("				return false;");
printf("			}else{");										//else value seems to have been valid, so update the zoom to match what we got from the database
printf("				FavScreen.set('attrZoom',\"100%%\");");							//set initial to default, so the on change event listener will have a chance to fire, next (if different of course)
printf("				FavScreen.set('attrZoom',rt+\"%%\");");							//set the value we got from the database
printf("			}");
printf("			return true;");
printf("			};");
printf("		var handleFailure = function(ioId, o){");							//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('log',\"FavScreen: applyDatabaseZoom(): YUI-IO:   Txn #\"+ioId+\" failed or timed-out.\",false);");
printf("			FavScreen.log('verbose',\"FavScreen: applyDatabaseZoom(): YUI-IO:   Txn #\"+ioId+\"'s responseText returned by server = '\"+o.responseText+\"'\",false);");
printf("			return false;");
printf("			};");
printf("		var cfg ={");											//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure");							//subscribe the above custom failure handler to IO's global failure event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
printf("				'favoritesGetZoomFromDeviceRecord':'true',");					//smcgi command flag
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP(),");
printf("				'uuid':parseUuidFromUA()");							//uuid string
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:false,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete (DEV-NOTE: this value allows Spinner and is fast)
printf("			timeout:10000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("			};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");
printf("		};\n");//end applyDatabaseZoom method definition

printf("	if(FavScreen.applyCookieZoom()){");								//always try to use the cookie first, for all platforms
printf("		FavScreen.log('log',\"FavScreen: Successfully executed applyCookieZoom() and set zoom from the cookie value. No need to get DB value.\",true);");
printf("	}else{");											//else no cookie available, so (depending on platform) handle taking further action (e.g. database, logging, etc)
if(isLoadedInMobileApp())
	{
	printf("	FavScreen.log('log',\"FavScreen: Execution of applyCookieZoom() returned false. Will now try to get DB value instead.\",true);");
	printf("	if(FavScreen.applyDatabaseZoom()){");
	printf("		FavScreen.log('log',\"FavScreen: Successfully executed applyDatabaseZoom() and set zoom from the database value.\",false);");
	printf("	}else{");
	printf("		FavScreen.log('info',\"FavScreen: Execution of applyDatabaseZoom() returned false. Custom zoom level may not exist or there was some error.\",false);");
	printf("	}");
	}
else
	{
	printf("	FavScreen.log('log',\"FavScreen: Execution of applyCookieZoom() returned false. Perhaps user hasn't set a custom zoom level.\",false);");
	}
printf("	}\n");

if(isLoadedInMobileApp())
	{
	printf("if(parseAppVersionFromUA(\"0\") >= \"%s\"){", FAVS_APP_IOS_VER_CANAUTOUPDATELOCATION);//if the app version supports automatically pushing updates to the JS layer, then we won't need a timer to keep location data updated
	printf("	handleGeolocationAcquisition();"); 				//do the initial geolocation call without setting a periodic update interval (since the native app can push updates to us as needed)
	printf("}else{");
	printf("	handleGeolocationAcquisition(60);");				//do the initial geolocation call and set periodic update interval (since the native app is too old to support automatic updates)
	printf("}");
	}
else
	{
	printf("handleGeolocationAcquisition(60);"); 			//do the initial geolocation call and set periodic update interval
	}

printf("});\n");//end YUI.use
//printf("FavScreen.set('attrWindowWidth', window.innerWidth);");
//printf("FavScreen.set('attrWindowHeight', window.innerHeight);");
printf("var Popup = new ClassInternalPopup(\"Popup\");");

printf("YUI().use(\"node\", \"event\", \"node-event-html5\", function(Y){");								// Globally subscribe event listeners to general window-scoped things

/* NOTE: as of iOS 8.1.2, orientationchange appears to be broken... specifically, the width/height values don't get updated fast enough? */
/*
printf("	Y.after('orientationchange', function(e){");								// The 'orientationchange' event should be a modern/reliable reserved keyword that we can use (may require testing-vigilance across mobile platforms)
printf("		var winWidth = parseInt(window.innerWidth);");								//local to each event, figure out width/height/orientation after the orientation changed...
printf("		var winHeight = parseInt(window.innerHeight);");
printf("		var winOrientation;");
printf("		if(winWidth>winHeight){");
printf("			winOrientation = ORIENTATION_LANDSCAPE;");
printf("		}else{");
printf("			winOrientation = ORIENTATION_PORTRAIT;");
printf("		}");
printf("		FavScreen.log('log',\"YUI Orientation Change: Detected as '\"+winOrientation+\"' (width=\"+winWidth+\", height=\"+winHeight+\").\",false);");
printf("		FavScreen.set('attrWindowWidth', winWidth);");								//set that local information back into our main class' attributes...
printf("		FavScreen.set('attrWindowHeight', winHeight);");
printf("		FavScreen.set('attrDeviceOrientation', winOrientation);");						//note: this attribute should have its own event-listener that fires whenever this attribute's value changes -- in other words, that event may fire after this line executes
printf("		window.scrollTo(0,FavScreen.get('attrCurrentScrollPositionPixelY'));");					//make sure we're scrolled to the previous position
printf("		if(FavScreen.get('attrInteractionMode')==MODE_EDITABLE){");						//if we're in edit-mode...
printf("			handleAutoEndEditMode_setOrReset();");									//handle the edit-mode auto-change stuff
printf("			handleAutoEndEditPanel_setOrReset();");									//handle the edit-panel auto-hide stuff
printf("		}");
printf("		var iframeHandle = document.getElementById(\"iframe_toResolveMsg\");");					//try to get a handle to the iframe used to resolve a message for launch (returns null if not available)
printf("		if(iframeHandle){");											//if an iframe to resolve a msg for launch exists, we need to recalculate widths for various elements inside its document
printf("			FavScreen.log('log',\"YUI Orientation Change: Calling existant iframe's doStyleUpdatesForRenderedInFavs() method...\",false);");
printf("			var iframeHandle_window = iframeHandle.contentWindow;");						//get reference to the iframe's window object
printf("			iframeHandle_window.doStyleUpdatesForRenderedInFavs();");						//call that window's method for updating styles
printf("		}");
printf("		});\n");//end after orientation change
*/

printf("	Y.on('windowresize', function(e){");									// On window resize...
printf("		var winWidth = parseInt(window.innerWidth);");								//local to each event, figure out width/height/orientation after the resize happened...
printf("		var winHeight = parseInt(window.innerHeight);");
printf("		var winOrientation;");
printf("		if(winWidth>winHeight){");
printf("			winOrientation = ORIENTATION_LANDSCAPE;");
printf("		}else{");
printf("			winOrientation = ORIENTATION_PORTRAIT;");
printf("		}");
printf("		FavScreen.log('log',\"YUI Window Resize Change: Detected width=\"+winWidth+\" and height=\"+winHeight+\" (orientation=\"+winOrientation+\").\",false);");
printf("		FavScreen.set('attrWindowWidth', winWidth);");								//set that local information back into our main class' attributes...
printf("		FavScreen.set('attrWindowHeight', winHeight);");
printf("		FavScreen.set('attrDeviceOrientation', winOrientation);");						//note: this attribute should have its own event-listener that fires whenever this attribute's value changes -- in other words, that event may fire after this line executes
printf("		if(FavScreen.menu && FavScreen.menu.get('visible')){");
printf("			FavScreen.menu.reposition(Y.one('#menuicon').ancestor());");					//reposition the menu to the menuicon anchor area
printf("		}");
/*the following was migrated from orientationchange...*/
printf("		window.scrollTo(0,FavScreen.get('attrCurrentScrollPositionPixelY'));");					//make sure we're scrolled to the previous position
printf("		if(FavScreen.get('attrInteractionMode')==MODE_EDITABLE){");						//if we're in edit-mode...
printf("			handleAutoEndEditMode_setOrReset();");									//handle the edit-mode auto-change stuff
printf("			handleAutoEndEditPanel_setOrReset();");									//handle the edit-panel auto-hide stuff
printf("		}");
printf("		var iframeHandle = document.getElementById(\"iframe_toResolveMsg\");");					//try to get a handle to the iframe used to resolve a message for launch (returns null if not available)
printf("		if(iframeHandle){");											//if an iframe to resolve a msg for launch exists, we need to recalculate widths for various elements inside its document
printf("			FavScreen.log('log',\"YUI Window Resize Change: Calling existant iframe's doStyleUpdatesForRenderedInFavs() method...\",false);");
printf("			var iframeHandle_window = iframeHandle.contentWindow;");						//get reference to the iframe's window object
printf("			iframeHandle_window.doStyleUpdatesForRenderedInFavs();");						//call that window's method for updating styles
printf("		}");
printf("		});\n");//end on windowresize

printf("	Y.on('scroll', function(e){");										// On any scroll event (should work for both touch and mousewheel scrolling)
printf("		if(FavScreen.menu && FavScreen.menu.get('visible')){");							//if the menu exists and is currently visible
printf("			FavScreen.menu.reposition(Y.one('#menuicon').ancestor());");						//reposition the menu to the menuicon anchor area
printf("		}");
//DEV-NOTE: the following is really buggy... probably need to calculate some kind of delta/threshold value to make it work?
//printf("		if(typeof ConfirmLaunch!==\"undefined\"){");
//printf("			if(ConfirmLaunch.isVisible()){");
//printf("				ConfirmLaunch.hide(1000);");
//printf("			}");
//printf("		}");
printf("		if(FavScreen.node_bodywrapper == undefined || FavScreen.node_bodywrapper == null){");			//only update scroll value if in regular favorites list mode (no resolve to launch node loaded as indicated by our body node not being saved aside - thus null)...
printf("			var yVal;");
printf("			if(FavScreen.get('attrBrowserSupports_scrollY')){");
printf("				yVal = window.scrollY;");									//better browsers
printf("			}else{");
printf("				var b = document.body || document.documentElement;");						//get a reference to the document body, so we can then use it to test for CSS3 animation capability
printf("				yVal = b.scrollTop;");										//crappy browsers
printf("				if(yVal == 0) {");										//if got a value of 0, it might be valid, but we may also be dealing with an especially shitty browser, indeed... try another way
printf("					b = document.documentElement;");
printf("					yVal = b.scrollTop;");
printf("				}");
printf("			}");
printf("			FavScreen.set('attrCurrentScrollPositionPixelY', yVal);");						//set the current scroll position
printf("		}");
printf("		if(Date.now() - FavScreen.get('attrLastScrolledTimestamp') > 1000){");					//anything in here will get done at a minimum interval (stuff that doesn't require the finest scroll-event precision)
printf("			if(FavScreen.get('attrInteractionMode')==MODE_EDITABLE){");						//if we're in edit-mode...
printf("				handleAutoEndEditMode_setOrReset();");									//handle the edit-mode auto-change stuff
printf("				handleAutoEndEditPanel_setOrReset();");									//handle the edit-panel auto-hide stuff
printf("			}");
printf("		}");
printf("		FavScreen.set('attrLastScrolledTimestamp', Date.now());");
printf("		}, Y.config.win);\n");//end on scroll 

printf("	Y.on('focus', function(e){");										// On any focus-related event (sets to true on a delay to allow tests to happen before it goes to true, since false happens immediately before true whenever focusing the window)
printf("		FavScreen.log('log',\"FavScreen: Window focus detected.\", false);");					//probably important (and infrequent enough) to log this
printf("		FavScreen.set('attrLastFocused_window', Date.now());");							//keep this updated to help ensure we allow immediately-subsequent user-initiated launches to happen
printf("		if(FavScreen.get('attrInteractionMode')==MODE_EDITABLE){");						//if we're in edit-mode...
printf("			handleAutoEndEditMode_setOrReset();");									//handle the edit-mode auto-change stuff
printf("			handleAutoEndEditPanel_setOrReset();");									//handle the edit-panel auto-hide stuff
printf("		}else if(typeof iframeHandle !== \"undefined\"){");							//else if an iframe is currently loaded...
printf("			FavScreen.log('log',\"FavScreen: Window focused while iframe exists. Not executing any refresh.\",true);");
printf("		}else{");												//else any other mode...
printf("			if(isLoadedInMobileApp()) {");										//mobile app handles its own native focus, so make sure we don't do it redundantly
printf("				FavScreen.log('verbose',\"FavScreen: Window focused while loaded in mobile app. Not executing any refresh, so hopefully native-focus can handle it.\",false);");
//printf("			} else {");
//printf("				refreshRecordset('%s', true, false, false);", CurrentUserPin);						//make sure we have the latest favs data
//printf("				refreshRecordset_inboxMsgs(\"%s\",true,false);", CurrentUserPin);					//make sure we have the latest inbox data
printf("			}");
printf("		}");
printf("		}, Y.config.win);\n");

printf("	Y.on('click', function(e){");										// On any tap event
printf("		if(FavScreen.get('attrInteractionMode')==MODE_EDITABLE){");						//if we're in edit-mode...
printf("			handleAutoEndEditMode_setOrReset();");									//handle the edit-mode auto-change stuff
printf("			handleAutoEndEditPanel_setOrReset();");									//handle the edit-panel auto-hide stuff
printf("		}");
printf("		}, Y.config.win);\n");

/* the following is not fully tested... at least doesn't seem to throw console errors
printf("	Y.on('pinch', function(e){");
printf("		if(FavScreen.menu && FavScreen.menu.get('visible')){");							//if the menu exists and is currently visible
printf("			FavScreen.menu.reposition(Y.one('#menuicon').ancestor());");					//reposition the menu to the menuicon anchor area
printf("		}");
printf("		});");//end on 
*/

printf("	Y.on('input', function(e){");										// On any input event (typing characters)
printf("		if(FavScreen.get('attrInteractionMode')==MODE_EDITABLE){");						//if we're in edit-mode...
printf("			handleAutoEndEditMode_setOrReset();");									//handle the edit-mode auto-change stuff
printf("			handleAutoEndEditPanel_setOrReset();");									//handle the edit-panel auto-hide stuff
printf("		}");
printf("		}, Y.config.win);\n");

printf("});\n");//end YUI.use

printf("var ConfirmLaunch, ConfirmCloseMsg;");
printf("function loadModeSpecificAssets(){");									// Take care of loading anything that might be needed for each mode (this improves initial page load time by ensuring things are loaded only when they may be needed)
printf("	if(FavScreen.get('attrInteractionMode')==MODE_LAUNCHABLE){");						//if favorites screen is in launchable mode... (load launch-appropriate stuff if not already loaded)
			//note: most stuff is probably loaded already, since launchable is our default mode
printf("		ConfirmLaunch = new ClassPromptConfirmSend(\"ConfirmLaunch\");");
printf("		ConfirmCloseMsg = new ClassPromptConfirmCloseMsg(\"ConfirmCloseMsg\");");
printf("	}");
printf("	else if(FavScreen.get('attrInteractionMode')==MODE_EDITABLE){");					//else-if favorites screen is in editable mode... (load edit-appropriate stuff if not already loaded)
printf("		if(typeof FavScreen.favIconList===\"undefined\"){load_obj_favIconsFromServer(true);}");			//load all possible favorite icons from the server, so they can later be available for the user if they decide to change icons for favorite messages
printf("		if(typeof FavScreen.panelIconChooser===\"undefined\"){load_yuiPanel_iconChooser();}");			//load a YUI Panel for presenting to the user a way to choose icons, should they later choose to do so
printf("		if(typeof FavScreen.panelEditFav===\"undefined\"){load_yuiPanel_editFavMsg();}");			//load a YUI Panel for presenting to the user a way to edit a favorite message, should they later choose to do so
printf("		if(typeof FavScreen.rsEdited===\"undefined\"){load_yuiRsEdited();}");					//load a YUI Recordset for potentially keeping track of and saving user-edited/sorted favorites
printf("	}");
printf("	else if(FavScreen.get('attrInteractionMode')==MODE_DELETED){");						//else-if favorites screen is in delted-favs mode... (load undelete-appropriate stuff if not already loaded)
//printf("		if(typeof FavScreen.favIconList===\"undefined\"){load_obj_favIconsFromServer(true);}");			//load all possible favorite icons from the server, so they can later be available for the user if they decide to change icons for favorite messages
//printf("		if(typeof FavScreen.panelIconChooser===\"undefined\"){load_yuiPanel_iconChooser();}");			//load a YUI Panel for presenting to the user a way to choose icons, should they later choose to do so
printf("		if(typeof FavScreen.panelUndelete===\"undefined\"){load_yuiPanel_undelete();}");			//load a YUI Panel for presenting to the user a way to un-delete a deleted favorite
printf("		var node_ul = createMessageListNode(FavScreen.rsOrig_deleted, \"messagelist-unsorted-1\", \"\", \"deleted\");");//get deleted favs list node
printf("		var node_contentwrapper = document.getElementById(\"contentwrapper-aux1\");");
printf("		node_contentwrapper.removeChild(node_contentwrapper.childNodes[0]);");
printf("		var numDeletedFavsDisplayed = renderMessageListSection_deleted(node_ul);");				//render the deleted favorites as a node, while returning the number of favorites that got rendered
printf("		FavScreen.set('attrNumDeletedFavsDisplaying', numDeletedFavsDisplayed);");				//inform the global attribute how many deleted favs should be showing on-screen (we likely won't check this, but store it anyway, just in case)
printf("	}");
printf("	else if(FavScreen.get('attrInteractionMode')==MODE_REPLYING){");					//else-if favorites screen is in delted-favs mode... (load undelete-appropriate stuff if not already loaded)
printf("		if(typeof FavScreen.MessageReplyDialog===\"undefined\"){load_yuiPanel_messageReplyDialog();}");		//load a YUI Panel for presenting to the user a way to reply to a message
printf("	}");
printf("	else {");												//else, something didn't go quite right, so fall back to default of launch mode loading (happens sometimes in IE)
printf("		console.warn('loadModeSpecificAssets(): Unknown problem caused a default load (else branch) to launch-mode. Use a REAL browser instead of Internet Explorer.');");
printf("		ConfirmLaunch = new ClassPromptConfirmSend(\"ConfirmLaunch\");");
printf("		ConfirmCloseMsg = new ClassPromptConfirmCloseMsg(\"ConfirmCloseMsg\");");
printf("	}");
printf("}\n");//end function loadModeSpecificAssets()

printf("function isToggleActiveFor(favRecno){");								// Return boolean for whether toggle is active for the given favRecno (recordset should have server-calculated end dtsec for active, toggle-able messages... so examine that)
printf("	favRecno = favRecno.toString();");
printf("	if(!rs_isValidArg_favRecno(favRecno)){return false;}");							//validate argument
//DEV-NOTE: the following line is kinda hard-coded with rsRecentDB... while this is probably just fine (it's always the latest dataset), might be best to migrate over to using the arrToggleData stuff somehow? Might need to, to support multiple toggles per favorite?
//printf("	var favToggleEndDtsec = parseInt(rsRec_getToggleEndDtsec(FavScreen.rsRecentDB, favRecno));");		//attempt to get the server-calculated toggle end dtsec value (if exists, should be smaller than standard 1970 UNIX-epoch-derived value, since ours is based off 1980 something)
printf("	var rs = FavScreen.rsOrig || FavScreen.rsRecentDB;");
printf("	var favToggleEndDtsec_rawRet = rsRec_getToggleEndDtsec(rs, favRecno);");				//attempt to get the server-calculated toggle end dtsec value (if exists, should be smaller than standard 1970 UNIX-epoch-derived value, since ours is based off 1980 something)
printf("	var favToggleEndDtsec = parseInt(favToggleEndDtsec_rawRet);");						//parse to a calcuable number (note: will return NaN if not a number)
printf("	var favToggleDuration_rawRet = rsRec_getToggleDuration(rs, favRecno);");
printf("	var favToggleDuration = parseInt(favToggleDuration_rawRet);");
printf("	if(isNaN(favToggleEndDtsec)){");									//if cannot determine the toggle end dtsec (e.g. function returns false)

printf("		FavScreen.log('info',\"isToggleActiveFor(\"+favRecno+\"): rsRec_getToggleEndDtsec() returned '\"+favToggleEndDtsec_rawRet+\"' (NaN). Cannot determine whether toggle is currently active, so returning false.\",true);");
printf("		FavScreen.log('verbose',\"isToggleActiveFor(\"+favRecno+\"): If NaN, then there could be previous active-copy recno(s) in the FV record (possibly all with expired toggle durations), or toggle duration isn't being reported by (or isn't saved in) Banner database.\",true);");
//DEV-NOTE: add a fall-back to talk to server and try to determine what the next most recent active-copy-recno's remaining duration is?
//DEV-NOTE: or, clear the active-copy-recnos field for this FV record? (if do that, it might hurt our eventual desire to allow user-choice of which toggle to close?)
//DEV-NOTE: or, implement a FIFO scheme in the add-routine, and never worry?
//		DID the FIFO thing... seems alright so far
printf("		return false;");

printf("	}else{");
printf("		FavScreen.log('log',\"isToggleActiveFor(\"+favRecno+\"): favToggleEndDtsec=\"+favToggleEndDtsec+\" (diff from now is \"+(getCurrentDtsec_serverEstimate()-favToggleEndDtsec)+\" seconds).\",true);");
printf("		if(getCurrentDtsec_serverEstimate() < favToggleEndDtsec){");					//if the toggle end time hasn't yet passed...
printf("			FavScreen.log('verbose',\"isToggleActiveFor(\"+favRecno+\"): Toggle should be active for another \"+(favToggleEndDtsec-getCurrentDtsec_serverEstimate())+\" seconds.\",true);");
printf("			return true;");
printf("		}else{");											//else the toggle end time has passed...
printf("			FavScreen.log('verbose',\"isToggleActiveFor(\"+favRecno+\"): Toggle duration ended \"+(getCurrentDtsec_serverEstimate()-favToggleEndDtsec)+\" seconds ago.\",true);");
printf("			return false;");
printf("		}");
printf("	}");
printf("}\n");//end function isToggleActiveFor()

printf("var arrToggleTimeoutHandles = [];");									//initialize a global array for storing handles to setTimeouts for toggle
printf("function setOrUnsetToggleTimeoutFor(favRecno){");							// Handle setting up an auto-timeout for a messagecell's toggle icon... returns a handle to the setTimeout instance, in case you want to cancel it (but also gets stored in the global array above, anyway)
printf("	var ret = false;");											//initialize a default return value
printf("	favRecno = favRecno.toString();");
printf("	if(!rs_isValidArg_favRecno(favRecno)){return ret;}");							//validate required argument
printf("	var rs = FavScreen.rsOrig || FavScreen.rsRecentDB;");							//get reference to a valid recordset
printf("	var favToggleEndDtsec = parseInt(rsRec_getToggleEndDtsec(rs, favRecno));");				//attempt to get the server-calculated toggle end dtsec value (if exists, should be smaller than standard 1970 UNIX-epoch-derived value, since ours is based off 1980 something)
printf("	if(isNaN(favToggleEndDtsec)) {");									//if cannot determine the toggle end dtsec (e.g. function returns false)
printf("		FavScreen.log('warn',\"setOrUnsetToggleTimeoutFor(\"+favRecno+\"): rsRec_getToggleEndDtsec() returned \"+favToggleEndDtsec+\", which isNaN, so cannot determine whether toggle is currently active. Returning \"+ret.toString()+\".\",true);");
printf("		return ret;");
printf("	}");
printf("	else {");												//else we got toggle end-time data
printf("		FavScreen.log('log',\"setOrUnsetToggleTimeoutFor(\"+favRecno+\"): favToggleEndDtsec = \"+favToggleEndDtsec+\". Proceeding to setup timeout.\",false);");
printf("		if(getCurrentDtsec_serverEstimate() < favToggleEndDtsec) {");					//if the toggle end time hasn't yet passed... (then calculate how much time remains for the toggle, and setup a timeout to automatically take the toggle icon down)
printf("			var secondsRemaining = favToggleEndDtsec - getCurrentDtsec_serverEstimate();");			//calculate remaining toggle time
printf("			FavScreen.log('log',\"setOrUnsetToggleTimeoutFor(\"+favRecno+\"): Toggle should be active for another \"+secondsRemaining+\" seconds.\",true);");
printf("			ret = setTimeout(function(){");									//define what should happen once the toggle time expires, and immediately set it into motion... (saving a handle to that setTimeout routine)
printf("				FavScreen.log('log',\"arrToggleTimeoutHandles: A fav's toggle auto-timeout is executing, so updating all toggle icons.\",true);");
printf("				updateMessagecells_nodesAffectedByToggle();");							//update all messagecells' nodes affected by toggle (the toggle icon img nodes)
printf("				setTimeout(function(){refreshRecordset_inboxMsgs(\"%s\",false,false);},1000);", CurrentUserPin);//make sure we have the latest inbox data (but use a delay, to give server/banner time to actually update before reading its database), in case the msg also ended along with the toggle-end
printf("				}, (secondsRemaining*1000));");
printf("			arrToggleTimeoutHandles[parseInt(favRecno)] = ret;");						//save the setTimeout handle(r) to the global array (so it may be later cleared outside of this function, if needed... also so we easily know if a fav-msg has an active toggle)
printf("		}");
printf("		else {");											//else toggle end time has passed   NOTE: not sure if this is right, but cleaning up the array just in case execution gets here somehow
printf("			var secondsSinceToggleEnded = getCurrentDtsec_serverEstimate() - favToggleEndDtsec;");
printf("			FavScreen.log('verbose',\"setOrUnsetToggleTimeoutFor(\"+favRecno+\"): Toggle active period has been finished for \"+secondsSinceToggleEnded+\" seconds. Clearing arrToggleTimeoutHandles[\"+favRecno+\"] element.\",true);");
printf("			clearTimeout(arrToggleTimeoutHandles[parseInt(favRecno)]);");					//should be already cleared (by virtue of auto-timing out), but just be safe and cancel the setTimeout anyway
printf("			arrToggleTimeoutHandles[parseInt(favRecno)] = undefined;");					//un-define the handle reference
printf("			arrToggleTimeoutHandles.splice(parseInt(favRecno), 1);");					//and finally, to be extra safe, physically remove the element from the array... should be totally nuked at this point
printf("		}");
printf("	}");
printf("	return ret;");
printf("}\n");//end function setOrUnsetToggleTimeoutFor()

printf("var arr_validValuesFor_cssDisplay = ['inline','block','inline-block','inline-table','list-item','none','inherit'];");
printf("function updateMessagecells_nodesAffectedByInteractionMode(strDisplayStyle){");				// Take care of updating all of the messagecells' nodes that have anything to do with interaction mode
printf("	var cfgClassName = \"affectedbyinteractionmode\";");
printf("	if(arr_validValuesFor_cssDisplay.indexOf(strDisplayStyle)>-1){");					//if an explicit style-display value was provided, then explicitly do it
printf("		FavScreen.log('log',\"updateMessagecells_nodesAffectedByInteractionMode(): Explicit display style specified, setting all nodes to '\"+strDisplayStyle+\"'.\",false);");
printf("		var arrNodes = document.getElementsByClassName(cfgClassName);");				//get an array of all nodes of the specified class name
printf("		for(var i=0; i<arrNodes.length; i++){");							//going through each affectedbyinteractionmode node...
//printf("			if((FavScreen.get('attrInteractionMode')==MODE_EDITABLE) && (arrNodes[i].parentNode.parentNode.parentNode.parentNode.getAttribute('data-userpin')!=CURRENT_USER_PIN)) {");	//if going to edit mode AND this iteration is for a library messagecell that is not owned by this user, skip it
printf("			if(FavScreen.get('attrInteractionMode') == MODE_EDITABLE) {");					//if we're entering or already in edit mode
printf("				if(arrNodes[i].parentNode.parentNode.className.indexOf('libmsg') > -1) {");			//if this is for a library message (we will need additional conditional checks before updating nodes affected by interaction mode)
printf("					if(FavScreen.get('attrBrowserSupports_dataset')){");						//acquire this library's userpin data attribute
printf("						li_data_userpin = arrNodes[i].parentNode.parentNode.parentNode.parentNode.dataset.userpin;");
printf("					}else{");
printf("						li_data_userpin = arrNodes[i].parentNode.parentNode.parentNode.parentNode.getAttribute(\"data-userpin\");");
printf("					}");
printf("					if(CURRENT_USER_PIN != li_data_userpin) {");							//if the current user is not the owner of this library, skip showing any nodes that may allow them to edit msgs in it
printf("						arrNodes[i].style.display = 'none';");
printf("						continue;");
printf("					}");
printf("				}");
printf("			}");
printf("			arrNodes[i].style.display = strDisplayStyle;");						//apply the explicitly-specified style
printf("		}");
printf("	}else{");												//else need to figure out and do stuff intelligently...
printf("		FavScreen.log('info',\"updateMessagecells_nodesAffectedByInteractionMode(): else case not yet developed.\",true);");
printf("	}");
printf("}\n");//end function updateMessagecells_nodesAffectedByToggle()
printf("var updateMessagecells_nodesAffectedByToggle_lastExecutionCompleted = 0;");
printf("var alreadyToggledOffNewestActiveCopy_forFavRecno_thisSession = [];");	//favrecno-keyed array for tracking toggles for the session ~~For 0.40.2-beta, to appease Kevin not wanting to show ANY toggle for any remaining active copies, until multiple toggle capability exists
printf("function updateMessagecells_nodesAffectedByToggle(strDisplayStyle){");					// Take care of updating all of the messagecells' nodes that have anything to do with the toggle feature (if param supplied, it will apply it to all, otherwise it's intelligent)
printf("	FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(\"+strDisplayStyle+\"): Function called.\",false);");
printf("	var cfg_minMillisecsBetweenExecutions = 500;");
printf("	var executionTimeThatHasPassed = (new Date().getTime()) - updateMessagecells_nodesAffectedByToggle_lastExecutionCompleted;");
printf("	if(executionTimeThatHasPassed < cfg_minMillisecsBetweenExecutions){");
printf("		FavScreen.log('info',\"updateMessagecells_nodesAffectedByToggle(): Minimum execution time of \"+cfg_minMillisecsBetweenExecutions+\"ms has not passed (\"+executionTimeThatHasPassed+\"). Aborting, to prevent unnecessary repeated rapid-fire calls.\",false);");
printf("		return false;");
printf("	}");
printf("	var cfgClassName = \"affectedbytoggle\";");
printf("	if(arr_validValuesFor_cssDisplay.indexOf(strDisplayStyle)>-1){");					//if an explicit style-display value was provided, then explicitly do it for all
printf("		FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): Explicit display style specified, setting all nodes to '\"+strDisplayStyle+\"'.\",false);");
printf("		var arrNodes = document.getElementsByClassName(cfgClassName);");					//get an array of all nodes of the specified class name
printf("		for(var i=0; i<arrNodes.length; i++){");								//going through each affectedbytoggle node...
printf("			arrNodes[i].style.display = strDisplayStyle;");							//apply the explicitly-specified style
printf("		}");
printf("		updateMessagecells_nodesAffectedByToggle_lastExecutionCompleted = new Date().getTime();");
printf("		return i;");												//return the number of nodes affected
printf("	}else{");												//else need to figure out whether to show or not, intelligently...
//printf("		FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): No explicit display style specified, determining which toggle icons to display/hide based on current recordset values.\",true);");
printf("		FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): No explicit display style specified, determining which toggle icons to display/hide based on current recordset values.\",true);");
printf("		var toggleIconHandler = function(e) {");								//define a routine for what should happen if a toggle icon is clicked by the user (gets passed the user's click/tap event, which is what makes this modular for any toggle icon)
printf("			var favRecno = e.target.id;");										//get the favRecno from the messagecell they clicked (it's stored as the id attribute value)
printf("			FavScreen.log('log',\"toggleIconHandler: Clicked toggle icon for favRecno \"+favRecno+\", so calling closeMessage(\"+favRecno+\")...\",true);");
printf("			closeMessage(favRecno);");										//send the command to close an active-copy related to this fav-msg (that routine can handle determining favRecno vs. inboxRecno, so don't worry about that)
printf("			e.stopPropagation();");											//prevent the click/tap event from bubbling up further (helps prevent unintended launches)   NOTE: this is important!
printf("			};");
printf("		function enableToggleIcon(favRecno) {");								//enable the specified fav's toggle icon (assigns its handler, shows the icon, etc.)
printf("			FavScreen.log('verbose',\"enableToggleIcon(\"+favRecno+\"): Called.\",true);");
printf("			try {");
printf("				var node_thisToggleIcon = document.getElementById(\"toggleicon_\"+favRecno);");				//get a handle to the toggle icon node for this fav
printf("				node_thisToggleIcon.onclick = null;");									//reinitialize the onclick listener (just to make extra-sure the node won't receive multiple event listeners)
printf("				node_thisToggleIcon.onclick = toggleIconHandler;");							//assign our event handler (routine defined above)
printf("				node_thisToggleIcon.style.display = 'inline';");							//set the toggle icon node to be visible (of course, it will need its actionwrapper container to be visible as well)
printf("				document.getElementById(\"draghandleicon_\"+favRecno).style.display = 'none';");			//ensure we hide siblings in the actionwrapper node, that wouldn't be appropriate with toggle - this one could be a holdover from edit mode, in case it didn't clean up properly
printf("				document.getElementById(favRecno).getElementsByClassName(\"actionwrapper\")[0].style.display='block';");//show the actionwrapper to expose the toggle icon
printf("				return true;");
printf("			} catch(err) {");
printf("				FavScreen.log('verbose',\"enableToggleIcon(\"+favRecno+\"):  Caught error: \"+err.message+\".\",true);");
printf("				return false;");
printf("			}");
printf("		}");
printf("		function disableToggleIcon(favRecno) {");								//disable the specified fav's toggle icon (cleans up its handler, hides icon, etc.)
printf("			FavScreen.log('verbose',\"disableToggleIcon(\"+favRecno+\"): Called.\",true);");
printf("			try {");
printf("				var node_thisToggleIcon = document.getElementById(\"toggleicon_\"+favRecno);");				//get a handle to the toggle icon node for this fav
printf("				if(node_thisToggleIcon === null) {");
printf("					if(document.getElementById(favRecno) !== null) {");
printf("						FavScreen.log('verbose',\"disableToggleIcon(\"+favRecno+\"):  No toggle icon node found for this favRecno (favRecno-node's class is '\"+document.getElementById(favRecno).getAttribute('class')+\"').\",true);");
printf("						return false;");
printf("					}");
printf("					FavScreen.log('verbose',\"disableToggleIcon(\"+favRecno+\"):  No toggle icon node found for this favRecno.\",true);");
printf("					return false;");
printf("				}");
printf("				node_thisToggleIcon.style.display = 'none';");								//set the toggle icon node to be invisible
printf("				node_thisToggleIcon.onclick = null;");									//reinitialize the onclick listener (just to make extra-sure the node doesn't carry any unnecessary overhead while unused)
printf("				return true;");
printf("			} catch(err) {");
printf("				FavScreen.log('verbose',\"disableToggleIcon(\"+favRecno+\"):  Caught error: \"+err.message+\".\",true);");
printf("				return false;");
printf("			}");
printf("		}");
printf("		var arrMessageCellNodes = document.getElementsByClassName('messagecell');");				//get an array of all messagecell nodes (which we'll then go through to determine whether to show/hide its toggle icon)
printf("		for(var i=0; i<arrMessageCellNodes.length; i++){");							//going through all messagecell nodes...
printf("			var favRecno = parseInt(arrMessageCellNodes[i].id);");						//get the favorites recno (which is the id of messagecell nodes).. we'll need it to reference the recordset to ascertain any active copy recnos
printf("			if(isNaN(favRecno)){continue;}");								//if this list item isn't an actual message (as indicated by an id with recno), go to the next iteration to avoid any errors and be safe
printf("			FavScreen.log('verbose',\"updateMessagecells_nodesAffectedByToggle(): Checking for favRecno \"+favRecno+\"...\",true);");
//REQUIREMENTS:
//Since this could be called from any message operation or at any time (launch, close, refreshing, etc.), it needs to look at each
//favorite message, and determine if any active toggles exist... not sure exactly, but should reference arrToggleTimeoutHandles,
//as well as (?) recordset data (as long as it's latest?) for the toggle end dtsec? -- maybe that is a fallback and/or nested?

printf("			var arrActiveCopyRecnos = rsRec_getActiveCopies_asArray((FavScreen.rsOrig || FavScreen.rsRecentDB),favRecno.toString());");//get an array of active copy recnos from the recordset, for this fav (which should be the latest, as refreshRecordset is what's ultimately calling this - even after launch)
printf("			var node_thisToggleIcon = document.getElementById(\"toggleicon_\"+favRecno);");			//get a handle to the toggle icon node for this favorite
/*
printf("			if(arrActiveCopyRecnos.length > 0) {");								//if recordset reports active copies of this fav, then we may need to show toggle icon... (depends on particulars: is it the only toggle, latest, etc.?)
printf("				FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): Fav record \"+favRecno+\" seems to have \"+arrActiveCopyRecnos.length+\" or more active-copy-records (\"+arrActiveCopyRecnos+\"). Now testing any toggle-duration data...\",true);");
printf("				if(isToggleActiveFor(favRecno.toString())){");							//if recordset-indicated toggle still shows some remaining duration...
//printf("					FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): Fav record \"+favRecno+\" with active-copy-recno(s) has a currently-active toggle. Now testing whether it's already been toggled off...\",true);");
//printf("					if(arrActiveCopyRecnos.indexOf(alreadyToggledOffNewestActiveCopy_forFavRecno_thisSession[favRecno])==-1){");//if the active-copies array does NOT contain a recno that we've already toggled-off, then probably safe to show the toggle icon
printf("						FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): Fav record \"+favRecno+\" with active-copy-recno(s) seems to have not yet been toggled off. Enabling toggle icon.\",true);");
printf("						if(enableToggleIcon(favRecno)) {");
printf("							setOrUnsetToggleTimeoutFor(favRecno);");						//NOTE: by setting the timeout here, then ideally this update routine gets called at launch-success.. (or any other recordset-refresh routine's success, really?)
printf("						}");
//printf("					}");
//printf("					else {");											//else active-copies array contains a recno that's already been toggled-off, so don't show the toggle icon
//printf("						FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): Fav record \"+favRecno+\" with active-copy-recno(s) seems to have already been toggled off. Disabling any toggle icon.\",true);");
//printf("						disableToggleIcon(favRecno);");
//printf("					}");
printf("				}");
printf("				else {");											//else no remaining duration for the toggle, so don't show a toggle icon
printf("					FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): Fav record \"+favRecno+\" with active-copy-recno(s) does NOT have a currently-active toggle. Disabling any toggle icon.\",true);");
printf("					disableToggleIcon(favRecno);");
printf("				}");
printf("			}");
printf("			else {");											//else recordset shows NO active copies of this fav, so definitely don't show a toggle icon
printf("				FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): Fav record \"+favRecno+\" has no active-copy-recnos. Disabling any toggle icon.\",true);");
printf("				disableToggleIcon(favRecno);");
printf("			}");
*/
				//if this msg has 1 or more active copy recno(s), we may need to show the toggle icon (depends on whether the newest active-copy's toggle-duration has expired or not)
printf("			if(arrActiveCopyRecnos.length > 0) {");
printf("				var newestActiveCopy = arrActiveCopyRecnos[arrActiveCopyRecnos.length-1];");	//the newest one should always be the last one in the array (at the end of the field's string value), due to our FIFO scheme
printf("				FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): Fav record \"+favRecno+\" has \"+arrActiveCopyRecnos.length+\" active-copy-record(s) (\"+arrActiveCopyRecnos+\"). Now testing any toggle-duration data for newest one (\"+newestActiveCopy+\")...\",true);");
printf("				if(isToggleActiveFor(favRecno.toString())) {");		//if the newest active copy's toggle is still in effect, show the toggle icon
//printf("					FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): Fav record \"+favRecno+\" with newest active-copy-recno \"+newestActiveCopy+\" has a currently-active toggle. Now testing whether it's already been toggled off...\",true);");
//printf("					if(arrActiveCopyRecnos.indexOf(alreadyToggledOffNewestActiveCopy_forFavRecno_thisSession[favRecno])==-1){");//if the active-copies array does NOT contain a recno that we've already toggled-off, then probably safe to show the toggle icon
printf("						FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): Fav record \"+favRecno+\" with active-copy-recno(s) seems to have not yet been toggled off. Enabling toggle icon.\",true);");
printf("						if(enableToggleIcon(favRecno)) {");
printf("							setOrUnsetToggleTimeoutFor(favRecno);");						//NOTE: by setting the timeout here, then ideally this update routine gets called at launch-success.. (or any other recordset-refresh routine's success, really?)
printf("						}");
//printf("					}");
//printf("					else {");											//else active-copies array contains a recno that's already been toggled-off, so don't show the toggle icon
//printf("						FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): Fav record \"+favRecno+\" with active-copy-recno(s) seems to have already been toggled off. Disabling any toggle icon.\",true);");
//printf("						disableToggleIcon(favRecno);");
//printf("					}");
printf("				}");
printf("				else {");						//else the newest active copy's toggle must have expired, so don't show the toggle icon
printf("					FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): Fav record \"+favRecno+\" with active-copy-recno(s) has an expired toggle. Disabling any toggle icon.\",true);");
printf("					disableToggleIcon(favRecno);");
printf("				}");
printf("			}");
				//else there must be no active copy recnos for this msg...
printf("			else {");
printf("				FavScreen.log('log',\"updateMessagecells_nodesAffectedByToggle(): Fav record \"+favRecno+\" has no active-copy-recnos. Disabling any toggle icon.\",true);");
printf("				disableToggleIcon(favRecno);");
printf("			}");
printf("		}");
printf("		updateMessagecells_nodesAffectedByToggle_lastExecutionCompleted = new Date().getTime();");
printf("	}");
printf("}\n");//end function updateMessagecells_nodesAffectedByToggle()

printf("function updateMessagecells(){");									// Take care of updating anything about the messagecells
printf("	if(FavScreen.get('attrInteractionMode')==MODE_LAUNCHABLE){");						//if favorites screen is in launchable mode...
printf("		if(FavScreen.get('attrLayoutMode')==LAYOUT_LIST){");							//if favorites screen is set to show in a list layout...
printf("			FavScreen.log('log','updateMessageCells(): Called while in launch-mode. Executing appropriate update-functions...',false);");
printf("			updateMessagecells_nodesAffectedByInteractionMode(\"none\");");						//hide all affectedbyinteractionmode nodes
//printf("			var arrNodes_actionwrapper = document.getElementsByClassName('actionwrapper');");			//get an array of all actionwrapper nodes on the page
//printf("			for(var i=0; i<arrNodes_actionwrapper.length; i++){");							//going through each actionwrapper node...
//printf("				arrNodes_actionwrapper[i].style.display = \"none\";");							//hide the actionwrapper node
//printf("			}");
printf("			updateMessagecells_nodesAffectedByToggle();");
printf("		}");
printf("		else if(FavScreen.get('attrLayoutMode')==LAYOUT_GRID){");						//else if favorites screen is set to show in a grid layout...
printf("			FavScreen.log(\"warn\", \"DEV-NOTE: updateMessagecells() does not yet support grid layout\", true);");
printf("		}");
printf("	}");
printf("	else if(FavScreen.get('attrInteractionMode')==MODE_EDITABLE){");					//else-if favorites screen is in editable mode...
printf("		if(FavScreen.get('attrLayoutMode')==LAYOUT_LIST){");							//if favorites screen is set to show in a list layout...
printf("			FavScreen.log('log','updateMessageCells(): Called while in edit-mode. Executing appropriate update-functions...',false);");
printf("			if(YUI.Env.UA.android>0 && YUI.Env.UA.chrome<35.01916){");						//drag-and-drop not supported on certain older android browsers
printf("				FavScreen.log('info', \"updateMessagecells() not making drag handles visible, due to lack of Android browser support.\", true);");
printf("			}");//end if Android
printf("			else{");												//else display drag-and-drop capability
printf("				updateMessagecells_nodesAffectedByToggle(\"none\");");							//hide all affectedbytoggle nodes
printf("				updateMessagecells_nodesAffectedByInteractionMode(\"inline\");");					//display all affectedbyinteractionmode nodes
printf("				var arrNodes_actionwrapper = document.getElementsByClassName('actionwrapper');");			//get an array of all actionwrapper nodes on the page
//DEV-NOTE: add some logic to scroll to previous position... because, after display stuff, text may wrap, etc. that causes the whole page to shift down... should use native scrollY rather than attrCurrentScrollPositionPixelY, since it might update better
printf("				for(var i=0; i<arrNodes_actionwrapper.length; i++){");							//going through each actionwrapper node...
printf("					arrNodes_actionwrapper[i].style.display = \"block\";");							//show the actionwrapper node
printf("				}");//end for
printf("			}");//end else
printf("			setTimeout(function(){updateMessagecells_nodesAffectedByToggle(\"none\");},500);");							//hide all affectedbytoggle nodes
printf("		}");
printf("		else if(FavScreen.get('attrLayoutMode')==LAYOUT_GRID){");						//else if favorites screen is set to show in a grid layout...
printf("			FavScreen.log('warn', \"DEV-NOTE: updateMessagecells() does not yet support grid layout\", true);");
printf("		}");
printf("	}");
printf("	else if(FavScreen.get('attrInteractionMode')==MODE_REPLYING){");					//else-if favorites screen is in replying mode...
printf("		FavScreen.log('log','updateMessageCells(): Called while in reply-mode. Executing appropriate update-functions...',false);");
printf("		updateMessagecells_nodesAffectedByToggle();");
printf("	}");
printf("	attachFastClick();");
printf("}\n");//end function updateMessagecells()

printf("function handleAutoEndEditMode_clear(){");								// Clear/cancel the automatic timeout handle for edit-mode
printf("	if(typeof FavScreen.timeoutHandle_autoEndEditMode!==\"undefined\"){");					//if handle for setTimeout exists, clear and reinitialize it
printf("		FavScreen.log('log',\"handleAutoEndEditMode_clear(): Starting... FavScreen.timeoutHandle_autoEndEditMode=\"+FavScreen.timeoutHandle_autoEndEditMode+\", so clearing and re-initializing it to un-used state.\",false);");
printf("		clearTimeout(FavScreen.timeoutHandle_autoEndEditMode);");						//clear the setTimeout (cancels it)
printf("		FavScreen.timeoutHandle_autoEndEditMode = undefined;");							//re-initialize the handle
printf("		FavScreen.log('log',\"handleAutoEndEditMode_clear(): Finished... FavScreen.timeoutHandle_autoEndEditMode=\"+FavScreen.timeoutHandle_autoEndEditMode+\".\",false);");
printf("	}");
printf("}\n");//end function handleAutoEndEditMode_clear()
printf("function handleAutoEndEditMode_setOrReset(intSeconds){");						// Set or reset an automatic timeout for an edit-mode session (returns a handle to the timeout, so you can cancel it if you want)... if called, will start or restart auto-timeout countdown
printf("	handleAutoEndEditMode_clear();");									//if handle for setTimeout exists, clear it
printf("	if(FavScreen.get('attrInteractionMode')!=MODE_EDITABLE){");						//if we're not in edit mode, abort this function return false (leaving a cancelled timer)
printf("		FavScreen.log('log',\"handleAutoEndEditMode_setOrReset(): Not in edit mode, so no need to set auto-timeout for ending edit mode... aborting.\",false);");
printf("		return false;");
printf("	}");
printf("	if(typeof FavScreen.panelEditFav===\"object\"){");							//if the edit panel is active and visible, we need to leave the edit-mode auto timeout cancelled
printf("		if(FavScreen.panelEditFav.get('visible')==true){");
printf("			FavScreen.log('log',\"handleAutoEndEditMode_setOrReset(): The edit-panel is visible, so should not auto-end edit-mode... aborting.\",false);");
printf("			return false;");
printf("		}");
printf("	}");
printf("	if(typeof FavScreen.panelIconChooser===\"object\"){");							//if the icon chooser panel is active and visible, we need to leave the edit-panel auto timeout cancelled
printf("		if(FavScreen.panelIconChooser.get('visible')==true){");
printf("			FavScreen.log('log',\"handleAutoEndEditMode_setOrReset(): The icon-chooser is visible, so should not auto-end edit-mode... aborting.\",false);");
printf("			return false;");
printf("		}");
printf("	}");
printf("	if(typeof intSeconds===\"undefined\"){");								//if no argument was provided, set default timeout, in seconds
printf("		intSeconds = 30;");
printf("		FavScreen.log('log',\"handleAutoEndEditMode_setOrReset(): No duration specified. Defaulting to \"+intSeconds+\" seconds.\",false);");
printf("	}");
printf("	var fnAutoEndEditMode = function(){");									//define how to end edit-mode / what happens when edit-mode ends
printf("		if(typeof FavScreen.panelEditFav===\"object\"){");							//if the edit panel is active and visible, we need to leave the edit-mode auto timeout cancelled
printf("			if(FavScreen.panelEditFav.get('visible')==true){");
printf("				FavScreen.log('log',\"fnAutoEndEditMode(): The edit-panel is visible, so should not auto-end edit-mode... aborting.\",false);");
printf("				return false;");
printf("			}");
printf("		}");
printf("		if(typeof FavScreen.panelIconChooser===\"object\"){");							//if the icon chooser panel is active and visible, we need to leave the edit-panel auto timeout cancelled
printf("			if(FavScreen.panelIconChooser.get('visible')==true){");
printf("				FavScreen.log('log',\"fnAutoEndEditMode(): The icon-chooser is visible, so should not auto-end edit-mode... aborting.\",false);");
printf("				return false;");
printf("			}");
printf("		}");
printf("		FavScreen.set('attrInteractionMode',MODE_LAUNCHABLE);");
printf("		FavScreen.log('log', \"handleAutoEndEditMode_setOrReset(): setTimeout automatically returned to launch-mode after \"+intSeconds+\" seconds of inactivity.\", true);");
printf("		};");//end fnAutoEndEditMode definition
printf("	var intMilliseconds = intSeconds*1000;");
printf("	FavScreen.timeoutHandle_autoEndEditMode = setTimeout(fnAutoEndEditMode,intMilliseconds);");		//set the timeout, passing a global handle to it back to the FavScreen class
printf("	FavScreen.log('log',\"handleAutoEndEditMode_setOrReset(): Finished... FavScreen.timeoutHandle_autoEndEditMode=\"+FavScreen.timeoutHandle_autoEndEditMode+\" may auto-end edit-mode in \"+intSeconds+\" seconds.\",true);");
printf("	return FavScreen.timeoutHandle_autoEndEditMode;");							//return a reference to the global handle that we just created, so it's that much easier to cancel it if needed
printf("}\n");//end function handleAutoEndEditMode_setOrReset()

printf("function handleAutoEndEditPanel_clear(){");								// Clear/cancel the automatic timeout handle for the edit-panel
printf("	if(typeof FavScreen.timeoutHandle_autoEndEditPanel!==\"undefined\"){");					//if handle for setTimeout exists, clear and reinitialize it
printf("		FavScreen.log('log',\"handleAutoEndEditPanel_clear(): Starting... FavScreen.timeoutHandle_autoEndEditPanel=\"+FavScreen.timeoutHandle_autoEndEditPanel+\", so clearing and re-initializing it to un-used state.\",false);");
printf("		clearTimeout(FavScreen.timeoutHandle_autoEndEditPanel);");						//clear the setTimeout (cancels it)
printf("		FavScreen.timeoutHandle_autoEndEditPanel = undefined;");						//re-initialize the handle
printf("		FavScreen.log('log',\"handleAutoEndEditPanel_clear(): Finished... FavScreen.timeoutHandle_autoEndEditPanel=\"+FavScreen.timeoutHandle_autoEndEditPanel+\".\",false);");
printf("	}");
printf("}\n");//end function handleAutoEndEditPanel_clear()
printf("function handleAutoEndEditPanel_setOrReset(intSeconds,boolEndNow){");					// Set or reset an automatic timeout for an edit-panel session (returns a handle to the timeout, so you can cancel it if you want)... if called, will start or restart auto-timeout countdown
printf("	handleAutoEndEditPanel_clear();");									//if handle for setTimeout exists, clear it
printf("	if(typeof intSeconds===\"undefined\"){");								//if no argument was provided, set default timeout, in seconds
printf("		intSeconds = 30;");
printf("		FavScreen.log('log',\"handleAutoEndEditPanel_setOrReset(): No duration specified. Defaulting to \"+intSeconds+\" seconds.\",false);");
printf("	}");
printf("	var fnAutoEndEditPanel = function(){");									//define how to hide edit-panel / what happens when edit-panel hides
printf("		if(typeof FavScreen.panelIconChooser===\"object\"){");							//if the icon chooser panel is active and visible, we need to leave the edit-panel auto timeout cancelled
printf("			if(FavScreen.panelIconChooser.get('visible')==true){");
printf("				FavScreen.panelIconChooser.hide();");
printf("			}");
printf("		}");
printf("		var node_modalMask = document.getElementsByClassName(\"yui3-widget-mask\")[0];");			//get a reference to the modal mask (which, of course, is provided whenever a YUI-Panel reders)
printf("		var headerwrapperHeight = document.getElementById(\"headerwrapper\").offsetHeight;");			//get the calculated height of the headerwrapper area (including padding, etc.)
printf("		FavScreen.panelEditFav.hide();");
printf("		node_modalMask.style.top = headerwrapperHeight+\"px\";");						//position the modal mask so that the header area isn't masked
printf("		node_modalMask.style.display = \"block\";");								//re-show the modal mask immediately after the panel hides, so as to prevent accidental clicks/taps if they do it right as it's timing-out (we'll re-hide it with a timeout, next...)
printf("		FavScreen.log('log', \"handleAutoEndEditPanel_setOrReset(): setTimeout automatically hid edit-panel after \"+intSeconds+\" seconds of inactivity.\", true);");
printf("		setTimeout(function(){");										//this timeout will re-hide the modal mask
printf("			var node_modalMask = document.getElementsByClassName(\"yui3-widget-mask\")[0];");		//get a reference to the modal mask (which, of course, is provided whenever a YUI-Panel reders)
printf("			node_modalMask.style.display = \"none\";");							//hide the modal mask
printf("			node_modalMask.style.top = \"0px\";");								//reset the modal mask's original position for masking the entire document
printf("			},500);");
printf("		};");//end fnAutoEndEditPanel definition
printf("	if(intSeconds == 0) {");
printf("		fnAutoEndEditPanel();");
printf("		return false;");
printf("	}");
printf("	if(typeof FavScreen.panelEditFav===\"undefined\"){");							//if an edit panel isn't instantiated, abort this function return false (leaving a cancelled auto-end timer)
printf("		FavScreen.log('log',\"handleAutoEndEditPanel_setOrReset(): No edit panel instantiated (perhaps user hasn't entered edit-mode yet), so no need to set auto-timeout for hiding it... aborting.\",false);");
printf("		return false;");
printf("	}");
printf("	if(FavScreen.panelEditFav.get('visible')==false){");							//if an edit panel isn't showing, abort this function return false (leaving a cancelled auto-end timer)
printf("		FavScreen.log('log',\"handleAutoEndEditPanel_setOrReset(): No edit panel showing, so no need to set auto-timeout for hiding it... aborting.\",false);");
printf("		return false;");
printf("	}");
printf("	if(typeof FavScreen.panelIconChooser===\"object\"){");							//if the icon chooser panel is active and visible, we need to leave the edit-panel auto-end timeout cancelled
printf("		if(FavScreen.panelIconChooser.get('visible')==true){");
printf("			FavScreen.log('log',\"handleAutoEndEditPanel_setOrReset(): The icon-chooser is visible, so should not auto-hide the edit-panel that is open behind it... aborting.\",false);");
printf("			return false;");
printf("		}");
printf("	}");
printf("	var intMilliseconds = intSeconds*1000;");
printf("	FavScreen.timeoutHandle_autoEndEditPanel = setTimeout(fnAutoEndEditPanel,intMilliseconds);");		//set the timeout, passing a global handle to it back to the FavScreen class
printf("	FavScreen.log('log',\"handleAutoEndEditPanel_setOrReset(): Finished... FavScreen.timeoutHandle_autoEndEditPanel=\"+FavScreen.timeoutHandle_autoEndEditPanel+\" may auto-end the edit panel in \"+intSeconds+\" seconds.\",true);");
printf("	return FavScreen.timeoutHandle_autoEndEditPanel;");							//return a reference to the global handle that we just created, so it's that much easier to cancel it if needed
printf("}\n");//end function handleAutoEndEditPanel_setOrReset()

printf("function handleAutoEndResponseMode_clear(){");								// Clear/cancel the automatic timeout handle for response-mode
printf("	if(typeof FavScreen.timeoutHandle_autoEndResponseMode!==\"undefined\"){");					//if handle for setTimeout exists, clear and reinitialize it
printf("		FavScreen.log('log',\"handleAutoEndResponseMode_clear(): Starting... FavScreen.timeoutHandle_autoEndResponseMode=\"+FavScreen.timeoutHandle_autoEndResponseMode+\", so clearing and re-initializing it to un-used state.\",false);");
printf("		clearTimeout(FavScreen.timeoutHandle_autoEndResponseMode);");						//clear the setTimeout (cancels it)
printf("		FavScreen.timeoutHandle_autoEndResponseMode = undefined;");							//re-initialize the handle
printf("		FavScreen.log('log',\"handleAutoEndResponseMode_clear(): Finished... FavScreen.timeoutHandle_autoEndResponseMode=\"+FavScreen.timeoutHandle_autoEndResponseMode+\".\",false);");
printf("	}");
printf("}\n");//end function handleAutoEndResponseMode_clear()
printf("function handleAutoEndResponseMode_setOrReset(intSeconds){");						// Set or reset an automatic timeout for an response-mode session (returns a handle to the timeout, so you can cancel it if you want)... if called, will start or restart auto-timeout countdown
printf("	handleAutoEndResponseMode_clear();");									//if handle for setTimeout exists, clear it
printf("	if(FavScreen.get('attrInteractionMode')!=MODE_REPLYING){");						//if we're not in response mode, abort this function return false (leaving a cancelled timer)
printf("		FavScreen.log('log',\"handleAutoEndResponseMode_setOrReset(): Not in response mode, so no need to set auto-timeout for ending response mode... aborting.\",false);");
printf("		return false;");
printf("	}");
printf("	if(typeof FavScreen.MessageReplyDialog===\"object\"){");						//if the response panel is active and visible, we need to leave the response-mode auto timeout cancelled
printf("		if(FavScreen.MessageReplyDialog.isVisible==true){");
printf("			FavScreen.log('log',\"handleAutoEndResponseMode_setOrReset(): The response-panel is visible, so should not auto-end response-mode... aborting.\",false);");
printf("			return false;");
printf("		}");
printf("	}");
printf("	if(FavScreen.node_bodywrapper!==null || FavScreen.node_bodywrapper!==undefined){");			//if the legacy response iframe is active and visible (implied by a saved-aside bodywrapper-node), we need to leave the response-mode auto timeout cancelled
//printf("		if(FavScreen.MessageReplyDialog.isVisible==true){");  //DEV-NOTE: do extra check for explicit iframe in the DOM?
printf("			FavScreen.log('log',\"handleAutoEndResponseMode_setOrReset(): A legacy iframe to resolve a msg (in-reply to a msg) is visible, so should not auto-end response-mode... aborting.\",false);");
printf("			return false;");
//printf("		}");
printf("	}");
printf("	if(typeof intSeconds===\"undefined\"){");								//if no argument was provided, set default timeout, in seconds
printf("		intSeconds = 30;");
printf("		FavScreen.log('log',\"handleAutoEndResponseMode_setOrReset(): No duration specified. Defaulting to \"+intSeconds+\" seconds.\",false);");
printf("	}");
printf("	var fnAutoEndReplyMode = function(){");									//define how to end response-mode / what happens when response-mode ends
printf("		if(typeof FavScreen.MessageReplyDialog===\"object\"){");							//if the response panel is active and visible, we need to leave the response-mode auto timeout cancelled
printf("			if(FavScreen.MessageReplyDialog.isVisible==true){");
printf("				FavScreen.log('log',\"fnAutoEndReplyMode(): The response-panel is visible, so should not auto-end response-mode... aborting.\",false);");
printf("				return false;");
printf("			}");
printf("		}");
printf("		FavScreen.set('attrInteractionMode',MODE_LAUNCHABLE);");
printf("		FavScreen.log('log', \"handleAutoEndResponseMode_setOrReset(): setTimeout automatically returned to launch-mode after \"+intSeconds+\" seconds of inactivity.\", true);");
printf("		};");//end fnAutoEndReplyMode definition
printf("	var intMilliseconds = intSeconds*1000;");
printf("	FavScreen.timeoutHandle_autoEndResponseMode = setTimeout(fnAutoEndReplyMode,intMilliseconds);");		//set the timeout, passing a global handle to it back to the FavScreen class
printf("	FavScreen.log('log',\"handleAutoEndResponseMode_setOrReset(): Finished... FavScreen.timeoutHandle_autoEndResponseMode=\"+FavScreen.timeoutHandle_autoEndResponseMode+\" may auto-end response-mode in \"+intSeconds+\" seconds.\",true);");
printf("	return FavScreen.timeoutHandle_autoEndResponseMode;");							//return a reference to the global handle that we just created, so it's that much easier to cancel it if needed
printf("}\n");//end function handleAutoEndResponseMode_setOrReset()

printf("function handleAutoEndResponsePanel_clear(){");								// Clear/cancel the automatic timeout handle for the response-panel
printf("	if(typeof FavScreen.timeoutHandle_autoEndResponsePanel!==\"undefined\"){");					//if handle for setTimeout exists, clear and reinitialize it
printf("		FavScreen.log('log',\"handleAutoEndResponsePanel_clear(): Starting... FavScreen.timeoutHandle_autoEndReplyPanel=\"+FavScreen.timeoutHandle_autoEndReplyPanel+\", so clearing and re-initializing it to un-used state.\",false);");
printf("		clearTimeout(FavScreen.timeoutHandle_autoEndReplyPanel);");						//clear the setTimeout (cancels it)
printf("		FavScreen.timeoutHandle_autoEndReplyPanel = undefined;");						//re-initialize the handle
printf("		FavScreen.log('log',\"handleAutoEndResponsePanel_clear(): Finished... FavScreen.timeoutHandle_autoEndReplyPanel=\"+FavScreen.timeoutHandle_autoEndReplyPanel+\".\",false);");
printf("	}");
printf("}\n");//end function handleAutoEndResponsePanel_clear()
printf("function handleAutoEndResponsePanel_setOrReset(intSeconds,boolEndNow){");					// Set or reset an automatic timeout for an response-panel session (returns a handle to the timeout, so you can cancel it if you want)... if called, will start or restart auto-timeout countdown
printf("	handleAutoEndResponsePanel_clear();");									//if handle for setTimeout exists, clear it
printf("	if(typeof intSeconds===\"undefined\"){");								//if no argument was provided, set default timeout, in seconds
printf("		intSeconds = 30;");
printf("		FavScreen.log('log',\"handleAutoEndResponsePanel_setOrReset(): No duration specified. Defaulting to \"+intSeconds+\" seconds.\",false);");
printf("	}");
printf("	var fnAutoEndReplyPanel = function(){");								//define how to hide response-panel / what happens when response-panel hides
printf("		var node_modalMask = document.getElementsByClassName(\"yui3-widget-mask\")[0];");			//get a reference to the modal mask (which, of course, is provided whenever a YUI-Panel reders)
printf("		var headerwrapperHeight = document.getElementById(\"headerwrapper\").offsetHeight;");			//get the calculated height of the headerwrapper area (including padding, etc.)
printf("		try {");
printf("			if(FavScreen.MessageReplyDialog.isVisible) {");
printf("				doJump = true;");
printf("			}else{");
printf("				doJump = false;");
printf("			}");
printf("			FavScreen.MessageReplyDialog.hide();");
printf("			if(doJump) {");
//printf("				jumpScrollTo(\"bodywrapperInboxAnchor\");");
printf("				scrollTo_animated(document.body, FavScreen.get('attrPreviousScrollPositionPixelY'), 150);");	//return to the previous scroll position (from where they hit respond on the inbox msg)
printf("			}");
printf("		}");
printf("		catch(err) {");
printf("			FavScreen.log('log',\"handleAutoEndResponsePanel(): fnAutoEndReplyPanel(): There is currently no MessageReplyDialog object instantiated, so no need to run hide method or jump back to inbox.\",false);");
printf("		}");
//printf("		jumpScrollTo(\"bodywrapperInboxAnchor\");");
printf("		node_modalMask.style.top = headerwrapperHeight+\"px\";");						//position the modal mask so that the header area isn't masked
printf("		node_modalMask.style.display = \"block\";");								//re-show the modal mask immediately after the panel hides, so as to prevent accidental clicks/taps if they do it right as it's timing-out (we'll re-hide it with a timeout, next...)
printf("		FavScreen.log('log', \"handleAutoEndResponsePanel_setOrReset(): setTimeout automatically hid response-panel after \"+intSeconds+\" seconds of inactivity.\", true);");
printf("		setTimeout(function(){");										//this timeout will re-hide the modal mask
printf("			var node_modalMask = document.getElementsByClassName(\"yui3-widget-mask\")[0];");		//get a reference to the modal mask (which, of course, is provided whenever a YUI-Panel reders)
printf("			node_modalMask.style.display = \"none\";");							//hide the modal mask
printf("			node_modalMask.style.top = \"0px\";");								//reset the modal mask's original position for masking the entire document
printf("			},500);");
printf("		};");//end fnAutoEndReplyPanel definition
printf("	if(intSeconds == 0) {");
printf("		fnAutoEndReplyPanel();");
printf("		return false;");
printf("	}");
printf("	if(typeof FavScreen.MessageReplyDialog===\"undefined\"){");						//if an response panel isn't instantiated, abort this function return false (leaving a cancelled auto-end timer)
printf("		FavScreen.log('log',\"handleAutoEndResponsePanel_setOrReset(): No response panel instantiated (perhaps user hasn't entered response-mode yet), so no need to set auto-timeout for hiding it... aborting.\",false);");
printf("		return false;");
printf("	}");
printf("	if(FavScreen.MessageReplyDialog.isVisible==false){");							//if an response panel isn't showing, abort this function return false (leaving a cancelled auto-end timer)
printf("		FavScreen.log('log',\"handleAutoEndResponsePanel_setOrReset(): No response panel showing, so no need to set auto-timeout for hiding it... aborting.\",false);");
printf("		return false;");
printf("	}");
printf("	var intMilliseconds = intSeconds*1000;");
printf("	FavScreen.timeoutHandle_autoEndReplyPanel = setTimeout(fnAutoEndReplyPanel,intMilliseconds);");		//set the timeout, passing a global handle to it back to the FavScreen class
printf("	FavScreen.log('log',\"handleAutoEndResponsePanel_setOrReset(): Finished... FavScreen.timeoutHandle_autoEndReplyPanel=\"+FavScreen.timeoutHandle_autoEndReplyPanel+\" may auto-end the response panel in \"+intSeconds+\" seconds.\",true);");
printf("	return FavScreen.timeoutHandle_autoEndReplyPanel;");							//return a reference to the global handle that we just created, so it's that much easier to cancel it if needed
printf("}\n");//end function handleAutoEndResponsePanel_setOrReset()

printf("function sendUpdatedRecordToSMCGI(objDataRecord){");							// Send an updated record to the server to be saved (argument is a data object, e.g. like you'd get from: objRS.item(i).get('data') )
printf("	YUI().use(\"recordset\", \"io\", \"io-base\", function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");								//what should happen when the io txn starts
printf("			FavScreen.log('log', \"sendUpdatedRecordToSMCGI(): YUI-IO: Starting txn to update favorite (recno_fav = \"+objDataRecord.recno_fav+\")... YUI-IO txn ID# will be: \"+ioId+\".\", true);");
printf("			Spinner.show();");
printf("		};");
printf("		var handleSuccess = function(ioId, o){");							//response HTTP status resolves to 2xx
printf("			FavScreen.log('log', \"sendUpdatedRecordToSMCGI(): YUI-IO:   Txn #\"+ioId+\" succeeded. Calling refreshRecordset()...\", true);");
printf("			refreshRecordset(\"%s\", true, false);", CurrentUserPin);
printf("		};");
printf("		var handleFailure = function(ioId, o){");							//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('error', \"sendUpdatedRecordToSMCGI(): YUI-IO:   Txn #\"+ioId+\" failed or timed-out. ResponseText returned by server... (next log entry)\", true);");
printf("			FavScreen.log('error', o.responseText, false);");
printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("		};");
printf("		var handleEnd = function(ioId,o){");
printf("			Spinner.hide();");
printf("			};");
printf("		var cfg ={");											//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");							//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");								//subscribe the above custom failure handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
printf("				'updateFavRecord':'true',");							//smcgi command flag
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP(),");
printf("				'userPin':'%s',", CurrentUserPin);
printf("				'recno_fav':objDataRecord.recno_fav,");
printf("				'position':objDataRecord.position");
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
//printf("			sync:true,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete (DEV-NOTE: this value affects Spinner behavior)
printf("			sync:false,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:10000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("		};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");
printf("	});");//end YUI.use
printf("}\n");//end function sendUpdatedRecordToSMCGI

/* DEV-NOTE: the following will only work once we can get JSON-C library working  in our releases... */
/*
printf("function sendUpdatedRecordsetToSMCGI(objRS){");		// Send an updated recordset~ multiple records in string-encoded JavaScript object-literal notation... e.g. "[{rec1keyA:somevalue,rec1keyB:somevalue,...},{rec2keyA:somevalue,rec2keyB:somevalue,....},...]"
		//DEV-NOTE: do validation
printf("	var objLit_recordset = {};");										//declare a variable that we'll use to construct the pre-JSON, object-literal representation of the recordset
printf("	var json_recordset = \"\";");
printf("	var i = 0;");
printf("	var l = objRS.size();");
printf("	for(i; i<l; i++){");											//for each record in the recordset...
printf("		objLit_recordset[i] = objRS.get('records')[i].get('data');");
printf("	}");
printf("	if(typeof JSON===\"undefined\"){");									//check whether the client supports the method we need
printf("		FavScreen.log('error', \"sendUPdatedRecordsetToSMCGI(): Client does not support JSON methods.\", true);");
printf("		alert(\"Your software (browser) is too old. Operation to save multiple records at once is not supported.\");");
printf("		return false;");
printf("	}else{");
printf("		json_recordset = JSON.stringify(objLit_recordset);");					//convert the recordset data into a JSON string (smcgi will need to parse this and save each record)
printf("	}");
printf("	YUI().use(\"io\", \"io-base\", function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("			Y.log(\"Starting transaction to update favorite recordset... YUI-IO transaction ID# will be: \"+ioId+\".\", \"log\", \"sendUpdatedRecordsetToSMCGI(): YUI-IO\");");
printf("			};");
printf("		var handleSuccess = function(ioId, o){");							//response HTTP status resolves to 2xx
printf("			Y.log(\"  Txn #\"+ioId+\" succeeded. Calling refreshRecordset()...\", \"log\", \"sendUpdatedRecordsetToSMCGI(): YUI-IO\");");
printf("			Spinner.hide();");
printf("			refreshRecordset(\"%s\", true);", CurrentUserPin);
printf("			};");
printf("		var handleFailure = function(ioId, o){");							//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			Spinner.hide();");
printf("			Y.log(\"  Txn #\"+ioId+\" failed or timed-out (view 'log' console log for details).\", \"error\", \"sendUpdatedRecordsetToSMCGI(): YUI-IO\");");
printf("			Y.log(\"  Txn #\"+ioId+\"'s responseText returned by server = '\"+o.responseText+\"'\", \"log\", \"sendUpdatedRecordsetToSMCGI(): YUI-IO\");");
printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("			};");
printf("		var cfg ={");											//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure");							//subscribe the above custom failure handler to IO's global failure event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
printf("				'updateFavRecordset':'true',");							//smcgi command flag
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				'disableCheckForIP_favorites':'%d',", TRUE);
printf("				'userPin':'%s',", CurrentUserPin);
printf("				'recordset':json_recordset");							//JSON-encoded recordset data
printf("				},");
printf("			headers:{");
//printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				'Content-Type':'application/json; charset=utf-8'");
printf("				},");
//printf("			sync:true,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete (DEV-NOTE: this value breaks Spinner and is slow)
printf("			sync:false,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete (DEV-NOTE: this value allows Spinner and is fast)
printf("			timeout:5000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("			};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");
printf("		});");//end YUI.use
printf("}\n");
*/

printf("function saveSortedFavRecnosToSMCGI(objRS,boolSync){");							// Instruct SMCGI to reorder sorted favorite-message records according to what's in the specified recordset
		//DEV-NOTE: build argument-validation
printf("	boolSync = Boolean(boolSync);");									//defaults to false, if none provided
printf("	YUI().use(\"io\", \"io-base\", function(Y){");
printf("		var strRecnos = rs_getEncodedStringOf(objRS, \"recno_fav\", \",\");");				//get an encoded string of fav-recnos, delineated by commas
printf("		var strPositions = rs_getEncodedStringOf(objRS, \"position\", \";\");");			//get an encoded string of position values, delineated by semicolons
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");								//what should happen when the io txn starts
printf("			FavScreen.log('log', \"saveSortedFavRecnosToSMCGI(): YUI-IO: Starting txn to update favorite recordset... YUI-IO txn ID# will be: \"+ioId+\".\", true);");
printf("			Spinner.show();");
printf("			};");
printf("		var handleSuccess = function(ioId, o){");							//response HTTP status resolves to 2xx
printf("			FavScreen.log('log', \"saveSortedFavRecnosToSMCGI(): YUI-IO:   Txn #\"+ioId+\" succeeded. (Server response next log entry). Calling refreshRecordset()...\", true);");
printf("			FavScreen.log('verbose', o.responseText, false);");
printf("			refreshRecordset(\"%s\", true, false);", CurrentUserPin);
printf("			FavScreen.rsEdited.empty();");								//the edited recordset should now be saved to the database, so we can now empty it
printf("			ModalNotification_Saved.showFor(1500);");						//show the saved notification for the specified number of milliseconds
printf("			};");
printf("		var handleFailure = function(ioId, o){");							//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('log', \"saveSortedFavRecnosToSMCGI(): YUI-IO:   Txn #\"+ioId+\" failed or timed-out.\", true);");
printf("			FavScreen.log('verbose', \"saveSortedFavRecnosToSMCGI(): YUI-IO:   Txn #\"+ioId+\"'s responseText returned by server = '\"+o.responseText+\"'\", true);");
printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("			};");
printf("		var handleEnd = function(ioId,o){");
printf("			Spinner.hide();");
printf("			};");
printf("		var cfg ={");											//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");							//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");								//subscribe the above custom failure handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
printf("				'reorderSortedFavs':'true',");							//smcgi command flag
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP(),");
printf("				'userPin':'%s',", CurrentUserPin);
printf("				'orderedRecnos':strRecnos,");							//a comma-separated string of favorite record numbers, in the same order as those in the rsEdited recordset (i.e. the order that the user wants)
printf("				'orderedPositions':strPositions");						//a semicolon-separated string of favorite positions, in the same order as those in the rsEdited recordset (i.e. the order that the user wants)
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:boolSync,");
printf("			timeout:10000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("			};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");
printf("		});");//end YUI.use
printf("}\n");//end function saveSortedFavRecnosToSMCGI()

printf("function load_obj_favIconsFromServer(preloadImages){");							// Get a listing (as filenames) of all favorite icons on the server and populate them as an object into the global class (this uses YUI IO to do an HTTP transaction with SMCGI)
printf("	YUI().use(\"io\", \"io-base\", \"querystring-stringify-simple\", function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("			Y.log(\"Starting txn to get available icons... YUI-IO txn ID# will be: \"+ioId+\".\", \"log\", \"load_obj_favIconsFromServer(): YUI-IO\");");
printf("		};");
printf("		var handleSuccess = function(ioId, o){");							//response HTTP status resolves to 2xx
//printf("			if(o.responseText.indexOf(\"smcgi stopped due to signal\" != -1){");			//indexOf method returns -1 if the string was not found, otherwise returns the position of the string's first character
//printf("				Y.log(\"Server response contains 'smcgi stopped due to signal', which means there is a problem in the SMCGI program\", \"error\", \"YUI: IO: Get icon listing\");");
//printf("				return -1;");									//get out of this function(handleSuccess)
//printf("			}");//end if
printf("			FavScreen.favIconList = eval(o.responseText);");					//parse the responseText (a string which represents an object literal) into an object-literal  DEV-NOTE: eval might be the best (only?) way to do this... alternative is to send as JSON Mime Type? NOTE: cannot use o.response with IE, must use responseText
printf("			Y.log(\"  Txn #\"+ioId+\" succeeded. \"+FavScreen.favIconList.length+\" icons retrieved.\", \"log\", \"load_obj_favIconsFromServer(): YUI-IO\");");
printf("			if(preloadImages==true){");								//pre-loading icons allows us to load them in the background, so (hopefully) they're ready to be used when needed  --remember to render them from this array, to get the benefit
printf("				Y.log(\"  Pre-loading icons...\", \"log\", \"load_obj_favIconsFromServer(): YUI-IO\");");
printf("				FavScreen.favIconLoadedImages = new Array();");					//prepare an array for storing images
printf("				for(var i=0; i<FavScreen.favIconList.length; i++){");				//for each possible icon, load it... note: length is 1-based, but arrays in JS are 0-based, so using "<" operator here instead of "<="
printf("					FavScreen.favIconLoadedImages[i] = new Image();");			//create a new image object in this array element
printf("					FavScreen.favIconLoadedImages[i].src = \"%s/icons/32x32/\"+FavScreen.favIconList[i].fn+\"\";", cgi_icons);//load the image into this element (again, remember to reference this later when you intend to render the image, to get the benefit of pre-loading)
printf("					FavScreen.favIconLoadedImages[i].id = \"\"+FavScreen.favIconList[i].fn+\"\";");//load the image name into this element's ID attribute
printf("				}");
printf("				Y.log(\"  Done pre-loading icons (it may still take a while for them to come across the wire, though).\", \"log\", \"load_obj_favIconsFromServer(): YUI-IO\");");
printf("			}");
printf("		};");
printf("		var handleFailure = function(ioId, o){");							//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			Y.log(\"  Txn #\"+ioId+\" failed or timed-out (view 'log' console log for details).\", \"error\", \"load_obj_favIconsFromServer(): YUI-IO\");");
printf("			Y.log(\"  Txn #\"+ioId+\"'s responseText returned by server = '\"+o.responseText+\"'\", \"log\", \"load_obj_favIconsFromServer(): YUI-IO\");");
printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("			return false;");
printf("		};");
printf("		var cfg ={");											//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure");							//subscribe the above custom failure handler to IO's global failure event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
printf("				'getFavIcons':'true',");							//smcgi command flag
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP()");
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:false,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:20000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("		};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");								//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("	});");
printf("}\n");//end function load_obj_favIconsFromServer()
printf("function createNode_favIconList(){");									// Return a DOM node (HTML) containing all of the icons as they should be displayed
printf("	if(typeof FavScreen.favIconList===\"undefined\"){");							//check whether our icon list exists
printf("		FavScreen.log('error', \"createNode_favIconList(): The object 'FavScreen.favIconList' is currently undefined. Aborting function.\", true);");
printf("		return false;");
printf("	}");
printf("	var node_div_iconsWrapper = document.createElement('div');");						//setup a wrapper node to go inside the panel's body... it will contain all of the icons
printf("	node_div_iconsWrapper.style.height = \"100%%\";");							//make the wrapper as high as the panel's 'body' area ('body' is typically defined as Y.WidgetStdMod.BODY), so it needs to be set to a specific height for this percentage to work
printf("	node_div_iconsWrapper.style.maxheight = \"100%%\";");							//just extra assurance that we don't take more space than what's available in the panel
printf("	node_div_iconsWrapper.style.overflowY = \"auto\";");							//provide a vertical scrollbar, if needed
printf("	if(typeof FavScreen.favIconLoadedImages===\"undefined\"){var preloaded=false;}");			//set a local variable here (or in the else), before the loop, so we don't hammer the CPU analyzing whether this is defined or not, in each iteration
printf("	else{var preloaded = true;}");
printf("	for(var i=0; i<FavScreen.favIconList.length; i++){");							//setup a node for each icon in the list and put it inside the wrapper node that we just created
printf("		var node_img_icon = document.createElement('img');");						//create an img node object
printf("		if(preloaded){");										//if it looks like we already have a preloaded-images object...
printf("			node_img_icon = FavScreen.favIconLoadedImages[i];");					//pull over our preloaded image (as a hopefully already loaded/rendered object) from the javascript array
printf("		}else{");											//else no preloaded images seem to exist...
printf("			node_img_icon.src = \"%s/icons/32x32/\"+FavScreen.favIconList[i].fn+\"\";", cgi_icons);//so bring load the image from its source, now (note: this may result in visible loading/rendering)
printf("		}");
printf("		node_img_icon.style.margin = \"6px\";");							//provide some spacing around the icons, to be fat-finger-friendly
printf("		node_img_icon.onclick = function(){");
printf("			if(FavScreen.get('attrInteractionMode')==MODE_EDITABLE){");
printf("				FavScreen.panelEditFav.bodyNode.getById('panelEditFav_icon').getDOMNode().src = \"%s/icons/32x32/\"+this.id+\"\";", cgi_icons);//since we're only loading one icon, this method should be quick enough
printf("				FavScreen.panelEditFav.bodyNode.getById('fld_icon').getDOMNode().value = this.id;");
printf("			}");
printf("			else if(FavScreen.get('attrInteractionMode')==MODE_DELETED){");
printf("				FavScreen.panelUndeleteFav.bodyNode.getById('panelEditFav_icon').getDOMNode().src = \"%s/icons/32x32/\"+this.id+\"\";", cgi_icons);//since we're only loading one icon, this method should be quick enough
printf("				FavScreen.panelUndeleteFav.bodyNode.getById('fld_icon').getDOMNode().value = this.id;");
printf("			}");
printf("			FavScreen.panelIconChooser.hide();");
printf("		};");
printf("		node_div_iconsWrapper.appendChild(node_img_icon);");						//append the IMG node, as a child, to the DIV wrapper
printf("	}");//end for
printf("	return node_div_iconsWrapper;");									//return the DIV wrapper node (and its children)
printf("}\n");//end function createNode_favIconList()
//printf("var load_yuiPanel_iconChooser_maxRetries = 5;");							//used in our redundant coding scheme to try reloading the edit panel/modal on launch if it didn't
printf("function load_yuiPanel_iconChooser(){");								// Instantiate a YUI Panel object that will be used as the dialog for choosing an icon (note: this will only prepare it for use, but not display it)
printf("	YUI().use(\"panel\", \"recordset\", \"io\", \"io-base\", \"querystring-stringify-simple\", function(Y){");
printf("		FavScreen.panelIconChooser = new Y.Panel({");							//instantiate a new panel into our global class, so it can be worked with outside of this scope if necessary
printf("			id		: 'paneliconchooser',");
printf("			headerContent	: 'Choose an Icon',");
printf("			width		: '95%%',");
printf("			zIndex		: 6,");
printf("			centered	: true,");
printf("			modal		: true,");
printf("			visible		: false,");
printf("			render		: true,");
printf("			buttons:[");
printf("				{");
printf("				value	: 'Cancel',");
printf("				section	: Y.WidgetStdMod.FOOTER,");
printf("				action	: function(e){");
printf("					e.preventDefault();");
printf("					this.hide();");								//dev-note: somehow, this causes the panelEditFav panel's modal feature (background masking) to break... it doesn't set the div with class 'yui3-widget-mask' back to what it should be
printf("					FavScreen.panelEditFav.get('maskNode')._node.style.display = \"block\";");//need this to make the original panelEditFav panel modal (background masked)... any explicit value except 'none' seems to work
printf("					FavScreen.panelEditFav.get('maskNode')._node.style.zIndex = \"5\";");	//need this to make the original panelEditFav panel modal (background masked)... zIndex should match that panel's
printf("					}");//end action
printf("				}");//end Cancel button
printf("			]");//end buttons
printf("		});");//end panelIconChooser instantiation
printf("		FavScreen.panelIconChooser.after('visibleChange', function(e){");				//whenever the panel's visibility changes (specifically, right after it changes)
printf("			if(FavScreen.panelIconChooser.get('visible')){");						//if the panel is now visible, then...
printf("				handleAutoEndEditMode_clear();");								//cancel the edit-mode auto timeout (we don't want anything closing while they're still browsing icons)
printf("				handleAutoEndEditPanel_clear();");								//cancel the edit-panel auto timeout (we don't want the edit panel closing while they're still browsing icons)
printf("			}else{");											//else the panel is now hidden, so...
printf("				handleAutoEndEditPanel_setOrReset();");								//restore the edit-panel auto timeout countdown
printf("				handleAutoEndEditMode_setOrReset();");								//restore the edit-mode auto timeout countdown
printf("			}");//end if-else
printf("			});");//end after-visible-change
printf("		FavScreen.panelIconChooser.after('init', function(e){");					//whenever the panel is initialized
printf("			FastClick.attach(document.getElementById('paneliconchooser'));");				//attach the fastclick override to this panel and any of its children (like buttons)
printf("			});");//end after-visible-change
printf("	});");//end YUI.use
printf("	return \"FavScreen.panelIconChooser was commanded to instantiate as YUI Panel\";");
printf("}\n");//end function load_YuiPanel_iconChooser
printf("function showPanel_iconChooser(){");									// It's showtime for the icon chooser panel... do last-minute things and actually show it on-screen
printf("	if(typeof FavScreen.panelIconChooser===\"undefined\"){");						//check whether our panel object exists
printf("		FavScreen.log('error', \"showPanel_iconChooser(): The YUI Panel object 'FavScreen.panelIconChooser' is currently undefined. Aborting function.\", true);");
printf("		return false;");
printf("	}");
printf("	FavScreen.panelIconChooser.setStdModContent('body', createNode_favIconList(), 'replace');");		//note: the strings 'body' and 'replace' are typically defined using WidgetStdMod.BODY and WidgetStdMod.REPLACE, but those weren't brought into scope with our global-assignment method, for some reason
printf("	FavScreen.panelIconChooser.set('height', '90%%');");
printf("	FavScreen.log('log',\"showPanel_iconChooser(): Now calling show() method of FavScreen.panelIconChooser.\",true);");
printf("	FavScreen.panelIconChooser.show();");
printf("}\n");//end function showPanel_iconChooser()
printf("var load_yuiPanel_editFavMsg_maxRetries = 5;\n");							//used in our redundant coding scheme to try reloading the edit panel/modal on launch if it didn't
printf("function load_yuiPanel_editFavMsg(){");									// Instantiate a YUI Panel object that will be used as the dialog for editing favorite messages (note: this will only prepare it for use, but not display it)
printf("	YUI().use(\"panel\", \"recordset\", \"io\", \"io-base\", \"io-form\", function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("			Y.log(\"Starting txn to update %s message... YUI-IO txn ID# will be: \"+ioId+\".\", \"log\", \"load_yuiPanel_editFavMsg(): YUI-IO\");", FAVS_NAME_SINGULAR);
printf("		};");
printf("		var handleSuccess = function(ioId, o){");							//response HTTP status resolves to 2xx
printf("			Y.log(\"  Txn #\"+ioId+\" succeeded.\", \"log\", \"load_yuiPanel_editFavMsg(): YUI-IO\");");
printf("			refreshRecordset(\"%s\", true, false, false, false);", CurrentUserPin);		//refresh the recordset (which, in turn, refreshes the favorites that are rendered on the screen, via event listener)... also 'true' so refresh rsOrig
				//DEV-NOTE: also need to do lib refresh? if so, will that handle attaching? -- maybe not.. saving seems to refresh the lib-msg that was saved, so apparently refreshing
printf("			attachActionListenersToMessageCells_allSubsectionsInSection(\"subsectionlist-libraries\");");
//DEV-NOTE: should probably do refresh here instead?
printf("		};");
printf("		var handleFailure = function(ioId, o){");							//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			Y.log(\"  Txn #\"+ioId+\" failed or timed-out (view 'log' console log for details).\", \"error\", \"load_yuiPanel_editFavMsg(): YUI-IO\");");
printf("			Y.log(\"  Txn #\"+ioId+\"'s responseText returned by server = '\"+o.responseText+\"'\", \"log\", \"load_yuiPanel_editFavMsg(): YUI-IO\");");
printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("		};");
printf("		var cfg ={");											//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure");							//subscribe the above custom failure handler to IO's global failure event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			form:{");
printf("				id:\"form_editFavMsg\"");							//id attribute value of the form to serialize and post name/value pairs out of
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:true,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:10000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("		};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		FavScreen.panelEditFav = new Y.Panel({");
printf("			id		: 'paneleditfav',");
printf("			width		: '90%%',");
printf("			maxWidth	: '90%%',");
printf("			zIndex		: 5,");
printf("			centered	: true,");
printf("			modal		: true,");
printf("			visible		: false,");
printf("			render		: true,");
printf("			buttons:[");
printf("				{");
printf("				value	: 'Delete',");
printf("				section	: Y.WidgetStdMod.FOOTER,");
printf("				classNames:'btndelete',");
//printf("				events	:{click:function(e){confirm('really?');}},");//DEV-NOTE: this method of attaching event listeners works, but needs further development
printf("				action	: function(e){");
printf("					e.preventDefault();");
printf("					Y.log(\"Delete %s message (send position-type-flag update to database) and call refreshRecordset()...\", \"log\", \"FavScreen.panelEditFav\");\n", FAVS_NAME_SINGULAR);
//printf("					this.bodyNode.getById(\"fld_smcgi_command\")._node.name = \"deleteFavRecord\";");//NOTE: this actually physically deletes the record
printf("					this.bodyNode.getById(\"fld_position\").getDOMNode().value = \"%s:00000,00000,00000\";",FAVS_DELETED_FLAG);//set position field value to the delete flag (DEV-NOTE: need to probably just update the flag, rather than also hardcoding the '00000,00000,00000' portion -- use string manipulation somehow)
printf("					objResponse = Y.io(sUrl, cfg);");					//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("					this.hide();");
printf("					refreshRecordset(\"%s\", true, false);", CurrentUserPin);		//refresh the recordset (which, in turn, refreshes the favorites that are rendered on the screen, via event listener)... also 'true' so refresh rsOrig
printf("					}");//end action
printf("				},{");
printf("				value	: 'Save',");
printf("				section	: Y.WidgetStdMod.FOOTER,");
printf("				action	: function(e){");
printf("					e.preventDefault();");
printf("					if(FavScreen.rsEdited.size()>0 && FavScreen.rsEdited!=FavScreen.rsOrig_sorted){");
//printf("						alert(\"Your sort order was also changed.\\nWe'll go ahead and save that now, too.\");");
printf("						saveSortedFavRecnosToSMCGI(FavScreen.rsEdited, true);");	//initiate a synchronous update to save sorted ordering (so it completes before we continue with this save --to prevent a possible race condition)
printf("					}");
printf("					Y.log(\"Saving changes to database and calling refreshRecordset()...\", \"log\", \"FavScreen.panelEditFav\");");
printf("					objResponse = Y.io(sUrl, cfg);");					//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("					this.hide();");								//hide the edit panel
//printf("					refreshRecordset(\"%s\", true, false, false, false);", CurrentUserPin);		//refresh the recordset (which, in turn, refreshes the favorites that are rendered on the screen, via event listener)... also 'true' so refresh rsOrig
						//DEV-NOTE: also need to do lib refresh? if so, will that handle attaching? -- maybe not.. saving seems to refresh the lib-msg that was saved, so apparently refreshing
//printf("					attachActionListenersToMessageCells_allSubsectionsInSection(\"subsectionlist-libraries\");");
printf("					}");//end action
printf("				},{");
printf("				value	: 'Cancel',");
printf("				section	: Y.WidgetStdMod.FOOTER,");
printf("				action	: function(e){");
printf("					e.preventDefault();");
printf("					this.hide();");
printf("					}");//end action
printf("				}");
printf("			]");//end buttons
printf("			});");//end new Panel instantiation
printf("		FavScreen.panelEditFav.after('visibleChange', function(e){");				//whenever the panel's visibility changes (specifically, right after it changes)
printf("			if(FavScreen.panelEditFav.get('visible')){");						//if the panel is now visible, then...
printf("				handleAutoEndEditMode_clear();");							//cancel the edit-mode auto timeout (we don't want edit mode ending while a edit panel is open)
printf("			}else{");										//else the panel is now hidden, so...
printf("				handleAutoEndEditMode_setOrReset();");							//handle restarting the edit-mode auto timeout
printf("				handleAutoEndEditPanel_clear();");							//cancel the edit-panel auto timeout (we don't want any possible later edit panels to auto hide prematurely)
printf("			}");//end if-else
printf("			});");//end after-visible-change
printf("		FavScreen.panelEditFav.after('init', function(e){");					//whenever the panel initializes
printf("			FastClick.attach(document.getElementById('paneleditfav'));");		//attach the fastclick override to this panel and any of its children (like buttons)
printf("			});");//end after-init
printf("	});");//end YUI.use
printf("	return 'FavScreen.panelEditFav was commanded to instantiate as YUI Panel';");
printf("}\n");//end function editFav_loadPanel()
printf("function updateCharCountDisplay(domNodeToUpdate, intChars, intMaxChars){");
printf("	if(typeof domNodeToUpdate===\"undefined\" || domNodeToUpdate==\"null\" || typeof intChars===\"undefined\" || typeof intMaxChars===\"undefined\"){");
printf("		FavScreen.log('warn', \"Invalid argument(s) given to updateCharCountDisplay(). Character count won't be displayed.\", true);");
printf("	}");
printf("	else{");
printf("		domNodeToUpdate.innerHTML = \"(\"+intChars+\"/\"+intMaxChars+\")\";");
printf("		if(intChars >= intMaxChars){");
printf("			if(typeof domNodeToUpdate.classList==\"object\"){domNodeToUpdate.classList.add(\"warn\");}");	//if browser supports classList, then use it to add the 'warn' class
printf("		}");
printf("		else{");
printf("			if(typeof domNodeToUpdate.classList==\"object\"){domNodeToUpdate.classList.remove(\"warn\");}");	//if browser supports classList, then use it to remove the 'warn'class
printf("		}");
printf("	}");
printf("}\n");//end function updateCharCountDisplay()
printf("function editFav_popPanel(favRecno,e,t){");
printf("	if(FavScreen.get(\"attrInteractionMode\")!=MODE_EDITABLE){");					//if we're not in edit mode, this shouldn't be allowed to happen, so abort this function
printf("		FavScreen.log('warn', \"FavScreen attrInteractionMode is currently not MODE_EDITABLE. Aborting editFav_popPanel() operation.\", true);");
printf("		return false;");
printf("	}");//end if
printf("	if(typeof t.getX === \"function\") {");								//if YUI-Node method exists, use the YUI methods to get the data we need...
printf("		var msgCell_leftX = parseInt(t.getX() || t.getBoundingClientRect().left);");			//get the messagecell's left-most position along the X axis
printf("		var msgCell_topY = parseInt(t.getY() || t.getBoundingClientRec().top);");			//get the messagecell's top-most position along the Y axis
printf("		var msgCell_width = parseInt(t.getComputedStyle('width'));");					//get the messagecell's computed width
printf("		var msgCell_height = parseInt(t.getComputedStyle('height'));");					//get the messagecell's computed height
printf("		var msgCell_paddingTop = parseInt(t.getComputedStyle('padding-top'));");			//get the messagecell's computed padding-top
printf("		var msgCell_paddingBottom = parseInt(t.getComputedStyle('padding-bottom'));");			//get the messagecell's computed padding-bottom
printf("		var evtX = e.pageX;");										//get the X coordinate of the mouse click
printf("		var evtY = e.pageY;");										//get the Y coordinate of the mouse click
printf("	} else {");											//else use native JavaScript...
printf("		var msgCell_leftX = parseInt(t.getBoundingClientRect().left);");				//get the messagecell's left-most position along the X axis
printf("		var msgCell_topY = parseInt(t.getBoundingClientRect().top);");					//get the messagecell's top-most position along the Y axis
printf("		var msgCell_width = parseInt(t.getBoundingClientRect().width);");				//get the messagecell's computed width
printf("		var msgCell_height = parseInt(t.getBoundingClientRect().height);");				//get the messagecell's computed height
printf("		var msgCell_paddingTop = parseInt(window.getComputedStyle(t,null).getPropertyValue('padding-top'));");//get the messagecell's computed padding-top
printf("		var msgCell_paddingBottom = parseInt(window.getComputedStyle(t,null).getPropertyValue('padding-bottom'));");//get the messagecell's computed padding-bottom
printf("		var evtX = e.x;");										//get the X coordinate of the mouse click
printf("		var evtY = e.y;");										//get the Y coordinate of the mouse click
printf("	}");
printf("	var msgCell_rightX = msgCell_leftX + msgCell_width;");						//get the messagecell's right-most position along the X axis
printf("	var msgCell_bottomY = msgCell_topY + msgCell_height;");						//get the messagecell's bottom-most position along the Y axis
printf("	var msgCell_clickArea_minX = msgCell_leftX + 40;");						//calculate the left-most position along the X axis for the allowable click-to-edit area
printf("	var msgCell_clickArea_maxX = msgCell_rightX - 45;");						//calculate the right-most position along the X axis for the allowable click-to-edit area
printf("	var msgCell_clickArea_minY = msgCell_topY;");							//calculate the top-most position along the Y axis for the allowable click-to-edit area
printf("	var msgCell_clickArea_maxY = msgCell_bottomY + msgCell_paddingTop + msgCell_paddingBottom;");	//calculate the bottom-most position along the Y axis for the allowable click-to-edit area
printf("	if( (evtX>=msgCell_clickArea_minX && evtX<=msgCell_clickArea_maxX) ");				//if the click event happened within the bounds of our calculated allowable area, then allow this function to continue...
printf("	 && (evtY>msgCell_clickArea_minY && evtY<msgCell_clickArea_maxY) ){");
printf("		FavScreen.log('log', \"editFav_popPanel(): Click-to-edit occurred inside allowable area. Proceeding to pop the panel.\", true);");
printf("	}else{");											//else, the click happened outside of the allowable area, so abort the function...
printf("		FavScreen.log('info', \"editFav_popPanel(): Click-to-edit occurred outside of allowable area. Aborting.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof FavScreen.panelEditFav===\"undefined\"){");						//if the panel we want to show isn't loaded (created) yet, then try to load it a few times
printf("		if(load_yuiPanel_editFavMsg_maxRetries>0){");
printf("			FavScreen.log('warn', \"Could not execute editFav_popPanel() because FavScreen.panelEditFav is undefined. Attempting to load now...\", true);");
printf("			editFav_loadPanel();");
printf("			load_yuiPanel_editFavMsg_maxRetries--;");
printf("			setTimeout(\"editFav_popPanel()\", 250);");						//recurse with a delay to hopefully give YUI Panel enough time to instantiate
printf("			return false;");
printf("		}");//end if
printf("		else{");
printf("			FavScreen.log('error', \"Failed to execute editFav_popPanel() because FavScreen.panelEditFav could not be defined. Aborting editFav_popPanel() operation.\", true);");
printf("			return false;");
printf("		}");//end else
printf("	}");//end if
printf("	if(typeof favRecno===\"undefined\" || isNaN(favRecno)){");						//validate arguments before continuing (favRecno must be valid, because SMCGI ultimately uses that to perform an update operation, should the user happen to save anything)
printf("		FavScreen.log('error', \"Failed to execute editFav_popPanel() because of invalid argument (\"+favRecno+\"). Aborting editFav_popPanel() operation.\", true);");
printf("		return false;");
printf("	}");//end if
printf("	var favName=rsRec_getFavName(FavScreen.rsOrig,favRecno);");
printf("	var favDesc=rsRec_getFavDescription(FavScreen.rsOrig,favRecno);");
printf("	var favIcon=rsRec_getFavIcon(FavScreen.rsOrig,favRecno);");
printf("	var msgTempRecno=rsRec_getMsgTemplateRecno(FavScreen.rsOrig,favRecno);");				//get the message template recno
printf("	var msgTempName=rsRec_getMsgTemplateName(FavScreen.rsOrig,favRecno);");					//get the message template name string
printf("	var msgTempDir=rsRec_getMsgTemplateDir(FavScreen.rsOrig,favRecno);");					//get the message template directory string
printf("	var msgTempDesc=rsRec_getMsgTemplateDesc(FavScreen.rsOrig,favRecno);");
printf("	var confirmSend=rsRec_getConfirmSend(FavScreen.rsOrig,favRecno);");
printf("	var fldCheckedAttr_phone=fldCheckedAttr_tablet=fldCheckedAttr_pc = '';");
printf("	switch(confirmSend){");
printf("		case %d:", FAVS_CONFIRMSEND_PHONE);
printf("			fldCheckedAttr_phone = 'checked=\"true\"';");
printf("			break;");
printf("		case %d:", FAVS_CONFIRMSEND_TABLET);
printf("			fldCheckedAttr_tablet = 'checked=\"true\"';");
printf("			break;");
printf("		case %d:", FAVS_CONFIRMSEND_PHONETABLET);
printf("			fldCheckedAttr_phone = 'checked=\"true\"';");
printf("			fldCheckedAttr_tablet = 'checked=\"true\"';");
printf("			break;");
printf("		case %d:", FAVS_CONFIRMSEND_PC);
printf("			fldCheckedAttr_pc = 'checked=\"true\"';");
printf("			break;");
printf("		case %d:", FAVS_CONFIRMSEND_PHONEPC);
printf("			fldCheckedAttr_phone = 'checked=\"true\"';");
printf("			fldCheckedAttr_pc = 'checked=\"true\"';");
printf("			break;");
printf("		case %d:", FAVS_CONFIRMSEND_TABLETPC);
printf("			fldCheckedAttr_tablet = 'checked=\"true\"';");
printf("			fldCheckedAttr_pc = 'checked=\"true\"';");
printf("			break;");
printf("		case %d:", FAVS_CONFIRMSEND_ALL);
printf("			fldCheckedAttr_phone = 'checked=\"true\"';");
printf("			fldCheckedAttr_tablet = 'checked=\"true\"';");
printf("			fldCheckedAttr_pc = 'checked=\"true\"';");
printf("			break;");
printf("		default:");
printf("			FavScreen.log('info', \"editFav_popPanel(): confirmSend value unknown or does not exist. Not checking any boxes for favRecno \"+favRecno+\".\", false);");
printf("			break;");
printf("	}");
printf("	var fldValue_favName = \"\";");										//initialize a variable that will be used to populate the form input field
printf("	if(favName.length>0){");										//if there is a favorite-msg name, use it to pre-populate the field for the user
printf("		fldValue_favName = favName;");
printf("	}");
printf("	else if(msgTempName.length>0){");									//else if there is a msg-template name, use it to pre-populate the field for the user
printf("		fldValue_favName = msgTempName;");
printf("	}");
printf("	var fldValue_favDesc = \"\";");										//initialize a variable that will be used to populate the form input field
printf("	if(favDesc.length>0){");										//if there is a favorite-msg description, use it to pre-populate the field for the user
printf("		fldValue_favDesc = favDesc;");
printf("	}");
//printf("	else if(msgTempDesc.length>0){");									//else if there is a msg-template description, use it to pre-populate the field for the user
//printf("		fldValue_favDesc = msgTempDesc;");
//printf("	}");
printf("	FavScreen.panelEditFav.set(\"headerContent\", \"<span style='font-weight:bold'>Edit %s</span>\");", FAVS_NAME_SINGULAR);
printf("	var s='<form id=\"form_editFavMsg\">';");
printf("	s+='<input type=\"hidden\" id=\"fld_smcgi_command\" name=\"updateFavRecord\" value=\"true\">';");						//smcgi command flag
printf("	s+='<input type=\"hidden\" name=\"%s\" value=\"%s\">';", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));			//smcgi authentication token
printf("	s+='<input type=\"hidden\" name=\"disableCheckForIP_favorites\" value=\"'+determineShouldIgnoreChangeInIP()+'\">';");
printf("	s+='<input type=\"hidden\" name=\"userPin\" value=\"%s\">';", CurrentUserPin);								//user pin
printf("	s+='<input type=\"hidden\" name=\"recno_fav\" value=\"'+favRecno+'\">';");								//favorite's recno
printf("	s+='<input type=\"hidden\" id=\"fld_position\" name=\"position\" value=\"'+rsRec_getFavPosition(FavScreen.rsOrig, favRecno)+'\">';");	//shouldn't be changing from here, but send it to smcgi anyway, so we can just reuse the logic there that also updates fav records from other places (which might include position)
printf("	s+='<div id=\"favmsgwrapper\">';");
printf("	s+='<table>';");
printf("	s+='<tr>';");
printf("	s+='<td class=\"fieldlabel\">';");
printf("	s+='	<img style=\"vertical-align:middle;\" id=\"panelEditFav_icon\" src=\"%s/icons/32x32/'+favIcon+'\"  onclick=\"javascript:showPanel_iconChooser();return false;\">';", cgi_icons);
printf("	s+='	</td>';");
printf("	s+='<td class=\"field\">';");
printf("	s+='	<input type=\"hidden\" id=\"fld_icon\" name=\"fld_icon\" value=\"'+favIcon+'\">';");
//printf("	s+='	<img style=\"vertical-align:middle; margin-right:1em;\" id=\"panelEditFav_icon\" src=\"%s/icons/32x32/'+favIcon+'\">';", cgi_icons);
printf("	s+='	<button type=\"button\" class=\"yui3-button\" onclick=\"javascript:showPanel_iconChooser();return false;\">Choose New Icon</button>';");	//note: type=button and return false -- to be safe and not have the form submit to smcgi by mistake
printf("	s+='	</td>';");
printf("	s+='</tr>';");
printf("	s+='<tr>';");
printf("	s+='<td class=\"fieldlabel\">Name</td>';");
printf("	s+='<td class=\"field\"><input type=\"text\" name=\"label1\" id=\"label1\" value=\"'+fldValue_favName+'\" maxlength=\"%d\"></input><span class=\"charcountdisplay\" id=\"charcountdisplay-favname\"></span></td>';", FAVS_FAVNAME_MAXLENGTH);
printf("	s+='</tr>';");
printf("	s+='<tr>';");
printf("	s+='<td class=\"fieldlabel\">Desc.</td>';");
printf("	s+='<td class=\"field\"><textarea name=\"label2\" id=\"label2\" maxlength=\"%d\">'+fldValue_favDesc+'</textarea><span class=\"charcountdisplay\" id=\"charcountdisplay-favdesc\"></span></td>';", MSGLINE_LENGTH-1);
printf("	s+='</tr>';");
printf("	s+='<tr>';");
printf("	s+='<td class=\"fieldlabel\" colspan=\"2\" style=\"text-align:left\">Confirm Msg Send &amp; Close On:</td>';");
printf("	s+='</tr>';");
printf("	s+='<tr>';");
printf("	s+='<td class=\"fieldlabel\">&nbsp;</td>';");	//DEV-NOTE: consider help icon/explanation here?
printf("	s+='<td class=\"field\">';");
printf("	s+='<label><input type=\"checkbox\" id=\"checkboxConfirmSend_phone\" name=\"confirmSend_phone\" value=\"%d\" class=\"checkbox\" '+fldCheckedAttr_phone+'></input>Phone</label>';", TRUE);
printf("	s+='<label><input type=\"checkbox\" id=\"checkboxConfirmSend_tablet\" name=\"confirmSend_tablet\" value=\"%d\" class=\"checkbox\" '+fldCheckedAttr_tablet+'></input>Tablet</label>';", TRUE);
printf("	s+='<label><input type=\"checkbox\" id=\"checkboxConfirmSend_pc\" name=\"confirmSend_pc\" value=\"%d\" class=\"checkbox\" '+fldCheckedAttr_pc+'></input>PC</label>';", TRUE);
printf("	s+='</td>';");
printf("	s+='</tr>';");
printf("	s+='</table>';");
printf("	s+='</div>';");
printf("	s+='<div id=\"msgtemplateinfo\" class=\"roundedcorners\">';");
printf("	s+='<table>';");
printf("	s+='<tr><td class=\"headercell roundedtopcorners6\" colspan=\"2\">MESSAGE TEMPLATE INFORMATION</td></tr>';");
printf("	s+='<tr><td class=\"fieldlabel\">DIRECTORY:</td><td id=\"msgtemplatedir\" class=\"fieldvalue\" data-msgtemprecno=\"'+msgTempRecno+'\" data-msgtempname=\"'+msgTempName+'\" data-msgtempdir=\"'+msgTempDir+'\"><a>'+msgTempDir+'</a></td></tr>';");
printf("	s+='<tr><td class=\"fieldlabel\">MSG NAME:</td><td id=\"msgtemplatename\" class=\"fieldvalue\" data-msgtemprecno=\"'+msgTempRecno+'\" data-msgtempname=\"'+msgTempName+'\" data-msgtempdir=\"'+msgTempDir+'\"><a>'+msgTempName+'</a></td></tr>';");
printf("	s+='<tr><td class=\"fieldlabel roundedblcorner6\">DESCRIPTION:</td><td class=\"fieldvalue\">'+msgTempDesc+'</td></tr>';");
printf("	s+='</table>';");
printf("	s+='</div>';");
//DEV-NOTE: grab the current ZX record's info (in case message has updated since it was originally favorited)???
//printf("	s+='<div id=\"msgtemplateinfo\" class=\"roundedcorners\">';");
//printf("	s+='<div class=\"title\">Current Message Information...</div>';");
//printf("	s+='<table>';");
//printf("	s+='<tr><td class=\"fieldlabel\">Current Name:</td><td>'+msgTempName+'</td></tr>';");
//printf("	s+='<tr><td class=\"fieldlabel\">Current Directory:</td><td>'+msgTempDir+'</td></tr>';");
//printf("	s+='<tr><td class=\"fieldlabel\">Current Description:</td><td>'+msgTempDesc+'</td></tr>';");
//printf("	s+='</table>';");
//printf("	s+='</div>';");
printf("	s+='</form>';");
printf("	FavScreen.panelEditFav.set(\"bodyContent\", s);");
printf("	document.getElementById('label1').oninput = function(){updateCharCountDisplay(document.getElementById('charcountdisplay-favname'), this.value.length, %d);};", FAVS_FAVNAME_MAXLENGTH);
printf("	document.getElementById('label2').oninput = function(){updateCharCountDisplay(document.getElementById('charcountdisplay-favdesc'), this.value.length, %d);};", MSGLINE_LENGTH-1);
if(isLoadedInMobileApp())
	{
	/* no mobile support for msg-template interaction YET, but will ultimately pop a window on their computer via PC-Alert... so no need yet to attach an event listener at this time */
	}
else
	{
	printf("var node_msgtemplatedir = document.getElementById('msgtemplatedir');");			//get reference to the message-template directory node
	printf("var node_msgtemplatename = document.getElementById('msgtemplatename');");		//get reference to the message-template node
	//printf("node_msgtemplatedir.addEventListener('click',popupNewWindowForSMCGI_viewMsgDir);");	//this method will result in a click event passing along the event payload to the callback function (which it requires)
	printf("node_msgtemplatedir.onclick = popupNewWindowForSMCGI_viewMsgDir;");			//this method will result in a click event passing along the event payload to the callback function (which it requires)
	//printf("node_msgtemplatename.addEventListener('click',popupNewWindowForSMCGI_viewMsgDef);");	//this method will result in a click event passing along the event payload to the callback function (which it requires)
	printf("node_msgtemplatename.onclick = popupNewWindowForSMCGI_viewMsgDef;");			//this method will result in a click event passing along the event payload to the callback function (which it requires)
	printf("node_msgtemplatedir.childNodes[0].title=\"Open message directory in new window\";");	//set a helpful mouse-over hover text tooltip popup
	printf("node_msgtemplatename.childNodes[0].title=\"Open message template in new window\";");	//set a helpful mouse-over hover text tooltip popup
	}
printf("	FavScreen.panelEditFav.show();");
printf("	handleAutoEndEditPanel_setOrReset();");
printf("}\n");//end function editFav_popPanel()
printf("function load_yuiPanel_undelete(){");									// Instantiate a YUI Panel object that will be used as the dialog for restoring/undeleting deleted favorite messages (note: this will only prepare it for use, but not display it)
printf("	YUI().use(\"panel\", \"recordset\", \"io\", \"io-base\", \"io-form\", function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("			Y.log(\"Starting txn to update %s... YUI-IO txn ID# will be: \"+ioId+\".\", \"log\", \"YUI-IO: Undelete %s\");", FAVS_NAME_SINGULAR, FAVS_NAME_SINGULAR);
printf("		};");
printf("		var handleSuccess = function(ioId, o){");							//response HTTP status resolves to 2xx
printf("			Y.log(\"  Txn #\"+ioId+\" succeeded.\", \"log\", \"YUI: IO: Undelete %s\");", FAVS_NAME_SINGULAR);
printf("		};");
printf("		var handleFailure = function(ioId, o){");							//response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			Y.log(\"  Txn #\"+ioId+\" failed or timed-out (view 'log' console log for details).\", \"error\", \"YUI: IO: Undelete %s\");", FAVS_NAME_SINGULAR);
printf("			Y.log(\"  Txn #\"+ioId+\"'s responseText returned by server = '\"+o.responseText+\"'\", \"log\", \"YUI: IO: Undelete %s\");", FAVS_NAME_SINGULAR);
printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("		};");
printf("		var cfg ={");											//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure");							//subscribe the above custom failure handler to IO's global failure event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			form:{");
printf("				id:\"form_undeleteFavMsg\"");							//id attribute value of the form to serialize and post name/value pairs out of
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:true,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:10000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("		};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		FavScreen.panelUndeleteFav = new Y.Panel({");
printf("			width		: '90%%',");
printf("			maxWidth	: '90%%',");
printf("			zIndex		: 5,");
printf("			centered	: true,");
printf("			modal		: true,");
printf("			visible		: false,");
printf("			render		: true,");
printf("			buttons:[");
printf("				{");
printf("				value	: 'Undelete / Restore',");
printf("				section	: Y.WidgetStdMod.FOOTER,");
printf("				action	: function(e){");
printf("					e.preventDefault();");
printf("					Y.log(\"save changes to server database.\", \"log\", \"YUI: FavScreen.panelUndeleteFav\");");
printf("					objResponse = Y.io(sUrl, cfg);");					//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("					this.hide();");								//hide the edit panel
printf("					refreshRecordset(\"%s\", true);", CurrentUserPin);			//refresh the recordset (which, in turn, refreshes the favorites that are rendered on the screen, via event listener)... also 'true' so refresh rsOrig
printf("					}");//end action
printf("				},{");
printf("				value	: 'Cancel',");
printf("				section	: Y.WidgetStdMod.FOOTER,");
printf("				action	: function(e){");
printf("					e.preventDefault();");
printf("					this.hide();");
printf("					}");//end action
printf("				}");
printf("			]");//end buttons
printf("		});");//end new Panel instantiation
printf("	});");//end YUI.use
printf("	return 'FavScreen.panelUndeleteFav was commanded to instantiate as YUI Panel';");
printf("}\n");//end function load_yuiPanel_undelete()
printf("var load_yuiPanel_undeleteFavMsg_maxRetries = 5;");
printf("function undeleteFav_popPanel(favRecno){");
printf("	FavScreen.log('log', \"undeleteFav_popPanel()\", true);");
printf("	if(FavScreen.get(\"attrInteractionMode\") != MODE_DELETED){");						//if we're not in deleted-fav mode, this shouldn't be allowed to happen, so abort this function
printf("		FavScreen.log('warn', \"FavScreen attrInteractionMode is currently not MODE_DELETED. Aborting undeleteFav_popPanel() operation.\", true);");
printf("		return false;");
printf("	}");//end if
printf("	if(typeof FavScreen.panelUndeleteFav===\"undefined\"){");						//if the panel we want to show isn't loaded (created) yet, then try to load it a few times
printf("		if(load_yuiPanel_undeleteFavMsg_maxRetries>0){");
printf("			FavScreen.log('warn', \"Could not execute undeleteFav_popPanel() because FavScreen.panelUndeleteFav is undefined. Attempting to load now...\", true);");
printf("			undeleteFav_loadPanel();");
printf("			load_yuiPanel_undeleteFavMsg_maxRetries--;");
printf("			setTimeout(\"undeleteFav_popPanel()\", 250);");						//recurse with a delay to hopefully give YUI Panel enough time to instantiate
printf("			return false;");
printf("		}");//end if
printf("		else{");
printf("			FavScreen.log('error', \"Failed to execute undeleteFav_popPanel() because FavScreen.panelUndeleteFav could not be defined. Aborting undeleteFav_popPanel() operation.\", true);");
printf("			return false;");
printf("		}");//end else
printf("	}");//end if
printf("	if(typeof favRecno===\"undefined\" || isNaN(favRecno) ){");						//validate arguments before continuing (favRecno must be valid, because SMCGI ultimately uses that to perform an update operation, should the user happen to save anything)
printf("		FavScreen.log('error', \"Failed to execute undeleteFav_popPanel() because of invalid argument (\"+favRecno+\"). Aborting undeleteFav_popPanel() operation.\", true);");
printf("		return false;");
printf("	}");//end if
printf("	var favName	= rsRec_getFavName(FavScreen.rsOrig, favRecno);");
printf("	var favDesc	= rsRec_getFavDescription(FavScreen.rsOrig, favRecno);");
printf("	var favIcon	= rsRec_getFavIcon(FavScreen.rsOrig, favRecno);");
printf("	var msgTempName	= rsRec_getMsgTemplateName(FavScreen.rsOrig, favRecno);");
printf("	var msgTempDir	= rsRec_getMsgTemplateDir(FavScreen.rsOrig, favRecno);");
printf("	var msgTempDesc	= rsRec_getMsgTemplateDesc(FavScreen.rsOrig, favRecno);");
printf("	var fldValue_favName = \"\";");										//initialize a variable that will be used to populate the form input field
printf("	if(favName.length>0){");										//if there is a favorite-msg name, use it to pre-populate the field for the user
printf("		fldValue_favName = favName;");
printf("	}");
printf("	else if(msgTempName.length>0){");									//else if there is a msg-template name, use it to pre-populate the field for the user
printf("		fldValue_favName = msgTempName;");
printf("	}");
printf("	var fldValue_favDesc = \"\";");										//initialize a variable that will be used to populate the form input field
printf("	if(favDesc.length>0){");										//if there is a favorite-msg description, use it to pre-populate the field for the user
printf("		fldValue_favDesc = favDesc;");
printf("	}");
//printf("	else if(msgTempDesc.length>0){");									//else if there is a msg-template description, use it to pre-populate the field for the user
//printf("		fldValue_favDesc = msgTempDesc;");
//printf("	}");
printf("	FavScreen.panelUndeleteFav.set(\"headerContent\", \"<span style='font-weight:bold'>Restore a Deleted %s</span>\");", FAVS_NAME_SINGULAR);
printf("	var s = '<form id=\"form_undeleteFavMsg\">';");
printf("	s+='<input type=\"hidden\" id=\"fld_smcgi_command\" name=\"updateFavRecord\" value=\"true\">';");						//smcgi command flag
printf("	s+='<input type=\"hidden\" name=\"%s\" value=\"%s\">';", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));			//smcgi authentication token
printf("	s+='<input type=\"hidden\" name=\"disableCheckForIP_favorites\" value=\"'+determineShouldIgnoreChangeInIP()+'\">';");
printf("	s+='<input type=\"hidden\" name=\"recno_fav\" value=\"'+favRecno+'\">';");								//favorite's recno
//printf("	s+='<input type=\"hidden\" id=\"fld_position\" name=\"position\" value=\"'+rsRec_getFavPosition(FavScreen.rsOrig, favRecno)+'\">';");	//shouldn't be changing from here, but send it to smcgi anyway, so we can just reuse the logic there that also updates fav records from other places (which might include position)
printf("	s+='<input type=\"hidden\" id=\"fld_position\" name=\"position\" value=\"%s:%d,%d,%d\">';", FAVS_UNSORTED_FLAG, FAVS_UNSORTED_INDEX_A_MIN, FAVS_UNSORTED_INDEX_B_MIN, FAVS_UNSORTED_INDEX_C_MIN);
printf("	s+='<div id=\"favmsgwrapper\">';");
printf("	s+='<table>';");
printf("	s+='<tr>';");
printf("	s+='<td class=\"fieldlabel\">';");
printf("	s+='	<img style=\"vertical-align:middle;\" id=\"panelEditFav_icon\" src=\"%s/icons/32x32/'+favIcon+'\"  onclick=\"javascript:showPanel_iconChooser();return false;\">';", cgi_icons);
printf("	s+='	</td>';");
printf("	s+='<td class=\"field\">';");
printf("	s+='	<input type=\"hidden\" id=\"fld_icon\" name=\"fld_icon\" value=\"'+favIcon+'\">';");
//printf("	s+='	<img style=\"vertical-align:middle; margin-right:1em;\" id=\"panelEditFav_icon\" src=\"%s/icons/32x32/'+favIcon+'\">';", cgi_icons);
printf("	s+='	<button type=\"button\" class=\"yui3-button\" onclick=\"javascript:showPanel_iconChooser();return false;\">Choose New Icon</button>';");	//note: type=button and return false -- to be safe and not have the form submit to smcgi by mistake
printf("	s+='	</td>';");
printf("	s+='</tr>';");
printf("	s+='<tr>';");
printf("	s+='<td class=\"fieldlabel\">Name</td>';");
printf("	s+='<td class=\"field\"><input type=\"text\" name=\"label1\" id=\"label1\" value=\"'+fldValue_favName+'\" maxlength=\"%d\"></input><span class=\"charcountdisplay\" id=\"charcountdisplay-favname\"></span></td>';", FAVS_FAVNAME_MAXLENGTH);
printf("	s+='</tr>';");
printf("	s+='<tr>';");
printf("	s+='<td class=\"fieldlabel\">Desc.</td>';");
printf("	s+='<td class=\"field\"><input type=\"text\" name=\"label2\" id=\"label2\" value=\"'+fldValue_favDesc+'\" maxlength=\"%d\"></input><span class=\"charcountdisplay\" id=\"charcountdisplay-favdesc\"></span></td>';", MSGLINE_LENGTH-1);
printf("	s+='</tr>';");
printf("	s+='</table>';");
printf("	s+='</div>';");
printf("	s+='<div id=\"msgtemplateinfo\" class=\"roundedcorners\">';");
printf("	s+='<table>';");
printf("	s+='<tr><td class=\"headercell roundedtopcorners6\" colspan=\"2\">ORIGINAL MESSAGE INFORMATION</td></tr>';");
printf("	s+='<tr><td class=\"fieldlabel\">DIRECTORY:</td><td class=\"fieldvalue\">'+msgTempDir+'</td></tr>';");
printf("	s+='<tr><td class=\"fieldlabel\">MSG NAME:</td><td class=\"fieldvalue\">'+msgTempName+'</td></tr>';");
printf("	s+='<tr><td class=\"fieldlabel roundedblcorner6\">DESCRIPTION:</td><td class=\"fieldvalue\">'+msgTempDesc+'</td></tr>';");
printf("	s+='</table>';");
printf("	s+='</div>';");
printf("	s+='</form>';");
printf("	FavScreen.panelUndeleteFav.set(\"bodyContent\", s);");
printf("	document.getElementById('label1').oninput = function(){updateCharCountDisplay(document.getElementById('charcountdisplay-favname'), this.value.length, %d);};", FAVS_FAVNAME_MAXLENGTH);
printf("	document.getElementById('label2').oninput = function(){updateCharCountDisplay(document.getElementById('charcountdisplay-favdesc'), this.value.length, %d);};", MSGLINE_LENGTH-1);
printf("	FavScreen.panelUndeleteFav.show();");
printf("}\n");//end function undeleteFav_popPanel()

printf("function load_yuiPanel_messageReplyDialog() {");
printf("	FavScreen.MessageReplyDialog = new ClassMessageReplyDialog();");
printf("}\n");

printf("function popupNewWindowForSMCGI_resolveMsg(strName, strHTML){");
printf("	if(strHTML===\"undefined\"){");
printf("		FavScreen.log('error', \"popupNewWindowForSMCGI_resolveMsg() requires a string of HTML in order to pop a new window.\", true);");
printf("		return false;");
printf("	}");
printf("	var windowHandle = window.open('', strName, 'menubar=yes,toolbar=no,location=no,resizable=yes,scrollbars=yes,status=yes,height=320,width=840,%s', false);", HTML_WINDOW_OPEN_LOCATION);
printf("	if(typeof windowHandle===\"undefined\"){");							//if the client doesn't (or won't) support support (or allow) popups, provide a friendly message to the user
//printf("		window.alert(\"Your browser doesn't allow this type of message to be launched. Please disable any pop-up blockers, first.\");");
printf("		Spinner.hide();");
printf("		return false;");
printf("	}");
printf("	windowHandle.document.write(strHTML);");
//printf("	if(strHTML.indexOf(\"SetFormIsLoaded\")>-1){windowHandle.SetFormIsLoaded();}");	//if this function exists in the html, have the new window call it (since by using this method, the onbodyload event doesn't fire)
printf("	return windowHandle;");
printf("}\n");//end function popupNewWindowForSMCGI_resolveMsg()

printf("function popupNewWindowForSMCGI_viewMsg(strName, strHTML){");
printf("	if(strHTML===\"undefined\"){");
printf("		FavScreen.log('error', \"popupNewWindowForSMCGI_viewMsg() requires a string of HTML in order to pop a new window.\", true);");
printf("		return false;");
printf("	}");
printf("	var windowHandle = window.open('', strName, 'menubar=yes,toolbar=no,location=no,resizable=yes,scrollbars=yes,status=yes,height=320,width=840,%s', false);", HTML_WINDOW_OPEN_LOCATION);
printf("	if(typeof windowHandle===\"undefined\"){");							//if the client doesn't (or won't) support support (or allow) popups, provide a friendly message to the user
//printf("		window.alert(\"Your browser doesn't allow this type of message to be launched. Please disable any pop-up blockers, first.\");");
printf("		Spinner.hide();");
printf("		return false;");
printf("	}");
printf("	windowHandle.document.write(strHTML);");
//printf("	if(strHTML.indexOf(\"SetFormIsLoaded\")>-1){windowHandle.SetFormIsLoaded();}");	//if this function exists in the html, have the new window call it (since by using this method, the onbodyload event doesn't fire)
printf("	return windowHandle;");
printf("}\n");//end function popupNewWindowForSMCGI_resolveMsg()

printf("var windowHandle_viewMsgDir;");
printf("function popupNewWindowForSMCGI_viewMsgDir(e){");				// Popup a new window for showing the legacy message-directory screen (optional arg)
printf("	var recno = 0;");
printf("	var msgname = \"\";");
printf("	var msgdir = \"\";");
printf("	if(FavScreen.get('attrBrowserSupports_dataset')){");				//acquire the message-template recno 
printf("		recno = e.currentTarget.dataset.msgtemprecno;");
printf("		msgname = e.currentTarget.dataset.msgtempname;");
printf("		msgdir = e.currentTarget.dataset.msgtempdir;");
printf("	}else{");
printf("		recno = e.currentTarget.getAttribute(\"data-msgtemprecno\");");
printf("		msgname = e.currentTarget.getAttribute(\"data-msgtempname\");");
printf("		msgdir = e.currentTarget.getAttribute(\"data-msgtempdir\");");
printf("	}");
printf("	if(typeof recno===\"undefined\" || recno==0){");
printf("		FavScreen.log('warn',\"popupNewWindowForSMCGI_viewMsgDir(): Could not determine the message template record number. Aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	if(typeof msgname===\"undefined\" || msgname.length==0){");
printf("		FavScreen.log('warn',\"popupNewWindowForSMCGI_viewMsgDir(): Could not determine the message template name. Aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	if(typeof msgdir===\"undefined\" || msgdir.length==0){");
printf("		FavScreen.log('warn',\"popupNewWindowForSMCGI_viewMsgDir(): Could not determine the message template directory name. Aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	YUI().use(\"io\", \"io-base\", function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("			FavScreen.log('log',\"popupNewWindowForSMCGI_viewMsgDir(): YUI-IO Txn ID#\"+ioId+\": Starting txn.\",false);");
printf("		};");
printf("		var handleSuccess = function(ioId, o){");						//what should happen when response HTTP status resolves to 2xx
printf("			FavScreen.log('log',\"popupNewWindowForSMCGI_viewMsgDir(): YUI-IO Txn ID#\"+ioId+\": Txn succeeded.\",false);");
printf("			windowHandle_viewMsgDir = window.open('', '', 'menubar=yes,toolbar=no,location=no,resizable=yes,scrollbars=yes,status=yes,height=320,width=840,%s', false);", HTML_WINDOW_OPEN_LOCATION);
printf("			if(typeof windowHandle_viewMsgDir===\"undefined\"){");							//if the client doesn't (or won't) support support (or allow) popups, provide a friendly message to the user
printf("				window.alert(\"Your browser doesn't allow pop-ups. Please disable any pop-up blockers, first.\");");
printf("				Spinner.hide();");
printf("				return false;");
printf("			}");
printf("			windowHandle_viewMsgDir.document.write(o.responseText);");
printf("			if(o.responseText.indexOf(\"SetFormIsLoaded\")>-1){setTimeout(function(){windowHandle_viewMsgDir.SetFormIsLoaded();},1000);}");	//if this function exists in the html, have the new window call it (since by using this method, the onbodyload event doesn't fire)
printf("			return windowHandle_viewMsgDir;");
printf("		};");
printf("		var handleFailure = function(ioId, o){");						//what should happen when response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('warn',\"popupNewWindowForSMCGI_viewMsgDir(): YUI-IO Txn ID#\"+ioId+\": Txn failed or timed-out.\",false);");
printf("			FavScreen.log('verbose',\"Txn ID#\"+ioId+\"'s responseText returned by server = '\"+o.responseText+\"'\",false);");
//printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("			return false;");
printf("		};");
printf("		var handleEnd = function(ioId, o){");							//what should happen when YUI-IO transaction is finished
printf("			FavScreen.log('log',\"popupNewWindowForSMCGI_viewMsgDir(): YUI-IO Txn ID#\"+ioId+\": Txn has ended.\",false);");
printf("		};");
printf("		var cfg ={");										//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");							//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");								//subscribe the above custom end handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
printf("				'%s':'%s'", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				,'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP()");
printf("				,'jump_to_message_editor':recno");
printf("				,'jump_to_message_editor_dtsec':''");
printf("				,'main_send_message':msgname");
printf("				,'directory':msgdir");									//this is the important one here (not sure about the rest.. was hard to figure out)
printf("				,'button_directory':1");
printf("				,'inbox_table_view':1");
printf("				,'form_state':%d", STATE_SEND_MESSAGES);
printf("				,'preferences_form_state':%d", STATE_SEND_MESSAGES);
printf("				,'from_pin':'%s'", CurrentUserPin);
printf("				,'first_record':recno");
printf("				,'first_record_archive':1");
printf("				,'last_record_archive':1");
printf("				,'first_displayed_record':recno");
printf("				,'first_displayed_record_archive':1");
printf("				,'checkbox_checked_clear_checkbox_field':1");
printf("				,'checkbox_checked_inbox_view':1");
printf("				,'launch_or_delayed_launch':'ZX'");
printf("				,'main_button_selected':'1'");
printf("				,'main_current_organization':'ADMINISTRATION                '");
printf("				,'message_line_resizer':0");
printf("				,'recent_message_line_resizer':0");
printf("				,'inbox_full_view_recno':0");
printf("				,'inbox_full_view_recent_messages':0");
printf("				,'inbox_full_view_archive_number':0");
printf("				,'inbox_schedule_view_recno':0");
printf("				,'inbox_cancel_lsi_calling':0");
printf("				,'print_inbox':0");
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:true,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:20000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("		};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");								//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("	});");
printf("}\n");//end function popupNewWindowForSMCGI_resolveMsgDir()

printf("var windowHandle_viewMsgDef;");
printf("function popupNewWindowForSMCGI_viewMsgDef(e){");				// Popup a new window for showing the legacy message-directory screen (optional arg)
printf("	var recno = 0;");
printf("	var msgname = \"\";");
printf("	var msgdir = \"\";");
printf("	if(FavScreen.get('attrBrowserSupports_dataset')){");				//acquire the message-template recno 
printf("		recno = e.currentTarget.dataset.msgtemprecno;");
printf("		msgname = e.currentTarget.dataset.msgtempname;");
printf("		msgdir = e.currentTarget.dataset.msgtempdir;");
printf("	}else{");
printf("		recno = e.currentTarget.getAttribute(\"data-msgtemprecno\");");
printf("		msgname = e.currentTarget.getAttribute(\"data-msgtempname\");");
printf("		msgdir = e.currentTarget.getAttribute(\"data-msgtempdir\");");
printf("	}");
printf("	if(typeof recno===\"undefined\" || recno==0){");
printf("		FavScreen.log('warn',\"popupNewWindowForSMCGI_viewMsgDef(): Could not determine the message template record number. Aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	if(typeof msgname===\"undefined\" || msgname.length==0){");
printf("		FavScreen.log('warn',\"popupNewWindowForSMCGI_viewMsgDef(): Could not determine the message template name. Aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	if(typeof msgdir===\"undefined\" || msgdir.length==0){");
printf("		FavScreen.log('warn',\"popupNewWindowForSMCGI_viewMsgDef(): Could not determine the message template directory name. Aborting.\",true);");
printf("		return false;");
printf("	}");
printf("	YUI().use(\"io\", \"io-base\", function(Y){");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("			FavScreen.log('log',\"popupNewWindowForSMCGI_viewMsgDef(): YUI-IO Txn ID#\"+ioId+\": Starting txn.\",false);");
printf("		};");
printf("		var handleSuccess = function(ioId, o){");						//what should happen when response HTTP status resolves to 2xx
printf("			FavScreen.log('log',\"popupNewWindowForSMCGI_viewMsgDef(): YUI-IO Txn ID#\"+ioId+\": Txn succeeded.\",false);");
printf("			windowHandle_viewMsgDef = window.open('', '', 'menubar=yes,toolbar=no,location=no,resizable=yes,scrollbars=yes,status=yes,height=320,width=840,%s', false);", HTML_WINDOW_OPEN_LOCATION);
printf("			if(typeof windowHandle_viewMsgDef===\"undefined\"){");							//if the client doesn't (or won't) support support (or allow) popups, provide a friendly message to the user
printf("				window.alert(\"Your browser doesn't allow pop-ups. Please disable any pop-up blockers, first.\");");
printf("				Spinner.hide();");
printf("				return false;");
printf("			}");
printf("			windowHandle_viewMsgDef.document.write(o.responseText);");
printf("			if(o.responseText.indexOf(\"SetFormIsLoaded\")>-1){setTimeout(function(){windowHandle_viewMsgDef.SetFormIsLoaded();},1000);}");	//if this function exists in the html, have the new window call it (since by using this method, the onbodyload event doesn't fire)
printf("			return windowHandle_viewMsgDef;");
printf("		};");
printf("		var handleFailure = function(ioId, o){");						//what should happen when response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('warn',\"popupNewWindowForSMCGI_viewMsgDef(): YUI-IO Txn ID#\"+ioId+\": Txn failed or timed-out.\",false);");
printf("			FavScreen.log('verbose',\"Txn ID#\"+ioId+\"'s responseText returned by server = '\"+o.responseText+\"'\",false);");
//printf("			ModalNotification_ServiceUnavailable.showFor(4000);");
printf("			return false;");
printf("		};");
printf("		var handleEnd = function(ioId, o){");							//what should happen when YUI-IO transaction is finished
printf("			FavScreen.log('log',\"popupNewWindowForSMCGI_viewMsgDef(): YUI-IO Txn ID#\"+ioId+\": Txn has ended.\",false);");
printf("		};");
printf("		var cfg ={");										//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");							//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");								//subscribe the above custom end handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
printf("				'%s':'%s'", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				,'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP()");
printf("				,'jump_to_message_editor':recno");
printf("				,'jump_to_message_editor_dtsec':''");
printf("				,'loadSecondaryCreateEditMessages':recno");
printf("				,'record_number':recno");
printf("				,'me_command':'FIND'");
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:true,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:20000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("		};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");								//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("	});");
printf("}\n");//end function popupNewWindowForSMCGI_resolveMsgDef()

printf("function parsePositionType(strRawPosition){");							// Take the raw position string (ex. "S:00002,00001,00001") and parse the position-type flag, returning it as a string
printf("	if(typeof strRawPosition===\"undefined\"){");						//if the required argument wasn't provided to this function call
printf("		FavScreen.log('error', \"The function, parsePositionType(), requires the strRawPosition argument to be supplied.\", true);");
printf("		return false;");
printf("	}");
printf("	if(strRawPosition==\"false\" || strRawPosition==false){");					//if there is trash data for some reason (such that .split will not work), make sure we avoid that error and still return some kind of valid value...
printf("		FavScreen.log('warn', \"The function, parsePositionType() was given a bad strRawPosition argument (\"+strRawPosition+\").\", true);");
printf("		return \"%s\";", FAVS_ERROR_FLAG);							//return a value reflecting an error state
printf("	}");
printf("	else{");
printf("		var arr = strRawPosition.split(':');");							//after this, arr should now be something like: arr[0]="S" and arr[1]="00002,00001,00001"
printf("		return arr[0];");									//return the type flag as a string
printf("	}");
printf("}\n");//end function parsePositionType()
printf("function parsePositionInteger(strRawPosition, intI){");						// Take the raw position string (ex. "S:00002,00001,00001") and parse the specified dimension's value, returning it as an integer (intI is a 1-based integer representing the position's dimension to parse)
printf("	if(typeof strRawPosition===\"undefined\"){");						//if the required argument wasn't provided to this function call
printf("		FavScreen.log('error', \"The function, parsePositionInteger(), requires the strRawPosition argument to be supplied.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof intI===\"undefined\" || typeof intI===\"NaN\"){");				//if the required argument wasn't provided to this function call or doesn't represent a number
printf("		FavScreen.log('error', \"The function, parsePositionInteger(), requires a valid intI argument (\"+intI+\") to be supplied.\", true);");
printf("		return false;");
printf("	}");
printf("	if(strRawPosition==\"false\" || strRawPosition==false){");					//if there is trash data for some reason (such that .split will not work), make sure we avoid that error and still return some kind of valid value...
printf("		FavScreen.log('warn', \"The function, parsePositionInteger() was given a bad strRawPosition argument (\"+strRawPosition+\").\", true);");
printf("		return \"%s\";", FAVS_ERROR_FLAG);							//return a value reflecting an error state
printf("	}");
printf("	else{");
printf("		var arr = strRawPosition.split(':');");							//after this, arr should now be something like: arr[0]="S" and arr[1]="00002,00001,00001"
printf("		arr = arr[1].split(',');");								//after this, arr should now be something like: arr[0]="00002" and arr[1]="00001" and arr[2]="00001"
printf("		return parseInt(arr[parseInt(intI)]);");						//return an integer representing the specified-dimension's sort value
printf("	}");
printf("}\n");//end function parsePositionInteger()
printf("function parsePositionIntegerAsString(strRawPosition, intI){");					// Take the raw position string (ex. "S:00002,00001,00001") and parse the specified dimension's value, returning it as a string w/leading zeros (intI is a 1-based integer representing the position's dimension to parse)
printf("	if(typeof strRawPosition===\"undefined\"){");						//if the required argument wasn't provided to this function call
printf("		FavScreen.log('error', \"The function, parsePositionInteger(), requires the strRawPosition argument to be supplied.\", true);");
printf("		return false;");
printf("	}");
printf("	if(typeof intI===\"undefined\" || typeof intI===\"NaN\"){");				//if the required argument wasn't provided to this function call or doesn't represent a number
printf("		FavScreen.log('error', \"The function, parsePositionInteger(), requires a valid intI argument (\"+intI+\") to be supplied.\", true);");
printf("		return false;");
printf("	}");
printf("	if(strRawPosition==\"false\" || strRawPosition==false){");					//if there is trash data for some reason (such that .split will not work), make sure we avoid that error and still return some kind of valid value...
printf("		FavScreen.log('warn', \"The function, parsePositionInteger() was given a bad strRawPosition argument (\"+strRawPosition+\").\", true);");
printf("		return \"%s\";", FAVS_ERROR_FLAG);							//return a value reflecting an error state
printf("	}");
printf("	else{");
printf("		var arr = strRawPosition.split(':');");							//after this, arr should now be something like: arr[0]="S" and arr[1]="00002,00001,00001"
printf("		arr = arr[1].split(',');");								//after this, arr should now be something like: arr[0]="00002" and arr[1]="00001" and arr[2]="00001"
printf("		return arr[parseInt(intI)].toString();");						//return a string representing the specified-dimension's sort value (should thus include any leading zeros)
printf("	}");
printf("}\n");//end function parsePositionIntegerAsString()

printf("function load_yuiRsEdited(boolPopulateWithSorted){");						// Create a recordset object for keeping track of user-edited favorites... on initial call, rsEdited will be created as a member of FavScreen
printf("	YUI().use('recordset-base', 'recordset-filter', 'recordset-sort', function(Y){");		// Create a new YUI instance that will allow us to work with recordset stuff...
printf("		if(typeof FavScreen==='undefined'){");							//if our global object isn't defined, then don't allow this function to continue
printf("			console.error(\"Initializing the rsEdited recordset requires that FavScreen be created, first!\");");
printf("			return false;");
printf("		}");
printf("		FavScreen.rsEdited = new Y.Recordset();");						//initialize a new recordset into our global object
//printf("		FavScreen.rsEdited.plug(Y.Plugin.RecordsetFilter);");					//plug-in the filter stuff (access its stuff from the .filter namespace... e.g. to filter: FavScreen.rsEdited.filter.filter([options]) )
//printf("		FavScreen.rsEdited.plug(Y.Plugin.RecordsetSort);");					//plug-in the sort stuff (access its stuff from the .sort namespace... e.g. to sort: FavScreen.rsEdited.sort.sort([options]) )
printf("		FavScreen.rsEdited.after('init', function(){");					//subscribe an initial "after init" event listner to the recordset object (just so we are absolutely certain we attach the next after-add event listener to a fully-initialized object)
printf("			FavScreen.rsEdited.after('add', function(){");					//subscribe an initial "after add" event listner to the recordset object to render the favorites list as soon as possible (this will fire after our initial add of data, further below)
printf("				FavScreen.rsEdited.detachAll();");					//detach all initial event listeners, so we can seamlessly reattach other events later (like maybe for sorting, adding new, etc.)
printf("				Y.log(\"Initial set of \"+this.size()+\" record(s) now populated into the 'rsEdited' recordset.\", \"log\", \"load_yuiRsEdited(): YUI-RecordSet FavScreen.rsEdited\");");
printf("				Spinner.hide();");
printf("				FavScreen.rsEdited.after('add', function(e){");			//attach permanent after-add events (pertains to adding one/many records to the recordset)
printf("					Y.log(\"After-add event fired... \"+this.size()+\" record(s) added.\", \"log\", \"YUI-RecordSet: FavScreen.rsEdited\");");
printf("					});");
printf("				FavScreen.rsEdited.after('empty', function(e){");			//attach permanent after-empty events (pertains to emptying the entire recordset)
printf("					Y.log(\"After-empty event fired... recordset has been emptied of all records.\", \"log\", \"YUI-RecordSet: FavScreen.rsEdited\");");
printf("					});");
printf("				FavScreen.rsEdited.after('remove', function(e){");			//attach permanent after-remove events (pertains to removing one/many records from the recordset)
printf("					Y.log(\"After-remove event fired... record(s) removed.\", \"log\", \"YUI-RecordSet: FavScreen.rsEdited\");");
printf("					});");
printf("				FavScreen.rsEdited.after('update', function(e){");			//attach permanent after-update events (pertains to updating one/many records in the recordset)
printf("					Y.log(\"After-update event fired... record(s) updated.\", \"log\", \"YUI-RecordSet: FavScreen.rsEdited\");");
printf("					});");
printf("			});");//end add event listener subscription
printf("		});");//end init event listener subscription
printf("	});");//end YUI().use
printf("	if(boolPopulateWithSorted){");									//if we need to populate rsEdited with already-existing sorted records...
printf("		var initialRecords;");									//initialize a place to store the initial set of records that may get added to the rsEdited recordset
printf("		if(FavScreen.rsOrig_sorted){");								//if there is a rsOrig_sorted recordset, use whatever data it has for our initial loading of rsEdited...
printf("			initialRecords = FavScreen.rsOrig_sorted.get('records');");			//get an object of record(s) from rsOrig_sorted
printf("			FavScreen.rsEdited.add();");							//do the initial loading of the recordset with that object of record(s)
printf("		}else{");
printf("			FavScreen.log('warn', \"load_yuiRsEdited() could not initially populate FavScreen.rsEdited because FavScreen.rsOrig_sorted recordset didn't exist.\", true);");
printf("		}");
printf("	}");
printf("}\n");//end function load_yuiRsEdited()

printf("function handleSaveChanges(){");								// Determines whether there are any edits that need to be saved, and handles actually doing the stuff needed to save them
//note: this may expand quite a bit, but just for now, get it to save sorting order
printf("	if(FavScreen.get('attrInteractionMode_prev')==MODE_EDITABLE) {");				//if coming from edit mode
printf("		if(typeof FavScreen.rsEdited===\"object\" && FavScreen.rsEdited.name===\"recordset\" && FavScreen.rsEdited.size()>0){");
printf("			FavScreen.log('info', \"SAVING rsEdited to database\", true);");
printf("			saveSortedFavRecnosToSMCGI(FavScreen.rsEdited);");
printf("		}");
printf("	}");
printf("}\n");//end function handleSaveChanges()

printf("var ZOOMCONTROLS_HIDE = 0;\n");
printf("var ZOOMCONTROLS_SHOW = 1;\n");
printf("var node_bodywrapper_originalOffsetTop = undefined;\n");
printf("function zoomControls_doZoom(strPercentZoom){");
printf("	if(typeof strPercentZoom===\"undefined\"){");					//if zoom argument not provided, abort
printf("		FavScreen.log('error',\"zoomControls_doZoom() requires the strPercentZoom argument. Aborting function.\",true);");
printf("		return false;");
printf("	}");
printf("	if(typeof strPercentZoom!==\"string\"){");					//if zoom argument isn't a string type, convert it
printf("		FavScreen.log('warn',\"zoomControls_doZoom() requires the strPercentZoom argument be of a string type (it is '\"+typeof strPercentZoom+\"'). Automatically converting toString().\",true);");
printf("		strPercentZoom=strPercentZoom.toString();");
printf("	}");
printf("	if(strPercentZoom.indexOf(\"%%\")<0){");					//if zoom argument doesn't contain a percent symbol (which is required for CSS), append one. This may have happened if they had an older version's (0.7.2-alpha and older) zoom cookie set
printf("		FavScreen.log('info',\"zoomControls_doZoom() requires the strPercentZoom argument to contain a percent symbol (it is '\"+strPercentZoom+\"'). Automatically converting...\",true);");
printf("		strPercentZoom = parseInt(strPercentZoom)+\"%%\";");
printf("		FavScreen.set('attrZoom',\"100%%\");");						//set initial to default, so the on change event listener will fire, next (that listener should take care of setting cookie, saving DB, etc.)
printf("		FavScreen.set('attrZoom',strPercentZoom);");
printf("		FavScreen.log('info',\"zoomControls_doZoom() converted invalid CSS value to: '\"+strPercentZoom+\"'\",false);");
printf("	}");
printf("	if(isNaN(parseInt(strPercentZoom))){");						//if the string doesn't represent a number
printf("		FavScreen.log('warn',\"zoomControls_doZoom() argument doesn't represent a valid number (it is '\"+strPercentZoom+\"'). Can't determine, so defaulting to 100%%.\",true);");
printf("		strPercentZoom=\"100%%\";");
printf("	}");
printf("	var node_bodyWrapper = document.getElementById(\"bodywrapper\");");		//get a reference to the bodywrapper node
printf("	if(node_bodyWrapper==null){");							//if body node doesn't exist, abort
printf("		FavScreen.log('error',\"zoomControls_doZoom(): The node 'bodywrapper' does not exist in the document. Aborting function.\",true);");
printf("		return false;");
printf("	}");
printf("	try{");
printf("		if(node_bodywrapper_originalOffsetTop==undefined){");			//if the bodywrapper's original (pre-zoom) top position hasn't yet been set, then set it
printf("			node_bodywrapper_originalOffsetTop = parseInt(document.getElementById(\"bodywrapper\").offsetTop);");
printf("		}");
printf("		var intPercentZoom=parseInt(strPercentZoom);");				//get an integer value of zoom level so we can calculate offset
printf("		node_bodyWrapper.style.zoom = strPercentZoom;");			//apply the zoom level specified to the bodywrapper node
printf("		var tempiframe, tempdoc;");
printf("		if(document.getElementById(\"iframe_toResolveMsg\")){");		//if this iframe exists/showing, apply zoom to it's document (since the above operation won't propagate to it)
printf("			tempiframe = document.getElementById(\"iframe_toResolveMsg\");");
printf("			tempdoc = tempiframe.contentWindow.document || tempiframe.contentDocument;");//get a reference to the panel's iframe's document (this assignment method should help support different browsers)
printf("			tempdoc.body.style.zoom = FavScreen.get('attrZoom');");
printf("		}");
printf("		if(document.getElementById(\"internalPopupBodyContent\")){");		//if this iframe exists/showing, apply zoom to it's document (since the above operation won't propagate to it)
printf("			tempiframe = document.getElementById(\"internalPopupBodyContent\");");
printf("			tempdoc = tempiframe.contentWindow.document || tempiframe.contentDocument;");//get a reference to the panel's iframe's document (this assignment method should help support different browsers)
printf("			tempdoc.body.style.zoom = FavScreen.get('attrZoom');");
printf("		}");
printf("		if(document.getElementById(\"zoomcontrols\").style.display===\"block\"){");
printf("			zoomControls(ZOOMCONTROLS_HIDE);");				//hide the zoom controls
printf("		}");
printf("		node_bodyWrapper.style.top = node_bodywrapper_originalOffsetTop/intPercentZoom*100+\"px\";");//shift the bodywrapper up/down depending on zoom level, to give the impression that it is not moving
printf("		FavScreen.log('log',\"zoomControls_doZoom(): bodywrapper node's zoom (\"+strPercentZoom+\") and top-offset (\"+node_bodyWrapper.style.top+\") set.\",false);");
printf("	}");//end try
printf("	catch(err){");
printf("		FavScreen.log('error',\"zoomControls_doZoom(): A problem occurred while trying to set zoom styling to the bodywrapper node. Aborting function. Following, is the error...\",true);");
printf("		FavScreen.log('log', err.message+\" -- \"+err.description, false);");
printf("	}");//end catch
printf("}\n");//end function zoomControls_doZoom()

printf("SHOULD_IGNORE_CHANGE_IN_IP = false;");
printf("function determineShouldIgnoreChangeInIP(){");					// Determine whether we should tell the server to ignore a change in client IP address (really only for mobile devices, which usually change IP a lot - especially on mobile networks)
printf("	var ret = %d;", FALSE);								//default to false, for better security
printf("	if(SHOULD_IGNORE_CHANGE_IN_IP) {");						//if we've already done the work to check, just return that result (reduces workload a tiny bit and results in less log pollution)
printf("		return %d;", TRUE);
printf("	}");
printf("	if(typeof FavScreen!==\"undefined\" && FavScreen.get('attrIsMobileDevice')) {");//note: had to check FavScreen to fix bug where full-sys popup was blank (it calls this function and an error where can't call get() on undefined object, broke it)
printf("		FavScreen.log('info', \"determineShouldIgnoreChangeInIP(): Client seems to be a mobile device, so returning true and setting global to prevent unnecessary subsequent work/logging.\", false);");
printf("		SHOULD_IGNORE_CHANGE_IN_IP = true;");
printf("		return %d;", TRUE);
printf("	}");
printf("	return ret;");
printf("}\n");//end function determineSHouldIgnoreChangeInIP()

printf("function jumpScrollTo(targetAnchorID, boolAnimated, boolPreservePrevScrollPos){");// Jump/Scroll to the very top of the favorites list (anchored by the internally specified anchor)
printf("	var targetNode = document.getElementById(targetAnchorID);");			//get a reference to the DOM node of the anchor
printf("	var targetAnchorName = targetNode.name;");					//get the NAME attribute value of the anchor
printf("	var boolPreservePrevScrollPos = Boolean(boolPreservePrevScrollPos);");
printf("	forceHideModalMask();");
printf("	if(typeof ConfirmLaunch!==\"undefined\"){");
printf("		if(ConfirmLaunch.initialized && ConfirmLaunch.isVisible()){");
printf("			ConfirmLaunch.hide();");
printf("		}");
printf("	}");
printf("	if(typeof ConfirmToggle!==\"undefined\"){");
printf("		if(ConfirmToggle.initialized && ConfirmToggle.isVisible()){");
printf("			ConfirmToggle.hide();");
printf("		}");
printf("	}");
printf("	if(targetNode!=null){");							//if we successfully found the node (will proceed with jump/scroll)...
printf("		if(boolPreservePrevScrollPos == false) {");
printf("			FavScreen.set('attrPreviousScrollPositionPixelY', FavScreen.get('attrCurrentScrollPositionPixelY'));");//save the current scroll position before we change it
printf("		}");
printf("		if(targetAnchorID == \"bodywrapperTopAnchor\" && Boolean(boolAnimated)) {");	//if directed to do an animated scroll to top of page, we must override the traditional href-location scheme below (which doesn't do animation)
printf("			FavScreen.log('log', \"jumpScrollTo(): The 'boolAnimated' arg is true, so overriding traditional href change with a call to scrollTo_animated().\", true);");
printf("			FavScreen.set('attrJumpScrollToTopLastTimestamp',Date.now());");
printf("			scrollTo_animated(document.body, -67, 150, boolPreservePrevScrollPos);");
printf("			FavScreen.set('attrJumpNavMode',MODE_JUMPNAV_DOWN);");
printf("			return true;");
printf("		}");
printf("		var url = window.location.href;");					//get the window's current URL string
printf("		var startAnchor = url.indexOf(\"#\");");				//see if there's already an anchor directive in that URL line (if so, it will need to be removed before we specify it to do the actual jump)
printf("		if(startAnchor>-1){");							//if url line already contains an anchor directive, then we need to remove it first
printf("			url = url.substring(0,startAnchor); ");				//save everything up to (but excluding) the #anchor
printf("		}");
printf("		var jumpLoc = url+\"#\"+targetAnchorName;");				//construct a URL that we'll "navigate" to, to do the jump
printf("		FavScreen.log('log', \"jumpScrollTo(): Setting window.location.href to '\"+jumpLoc+\"'.\", true);");
printf("		window.location.href = jumpLoc;");					//do the actual jump
printf("		var headerwrapperHeight = document.getElementById(\"headerwrapper\").offsetHeight;");		//get the calculated height of the headerwrapper area (including padding, etc.)
printf("		window.scrollBy(0,-headerwrapperHeight);");
printf("		if(targetAnchorID == \"bodywrapperTopAnchor\") {");			//if we've been directed to go to the very top of the page, make sure the jump mode is set to down (since they can't go up anymore, anyway)
printf("			FavScreen.set('attrJumpNavMode',MODE_JUMPNAV_DOWN);");
printf("		}");
printf("		return true;");
printf("	}else{");									//the anchor node was NOT found, so throw warning and abort function (in future, fall back to scrollTo() ??)
printf("		FavScreen.log('warn', \"jumpScrollTo(): Anchor with id-attribute of '\"+targetAnchorID+\"' does not exist. Nothing to jump to.\", true);");
printf("		return false;");
printf("	}");
printf("}\n");//end function jumpScrollTo()

//printf("function checkRestoreFavoritesNode(){");					// Check whether the favorites listing is loaded... if something else (like personal page or message resolution, etc.), then restore the favorites
//printf("	if(FavScreen.node_bodywrapper!=null){");
//printf("		");
//printf("	}");
//printf("}\n");//end function checkRestoreFavoritesNode()

/*
//printf("function checkAndAutoClose(){");						// Check the current time against when the document was last used (focused), and auto close the window if too long -- intended to be run via setInterval()
printf("var checkAndAutoClose = function(){");
printf("	var timeoutHours = 1/60;");
printf("	var lastUsed = FavScreen.get('attrLastFocused_window');");
printf("	var curTime = Date.now();");
printf("	FavScreen.log('log', \"checkAndAutoClose(): curTime:\"+curTime+\", lastUsed:\"+lastUsed+\", diff:\"+(curTime-lastUsed)+\".\", true);");
printf("	if( (curTime-lastUsed)/1000/60/60 >= timeoutHours ){");				//since timestamps are in milliseconds, need to divide difference by 1000; then by 60 seconds/minute; then by 60 minutes/hour (since we are timing out in the HOURS timescale)
//printf("		self.close();");
printf("console.warn('CLOSE');");
printf("	}");
printf("}\n");//end function checkAndAutoClose()
//printf("autotimeout = setInterval(checkAndAutoClose, 10*1000);");
*/

printf("function parseFRC_asArray(strFRC){");						// Parse a favorites-response-code string and return an array of decoded values ([0]=code, [1]=description)
printf("	if(typeof strFRC===\"undefined\"){");
printf("		FavScreen.log('error',\"parseFRC_asArray(): A response code string argument is required.\",false);");
printf("		return false;");
printf("	}");
printf("	strFRC = strFRC.toString();");
printf("	if(strFRC.indexOf(\"FRC:\")<0){");
printf("		FavScreen.log('warn',\"parseFRC_asArray(): The argument provided is not a valid Favorites Response Code (\"+strFRC+\").\",false);");
printf("		return false;");
printf("	}");
printf("	var arr = [];");
printf("	arr[0] = strFRC.split(\"%s\")[1];", FAVS_RESPONSE_CODE_DELIM);
printf("	arr[1] = strFRC.split(\"%s\")[2];", FAVS_RESPONSE_CODE_DELIM);
printf("	return arr;");
printf("}");
/*
printf("function handleServerResponse_launchFavorite(objResponse){");			// Parse the server response object provided and handle how that's conveyed to the user (popping notifications, etc.)
printf("	if(typeof objResponse===\"undefined\"){");
printf("		FavScreen.log();");
printf("		return false;");
printf("	}");
printf("	");
printf("	");
printf("	");
printf("	");
printf("	");
printf("}\n");//end function handlServerResponse_launchFavorite
*/

printf("var forceCssRepaint_timeoutHandle = false;");					//initialize a global to store a timeout handle, if needed
printf("function forceCssRepaint(objDomNode){");					// Force a CSS repaint operation on the specified node (or entire body if none specified)
printf("	FavScreen.log('log',\"forceCssRepaint(): Called.\",false);");
printf("	if(typeof objDomNode===\"undefined\"){");
printf("		FavScreen.log('log',\"forceCssRepaint(): objDomNode argument not provided, defaulting repaint operation to the document's root body node.\",false);");
printf("		objDomNode=document.body;");
printf("	}");
printf("	var method = 1;");								//define the method to use
//printf("	var method = 2;");								//define the method to use
//printf("	var method = 3;");								//define the method to use
printf("	if(forceCssRepaint_timeoutHandle!=false){");
printf("		FavScreen.log('info',\"forceCssRepaint(): forceCssRepaint_timeoutHandle seems valid (= \"+forceCssRepaint_timeoutHandle+\"), aborting to avoid multiple simultaneous operations.\",false);");
printf("		return false;");
printf("	}");
printf("	if(method==1){");								//Method #1: didn't seem to work (0.9.6-alpha)
printf("		objDomNode.offsetHeight;");							//no need to store this anywhere, the reference is enough?
printf("		return;");
printf("	}");
printf("	var disp = objDomNode.style.display;");						//save original display value so it can be restored later if needed
printf("	if(disp==\"\"){disp=\"block\";}");						//if there's no explicit value, default to block
printf("	if(method==2){");								//Method #2: didn't seem to work (0.9.6-alpha)
printf("		objDomNode.style.display='none';");						//take the node out of view
printf("		objDomNode.offsetHeight;");							//no need to store this anywhere, the reference is enough?
printf("		objDomNode.style.display=disp;");						//restore the node's original display
printf("		return;");
printf("	}");
printf("	if(method==3){");								//Method #2: seems to work (0.9.7-alpha)
printf("		var n = document.createTextNode(' ');");					//create an empty text node
printf("		objDomNode.appendChild(n);");							//add the empty text node to the document
printf("		objDomNode.style.display='none';");						//take the node out of view
printf("		forceCssRepaint_timeoutHandle = setTimeout(function(){");			//after a very short delay (as short as possible), remove the temporary blank text node and restore the node's original display
printf("			objDomNode.style.display=disp;");						//restore display
printf("			n.parentNode.removeChild(n);");							//remove the temporary blank text node
printf("			clearTimeout(forceCssRepaint_timeoutHandle);");					//clear the timeout handle this routine was assigned to
printf("			forceCssRepaint_timeoutHandle=false;");						//re-initialize the global so future tests won't be messed up
printf("			},10);");									//make as short as possible (20ms starts to REALLY be noticeable)
printf("		return;");
printf("	}");
printf("}\n");//end function forceCssRepaint

printf("function parseUuidFromUA(){");
if(isLoadedInMobileApp())
	{
	printf("var ua = navigator.userAgent;");								//user agent string the client gives us
	printf("var expectedPositionOfUUID = ua.indexOf(\"%s\");", FAVS_APP_USERAGENT_UUID_START);		//zero-based character position of our UUID substring start
	printf("var uaFromUUID = ua.substring(expectedPositionOfUUID);");					//get just the section of user-agent starting with the uuid (and anything that may be after it)
	printf("return uaFromUUID.split(\"%s\")[1];", FAVS_APP_USERAGENT_UUID_START);				//return what should be just the UUID portion
	}
else
	{
	printf("FavScreen.log('warn',\"parseUuidFromUA(): Called from a client that provides no UUID. Returning false.\",true);");
	printf("return undefined;");
	}
printf("}\n");//end function parseUuidFromUA()

/*
printf("function getCurrentNativeAppleAppVersion(){");							// Ask the server for the current official Apple native-app version and return it as a string
//printf("	YUI().use(\"io\", \"io-base\", function(Y){");
//printf("	var mine = YUI().use(\"io\", \"io-base\");");
//printf("debugger;");
printf("		var ret = \"\";");
printf("		var objResponse;");
printf("		var handleStart = function(ioId, o){");							//what should happen when the io txn starts
printf("			FavScreen.log('log',\"getCurrentNativeAppleAppVersion(): YUI-IO Txn ID#\"+ioId+\": Starting transaction.\",false);");
printf("		};");
printf("		var handleSuccess = function(ioId, o){");						//what should happen when response HTTP status resolves to 2xx
printf("			FavScreen.log('log',\"getCurrentNativeAppleAppVersion(): YUI-IO Txn ID#\"+ioId+\": Txn succeeded.\",false);");
printf("			ret = o.responseText;");
printf("		};");
printf("		var handleFailure = function(ioId, o){");						//what should happen when response HTTP status resolves to 4xx, 5xx, undefined, or a non-standard HTTP status
printf("			FavScreen.log('warn',\"getCurrentNativeAppleAppVersion(): YUI-IO Txn ID#\"+ioId+\": Txn failed or timed-out.\",false);");
printf("			FavScreen.log('log',\"Txn ID#\"+ioId+\"'s responseText returned by server = '\"+o.responseText+\"'\",false);");
printf("			ret = false;");
printf("		};");
printf("		var handleEnd = function(ioId, o){");							//what should happen when YUI-IO transaction is finished
printf("			FavScreen.log('log',\"getCurrentNativeAppleAppVersion(): YUI-IO Txn ID#\"+ioId+\": Txn has ended.\",false);");
printf("			console.log(ret);");
printf("			return ret;");
printf("		};");
printf("		var cfg ={");										//setup a standard YUI configuration object for our transaction
printf("			on:{");
printf("				start:handleStart,");								//subscribe the above custom start handler to IO's global start event
printf("				success:handleSuccess,");							//subscribe the above custom success handler to IO's global success event
printf("				failure:handleFailure,");							//subscribe the above custom failure handler to IO's global failure event
printf("				end:handleEnd");								//subscribe the above custom end handler to IO's global end event
printf("				},");
printf("			method:\"POST\", ");									//method will default to GET unless we specify POST here
printf("			data:{");										//whatever fields/data that CGI gets to parse...
printf("				'favoritesGetCurrentOfficialAppleAppVersion':'true',");					//smcgi command flag
printf("				'%s':'%s',", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("				'disableCheckForIP_favorites':determineShouldIgnoreChangeInIP()");
printf("				},");
printf("			headers:{");
printf("				'Content-Type':'application/x-www-form-urlencoded'");
printf("				},");
printf("			sync:true,");										//define whether the transaction will be processed synchronously (which would halt all code execution until the transaction is complete
printf("			timeout:15000");									//defined in ms, if this limit is reached but the transaction's 'Complete' event hasn't fired, the txn will abort and fire fail event
printf("		};");//end cfg
printf("		var sUrl = \"%s\";", cgi_server);								//specify the URL of the resource to which we're posting data (in this case, the standard CGI program)
printf("		objResponse = Y.io(sUrl, cfg);");								//initiate the YUI-IO operation, sending our config object (which contains the data) to the CGI program (specified by sUrl above)... response will be in plain text, the way we're doing it now (HTTP response)
printf("	});");
printf("}");//end function getCurrentNativeAppleAppVersion()
*/

/* If loaded in mobile app (specifically iOS webview), enable the ObjC/JavaScript bridge... */
if(0 && isLoadedInMobileApp())
	{
		//once the bridge-logic becomes available (once ObjC uses it? onload??), define what happens...
	printf("document.addEventListener('WebViewJavascriptBridgeReady', function(e){");
	printf("	var bridge = e.bridge;");						//get a reference to the webview-bridge's 'bridge' object
	printf("	FavScreen.log('log',\"BRIDGE: WebViewJavascriptBridge Is Ready (event='\"+e+\"', bridge='\"+bridge+\"').\",true);");

			//initialize the bridge (for receiving?)...
	printf("	bridge.init(function(data, responseCallback){");			//this anonymous function will receive all messages sent from ObjC via [bridge send:(id)data] and [bridge send:(id)data responseCallback:(WVJBResponseCallback)responseCallback]... the responseCallback object will be defined if if ObjC sent the message with a WVJBResponseCallback block.
	printf("		FavScreen.log('log',\"BRIDGE: Received data from ObjC (\"+JSON.stringify(data)+\").\",true);");
	printf("		if(responseCallback){");					//if the ObjC sent the message with a WVJBResponseCallback block... then tell it what it should do
	printf("			FavScreen.log('verbose',\"BRIDGE: Callback specified by ObjC.\",true);");
	printf("			responseCallback(\"Right back atcha!\");");
	printf("		}");//end if
	printf("		});");//end init with anon fxn definition

			//can also send to the ObjC via bridge (even with a callback specified)...
			//bridge.send("Hi there!");
			//bridge.send({ Foo:"Bar" });
			//bridge.send(data, function responseCallback(responseData) { ... });

			//can also register a handler that ObjC can call...
			//bridge.registerHandler("handlerName", function(responseData) { ... });

	printf("	},false);");//end addEventListener for bridge-ready
	}
if(0 && isLoadedInMobileApp())
	{
		//once the bridge-logic becomes available (once ObjC uses it? onload??), define what happens...
	printf("document.addEventListener('WebViewJavascriptBridgeReady', function(e){");
	printf("	var bridge = e.bridge;");						//get a reference to the webview-bridge's 'bridge' object
	printf("	FavScreen.log('log',\"BRIDGE: WebViewJavascriptBridge Is Ready (event='\"+e+\"', bridge='\"+bridge+\"').\",true);");

			//initialize the bridge (for receiving?)...
	printf("	bridge.init(function(data, responseCallback){");			//this anonymous function will receive all messages sent from ObjC via [bridge send:(id)data] and [bridge send:(id)data responseCallback:(WVJBResponseCallback)responseCallback]... the responseCallback object will be defined if if ObjC sent the message with a WVJBResponseCallback block.
	printf("		FavScreen.log('log',\"BRIDGE: Received data from ObjC (\"+JSON.stringify(data)+\").\",true);");
	printf("		if(responseCallback){");					//if the ObjC sent the message with a WVJBResponseCallback block... then tell it what it should do
	printf("			FavScreen.log('verbose',\"BRIDGE: Callback specified by ObjC.\",true);");
	printf("			responseCallback(\"Right back atcha!\");");
	printf("		}");//end if
	printf("		});");//end init with anon fxn definition
	}

/* Setup panels... ************************************************************************************************************/
printf("var Panel_editSubheader_personalLibs;");

printf("var objConfig_Panel_editSubheader_personalLibs;");

printf("function loadPanels(bool_forceReload) {");
printf("	objConfig_Panel_editSubheader_personalLibs = {");
printf("		str_panelDomID : \"panelEditSubheader-personalLibs\",");
//printf("		str_panelDomClassName : \"panelEditSubheader\","); //NOTE: can't figure out how to force YUI-Panel to use this (there's no attribute for it.. just id)
printf("		str_panelTitleText : \"Edit Header\"");
printf("		};");
printf("	Panel_editSubheader_personalLibs = new ClassPanelSubsectionEdit(objConfig_Panel_editSubheader_personalLibs);");
printf("}");

printf("function initializePanels() {");				//routine to initialize the panel instances... (note: this is called initially from a try/catch, so don't worry)
printf("	try {");
printf("		Panel_editSubheader_personalLibs.initialize();");
printf("	}");
printf("	catch(err) {");
printf("		FavScreen.log('error', \"initializePanels(): Caught error: \"+err.message+\".\", true);");
printf("	}");
printf("}");//end function initializeSections()

//printf("loadPanels();");

/* Setup sections... **********************************************************************************************************/
printf("var MajorSection_critical;");					//declare a major-section for critical-msgs
printf("var MajorSection_personalLibs;");				//declare a major-section for personal-libraries
printf("var MajorSection_dropbox;");					//declare a major-section for dropbox-msgs

printf("var objConfig_MajorSection_critical;");				//declare a configuration object for the 'critical' major section
printf("var objConfig_MajorSection_personalLibs;");			//declare a configuration object for the 'personal libraries' major section
printf("var objConfig_MajorSection_dropbox;");				//declare a configuration object for the 'dropbox' major section

printf("function loadSections(bool_forceReload) {");			//routine to actually load them all up... (note: this is called initially from a try/catch, so don't worry)
printf("	var ret = {");
printf("		int_configObjectsExist : 0,");
printf("		int_sectionInstancesExist : 0,");
printf("		int_configObjectsCreated : 0,");
printf("		int_sectionInstancesCreated : 0");
printf("		};");//end ret
printf("	try {");
printf("		bool_forceReload = Boolean(bool_forceReload);");
printf("		FavScreen.log('verbose', \"loadSections(): Value of bool_forceReload is \"+bool_forceReload.toString()+\". Some loading may get skipped.\", true);");

printf("		if(typeof objConfig_MajorSection_critical === 'object') {ret.int_configObjectsExist++;}");
printf("		if(typeof objConfig_MajorSection_personalLibs === 'object') {ret.int_configObjectsExist++;}");
printf("		if(typeof objConfig_MajorSection_dropbox === 'object') {ret.int_configObjectsExist++;}");

printf("		if(typeof MajorSection_critical === 'object') {if(Boolean(MajorSection_critical.bool_isConstructorLoaded)) {ret.int_sectionInstancesExist++;}}");
printf("		if(typeof MajorSection_personalLibs === 'object') {if(Boolean(MajorSection_personalLibs.bool_isConstructorLoaded)) {ret.int_sectionInstancesExist++;}}");
printf("		if(typeof MajorSection_dropbox === 'object') {if(Boolean(MajorSection_dropbox.bool_isConstructorLoaded)) {ret.int_sectionInstancesExist++;}}");

printf("		if(bool_forceReload || typeof objConfig_MajorSection_critical !== 'object') {");//if we need to load from scratch...
printf("			FavScreen.log('verbose', \"loadSections(): Typeof objConfig_MajorSection_critical is '\"+typeof objConfig_MajorSection_critical+\"'. Re/Creating now...\", true);");
printf("			objConfig_MajorSection_critical = {");						//configure the critical-msgs major section...
printf("				str_containerNodeID : \"contentwrapper-critical\",");				//the DOM ID value of the container entitiy in which to put the major section
printf("				str_sectionDomID : \"messagelist-critical\",");					//the DOM ID value to assign to the section-list node
printf("				str_sectionDomClassName : \"\",");						//any additional custom class name(s) to give to the instance (it'll get at least the required default ones, e.g. "messagelist")
printf("				str_sectionTitleText : FAVS_SECTION_TITLE_CRITICAL,");				//the title/header-text to display at the top of the section
printf("				bool_enableRefreshIcon : true,");						//enable the refresh icon (defaults to true)
printf("				objFxn_refreshHandler : function() {");						//define how to do the refresh for this section
printf("					Spinner.show();");
printf("					return refreshRecordset(CURRENT_USER_PIN, true, false, false, true);");
printf("					},");
printf("				bool_enableExpandCollapseIcon : false,");					//enable the expand/collapse toggle icon (defaults to true)
printf("				str_initialExpandCollapse : \"\",");						//specify default starting expanded/collapsed state (defaults to expanded): options are EXPANDED_STATE and COLLAPSED_STATE
printf("				str_baseColor : \"#ffcccc\",");							//the base-color of the section in hex format (defaults to a gray shade)
printf("				objArr_messageData : undefined,");						//NOTE: we intend to use the YUI-RS later, next...
printf("				objYuiRS_messageData : undefined");						//NOTE: will set/re-set this later in recordset operations for rsOrig, etc.
printf("				};");//end config object
printf("			ret.int_configObjectsCreated++;");
printf("		} else {");
printf("			FavScreen.log('verbose', \"loadSections(): Skipped recreation of objConfig_MajorSection_critical.\", true);");
printf("		}");//end if/else
printf("		if(bool_forceReload || typeof objConfig_MajorSection_personalLibs !== 'object') {");//if we need to load from scratch...
printf("			FavScreen.log('verbose', \"loadSections(): Typeof objConfig_MajorSection_personalLibs is '\"+typeof objConfig_MajorSection_personalLibs+\"'. Re/Creating now...\", true);");
printf("			objConfig_MajorSection_personalLibs = {");					//configure the personal-libs major section...
printf("				str_containerNodeID : \"contentwrapper-personallibraries\",");			//the DOM ID value of the container entitiy in which to put the major section
printf("				str_sectionDomID : \"messagelist-personallibraries\",");			//the DOM ID value to assign to the section-list node (note: the main UL node)
printf("				objRef_subheaderEditPanelInstance : Panel_editSubheader_personalLibs,");	//a reference to the subheader-edit-panel instance (WARNING: obviously, this must be instantiated, first, or the reference won't exist!)
printf("				str_sectionDomClassName : \"\",");						//any additional custom class name(s) to give to the instance (it'll get at least the required default ones, e.g. "messagelist")
printf("				str_sectionTitleText : FAVS_SECTION_TITLE_PERSONAL_LIBRARIES,");		//the title/header-text to display at the top of the section
printf("				bool_enableRefreshIcon : true,");						//enable the refresh icon (defaults to true)
printf("				objFxn_refreshHandler : function() {");						//define how to do the refresh for this section
printf("					Spinner.show();");
printf("					return refreshRecordset(CURRENT_USER_PIN, true, false, false, true);");
printf("					},");
printf("				bool_enableExpandCollapseIcon : true,");					//enable the expand/collapse toggle icon (defaults to true)
printf("				str_initialExpandCollapse : \"\",");						//specify default starting expanded/collapsed state (defaults to expanded): options are EXPANDED_STATE and COLLAPSED_STATE
printf("				str_baseColor : \"#ffccff\",");							//the base-color of the section in hex format (defaults to a gray shade)
printf("				objArr_messageData : undefined,");						//NOTE: we intend to use the YUI-RS later, next...
printf("				objYuiRS_messageData : undefined");						//NOTE: will set/re-set this later in recordset operations
printf("				};");//end config object
printf("			ret.int_configObjectsCreated++;");
printf("		} else {");
printf("			FavScreen.log('verbose', \"loadSections(): Skipped recreation of objConfig_MajorSection_personalLibs.\", true);");
printf("		}");//end if/else
printf("		if(bool_forceReload || typeof objConfig_MajorSection_dropbox !== 'object') {");	//if we need to load from scratch...
printf("			FavScreen.log('verbose', \"loadSections(): Typeof objConfig_MajorSection_dropbox is '\"+typeof objConfig_MajorSection_dropbox+\"'. Re/Creating now...\", true);");
printf("			objConfig_MajorSection_dropbox = {");						//configure the dropbox-msgs major section...
printf("				str_containerNodeID : \"contentwrapper-dropbox\",");				//the DOM ID value of the container entitiy in which to put the major section
printf("				str_sectionDomID : \"messagelist-dropbox\",");					//the DOM ID value to assign to the section-list node
printf("				str_sectionDomClassName : \"\",");						//any additional custom class name(s) to give to the instance (it'll get at least the required default ones, e.g. "messagelist")
printf("				str_sectionTitleText : FAVS_SECTION_TITLE_DROPBOX,");				//the title/header-text to display at the top of the section
printf("				bool_enableRefreshIcon : true,");						//enable the refresh icon (defaults to true)
printf("				objFxn_refreshHandler : function() {");						//define how to do the refresh for this section
printf("					Spinner.show();");
printf("					return refreshRecordset(CURRENT_USER_PIN, true, false, false, true);");
printf("					},");
printf("				bool_enableExpandCollapseIcon : true,");					//enable the expand/collapse toggle icon (defaults to true)
printf("				str_initialExpandCollapse : \"\",");						//specify default starting expanded/collapsed state (defaults to expanded): options are EXPANDED_STATE and COLLAPSED_STATE
printf("				str_baseColor : \"#e9dfae\",");							//the base-color of the section in hex format (defaults to a gray shade)
printf("				objArr_messageData : undefined,");						//NOTE: we intend to use the YUI-RS later, next...
printf("				objYuiRS_messageData : undefined");						//NOTE: will set/re-set this later in recordset operations for rsOrig, etc.
printf("				};");//end config object
printf("			ret.int_configObjectsCreated++;");
printf("		} else {");
printf("			FavScreen.log('verbose', \"loadSections(): Skipped recreation of objConfig_MajorSection_dropbox.\", true);");
printf("		}");//end if/else

printf("		if(bool_forceReload || typeof MajorSection_critical !== 'object') {");
printf("			FavScreen.log('verbose', \"loadSections(): Typeof MajorSection_critical is '\"+typeof MajorSection_critical+\"'. Re/Instantiating now...\", true);");
printf("			if(typeof objConfig_MajorSection_critical === 'object' && typeof ClassMajorSection === 'function') {");
printf("				MajorSection_critical = new ClassMajorSection(objConfig_MajorSection_critical);");
printf("				if(typeof MajorSection_critical === 'object') {if(Boolean(MajorSection_critical.bool_isConstructorLoaded)) {ret.int_sectionInstancesCreated++;}}");
printf("			}");
printf("		} else {");
printf("			FavScreen.log('verbose', \"loadSections(): Skipped reinstantiation of MajorSection_critical.\", true);");
printf("		}");
printf("		if(bool_forceReload || typeof MajorSection_personalLibs !== 'object') {");
printf("			FavScreen.log('verbose', \"loadSections(): Typeof MajorSection_personalLibs is '\"+typeof MajorSection_personalLibs+\"'. Re/Instantiating now...\", true);");
printf("			if(typeof objConfig_MajorSection_personalLibs === 'object' && typeof ClassMajorSection === 'function') {");
printf("				MajorSection_personalLibs = new ClassMajorSection(objConfig_MajorSection_personalLibs);");
printf("				if(typeof MajorSection_personalLibs === 'object') {if(Boolean(MajorSection_personalLibs.bool_isConstructorLoaded)) {ret.int_sectionInstancesCreated++;}}");
printf("			}");
printf("		} else {");
printf("			FavScreen.log('verbose', \"loadSections(): Skipped reinstantiation of MajorSection_personalLibs.\", true);");
printf("		}");
printf("		if(bool_forceReload || typeof MajorSection_dropbox !== 'object') {");
printf("			FavScreen.log('verbose', \"loadSections(): Typeof MajorSection_dropbox is '\"+typeof MajorSection_dropbox+\"'. Re/Instantiating now...\", true);");
printf("			if(typeof objConfig_MajorSection_dropbox === 'object' && typeof ClassMajorSection === 'function') {");
printf("				MajorSection_dropbox = new ClassMajorSection(objConfig_MajorSection_dropbox);");
printf("				if(typeof MajorSection_dropbox === 'object') {if(Boolean(MajorSection_dropbox.bool_isConstructorLoaded)) {ret.int_sectionInstancesCreated++;}}");
printf("			}");
printf("		} else {");
printf("			FavScreen.log('verbose', \"loadSections(): Skipped reinstantiation of MajorSection_dropbox.\", true);");
printf("		}");
printf("	}");//end try
printf("	catch(err) {");
printf("		FavScreen.log('error', \"loadSections(): Caught error: \"+err.message+\".\", true);");
printf("	}");
printf("	FavScreen.log('verbose', \"loadSections(): Finished, returning '\"+JSON.stringify(ret)+\"'.\", true);");
printf("	return ret;");
printf("}");//end function loadSections()

printf("function initializeSections() {");				//routine to initialize the major-section instances... (note: this is called initially from a try/catch, so don't worry)
printf("	try {");
printf("		MajorSection_critical.initialize();");
printf("		MajorSection_personalLibs.initialize();");
printf("		MajorSection_dropbox.initialize();");
printf("	}");
printf("	catch(err) {");
printf("		FavScreen.log('error', \"initializeSections(): Caught error: \"+err.message+\".\", true);");
printf("	}");
printf("}");//end function initializeSections()

printf("function renderSections() {");					//routine to actually render the major-section instances... (note: this is called initially from a try/catch, so don't worry)... (note: hopefully all data sources are available by now)
//printf("	MajorSection_critical.renderListInItsSection();");		//NOTE: this is called by initial recordset operations instead
//printf("	MajorSection_personalLibs.renderListInItsSection();");		//NOTE: this is called by initial recordset operations instead
//printf("	MajorSection_dropbox.renderListInItsSection();");		//NOTE: this is called by initial recordset operations instead
printf("}");//end function initializeSections()

printf("</script>");
}//end add_jsPageGlobals()


/***********************************************************************
* static void add_menu(void)
*
*	This function prints the javascript needed to instantiate YUI
*	for the pull-down menu effect.
*
***********************************************************************/
static void add_menu(void)
{
/* Output a static menu structure */
printf("<div id=\"menuwrapper\">");//initially styled display:none in css file
/* Possible types:
 * <li class="yui3-menu-heading">Group Heading</li>
 * <li class="yui3-menu-separator"><!--Separator Line--></li>
 */
printf("	<ul id=\"menulist\">");
printf("		<li class=\"modelaunchable\" label=\"test\"><a href=\"javascript:menuAction_makeChanges()\">Edit</a></li>");//DEV-NOTE: temp for beta test
printf("		<li class=\"yui3-menu-separator\"></li>");
printf("		<li class=\"\">View<ul>");
printf("			<li class=\"modelaunchable\"><a href=\"javascript:menuAction_refresh();\">Refresh</a></li>");
if( strstr(getenv("HTTP_USER_AGENT"), "Firefox") )		//if firefox don't allow show zoom option (firefox doesn't support css zoom)
	{
	printf("		<li class=\"modelaunchable\"><a href=\"javascript:alert('Firefox does not support zoom.')\">Zoom</a></li>");
	}
else
	{
	printf("		<li class=\"modelaunchable\"><a href=\"javascript:zoomControls(ZOOMCONTROLS_SHOW)\">Zoom</a></li>");
	}
if( !strstr(getenv("HTTP_USER_AGENT"), FAVS_APP_USERAGENT) )
	{
	printf("		<li class=\"modelaunchable\"><a href=\"javascript:CreateAlternateSession_oldWayFromFavs(0,0,0,0,0,0)\">Connections</a></li>");
	}
//printf("			<li class=\"modelaunchable\"><a href=\"javascript:menuAction_deletedFavs();\">Deleted Favs</a></li>");//DEV-NOTE: temp for beta test
printf("			<li class=\"modelaunchable modeeditable\"><a href=\"javascript:VersionInfo.showFor(20000)\">Version</a></li>");
printf("			</ul></li>");
//printf("		<li class=\"\">Settings<ul>");

if(DiagnosticCheck(DIAGNOSTIC_FAVORITES_DEBUG))
	{
	printf("	<li class=\"\">DEBUG<ul>");
	//printf("		<li class=\"\"><a href=\"\">Confirm Send</a></li>");
	if( !strstr(getenv("HTTP_USER_AGENT"), "iPod")                // example: Mozilla/5.0 (iPad; CPU OS 7_0_6 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11B651 Safari/9537.53
		&& !strstr(getenv("HTTP_USER_AGENT"), "iPhone")
		&& !strstr(getenv("HTTP_USER_AGENT"), "Android") )    // example: Mozilla/5.0 (Linux; Android 4.2.2; en-us; SAMSUNG SCH-I545 Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Version/1.0 Chrome/18.0.1025.308 Mobile Safari/535.19
		{
		printf("	<li class=\"modelaunchable modeeditable\"><a href=\"javascript:FavScreen.logSaveToFile()\">Save Log to File</a></li>");
		}
	printf("		<li class=\"modelaunchable modeeditable\"><a href=\"javascript:FavScreen.logDumpToConsole()\">Dump Log to Console</a></li>");
	printf("		<li class=\"modelaunchable modeeditable\"><a href=\"javascript:FavScreen.logSaveToServer()\">Send Log to Server</a></li>");
	printf("		<li class=\"yui3-menu-separator\"></li>");
	//printf("		<li class=\"modelaunchable modeeditable\"><a href=\"javascript:forceCssRepaint()\">CSS Repaint</a></li>");
	printf("		<li class=\"modelaunchable modeeditable\"><a href=\"javascript:menuAction_setUserAllFavsConfirm()\">Set All Confirm</a></li>");
	printf("		<li class=\"modelaunchable modeeditable\"><a href=\"javascript:menuAction_resetUserFavPositions()\">Reset Sorting</a></li>");
	printf("		<li class=\"modelaunchable modeeditable\"><a href=\"javascript:menuAction_purgeUserDeletedFavs()\">Purge Deleted</a></li>");
	//printf("		<li class=\"modelaunchable modeeditable\"><a href=\"javascript:menuAction_purgeUserFavRecords()\">Purge All Favs</a></li>");
	printf("		<li class=\"modelaunchable modeeditable\"><a href=\"javascript:menuAction_purgeAllActiveCopyRecnos()\">Purge All Active Copies</a></li>");
	//printf("		<li class=\"modelaunchable modeeditable\"><a href=\"javascript:alert(document.getElementsByName('viewport')[0].getAttribute('content'))\">Show Viewport</a></li>");
	//printf("		<li class=\"modelaunchable modeeditable\"><a href=\"javascript:document.getElementsByName('viewport')[0].setAttribute('content','initial-scale=1,user-scalable=yes,width=device-width,maximum-scale=1.3, minimum-scale=1')\">Reset Viewport</a></li>");
	printf("		</ul></li>");
	}

printf("		<li class=\"yui3-menu-separator\"></li>");
printf("		<li class=\"modelaunchable modeeditable\"><a href=\"%s?loadLoginWindow=NOAUTOLOGIN&SIGNOFF=1&%s=%s\" target=\"_parent\" onClick=\"ClearCookies(); return SetFormStateAndSubmit(%d, 0, 0);\">Sign Off</a></li>", cgi_server, cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin), STATE_LOGOUT);
printf("	</ul>");
printf("	<div class=\"clearfloats\"></div>");
printf("</div>\n");//end #menuwrapper

printf("<script type=\"text/javascript\" async=\"async\" src=\"%s/~silentm/javascripts/favorites/menu.min.js\"></script>", cgi_base);

printf("<script type=\"text/javascript\">");
/* Make the menu object */
printf("var menu_timeoutHideHandle = undefined;");							//initialize a global for holding a handle to a setTimeoutnu shows, so it can be cancelled, if needed
printf("var evtHandle_menuicon_click;");								//declare a global for holding the event listner for the menuicon (so we can reliably attach/detach as needed, whenever, without worrying about event-facades being sandboxed)
printf("YUI(YUI_config).use('gallery-sm-menu', 'event', function(Y){");					//using a YUI-gallery-sm-menu module, and events...
printf("	if(typeof window.document.body.childElementCount===\"number\"){");				//if client can count number of menu items, then use that to dynamically calculate how long menu should remain visible...
printf("		var node_menulist = Y.one(\"#menulist\").getDOMNode();");
printf("		var numberOfMenuItems = node_menulist.childElementCount;");
printf("		var cfg_menuTimeout = numberOfMenuItems * 1800;");					//show menu for this many milliseconds per menu item
printf("	}else{");											//else client cannot easily count menu items, so fall back to static value...
printf("		var cfg_menuTimeout = 10000;");								//configure how long menu stays visible before it automatically hides, in milliseconds
printf("	}");

printf("	FavScreen.menu = new Y.Menu({");								//instantiate a new menu object into our globally-initialized class (this will allow us to easily use the menu from outside of this particular YUI code block)
printf("		container:'#menuwrapper',");
printf("		sourceNode:'#menulist',");			
printf("		hideOnOutsideClick:true");
printf("		});");//end menu instantiation
/*
printf("	FavScreen.menu = new Y.Menu({");
printf("		container:'#menuwrapper',");
printf("		hideOnOutsideClick:true,");
printf("		items:[");										//configure menu items (API-Doc: http://smugmug.github.io/yui-gallery/api/classes/Menu.Item.html  -- also inherites Tree.Node config items: http://yuilibrary.com/yui/docs/api/classes/Tree.Node.html)
printf("			{label:\"Full System\",url:\"javascript:CreateAlternateSession_oldWayFromFavs(0,0,0,0,0,0)\"},");
printf("			{label:\"Refresh\",url:\"javascript:refreshRecordset('%s',true)\"},", CurrentUserPin);
printf("			{type:'separator'},");
printf("			{label:\"Edit Mode\",url:\"javascript:menuAction_makeChanges()\"},");
printf("			{type:'separator'},");
//printf("			{label:\"Sign Off\",url:\"%s?loadLoginWindow=NOAUTOLOGIN&SIGNOFF=1&%s=%s\",onclick:ClearCookies(); return SetFormStateAndSubmit(%d, 0, 0);},", cgi_server, cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin), STATE_LOGOUT);
printf("			{label:\"Sign Off\",url:\"%s?loadLoginWindow=NOAUTOLOGIN&SIGNOFF=1&%s=%s\",id:'menuItem_signOff'},", cgi_server, cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));
printf("			{type:'separator'},");
printf("			{label:\"Development\",children:[");
printf("				{label:\"Version\",url:\"javascript:menuAction_displayVersionInfo()\"},");
printf("				{type:'separator'},");
printf("				{label:\"Dump Log Console\",url:\"javascript:FavScreen.logDumpToConsole()\"},");
printf("				{label:\"Save Log File\",url:\"javascript:FavScreen.logSaveToFile()\"},");
printf("				{type:'separator'},");
printf("				{label:\"Reset Sort Order\",url:\"menuAction_resetUserFavPositions()\"},");
printf("				{label:\"Purge Deleted\",url:\"javascript:menuAction_purgeUserDeletedFavs()\"},");
printf("				{label:\"Purge All Favs\",url:\"javascript:menuAction_purgeUserFavRecords()\"}");
printf("				]}");//end sub-menu items for development
printf("			]");//end menu items
printf("		});");//end menu instantiation
*/
/*DEV-NOTE: customize the menu, based on our current mode...
 * need to go through the menu structure, look at the classes and show/hide from there? Use each()? combined with something the get/set classes? */
printf("	var menuiconAttachClickListener = function(){");						//define a method for attaching an on-click event listener to the menuicon...
printf("		document.getElementById('menuicon').className = \"\";");
printf("		evtHandle_menuicon_click = Y.one('#menuiconwrapper').on('click', function(e){");		//define what happens when the menu icon is actually clicked/tapped
printf("			FavScreen.menu.toggleVisible({anchorPoint:this});");						//toggle the menu's visibility (passing this along as the menu's anchor point ~ where it drops down from)
//printf("			setTimeout(function(){refreshRecordset(\"%s\",true,false,true,false);refreshRecordset_inboxMsgs(\"%s\",false,false);},50);", CurrentUserPin, CurrentUserPin);	//refresh as a timed event, so it won't delay showing the menu after they click/tap the menu icon
printf("			e.stopImmediatePropagation();");								//be extra safe and prevent any other event handlers from firing (e.g. launch/view message)
printf("			e.stopPropagation();");										//be extra safe and prevent any other event handlers from firing (e.g. launch/view message)
printf("			e.preventDefault();");										//be extra safe and prevent any other event handlers from firing (e.g. launch/view message)
printf("			});");
printf("		};");
printf("	var menuiconDetachClickListener = function(){");						//define a method for detaching the menuicon's on-click event listener...
printf("		if(typeof evtHandle_menuicon_click===\"object\"){");						//if event handle is valid...
printf("			evtHandle_menuicon_click.detach();");							//detach it
printf("			evtHandle_menuicon_click = Y.one('#menuiconwrapper').on('click', function(e){");		//define what happens when the menu icon is actually clicked/tapped while it is disabled (need this to prevent any underlying elements from firing)
printf("				e.stopImmediatePropagation();");								//be extra safe and prevent any other event handlers from firing (e.g. launch/view message)
printf("				e.stopPropagation();");										//be extra safe and prevent any other event handlers from firing (e.g. launch/view message)
printf("				e.preventDefault();");										//be extra safe and prevent any other event handlers from firing (e.g. launch/view message)
printf("				});");
printf("		}else{");											//else log a warning...
printf("			FavScreen.log('warn', \"menuiconDetachClickListener(): evtHandle_menuicon_click is not a valid event handle. Nothing to detach.\", true);");
printf("		}");
printf("		};");
printf("	FavScreen.menu.after('visibleChange', function(e){");						//define what happens whenever the menu's visibility changes...
printf("		var node_modalMask = document.getElementsByClassName(\"yui3-widget-mask\")[0];");		//get a reference to the modal mask (which, of course, is provided whenever a YUI-Panel reders)
printf("		var headerwrapperHeight = document.getElementById(\"headerwrapper\").offsetHeight;");		//get the calculated height of the headerwrapper area (including padding, etc.)
printf("		if(!(headerwrapperHeight>0)){headerwrapperHeight=60}");						//if for some reason we didn't get a valid value, then fallback to hard coded assumed height of 60px (this likely will never happen, though)
printf("		if(this.get('visible')){");									//if menu is showing...
printf("			node_modalMask.style.display = \"block\";");							//show the modal mask
printf("			node_modalMask.style.top = headerwrapperHeight+\"px\";");					//position the modal mask so that the header area isn't masked
printf("			menu_timeoutHideHandle = setTimeout(function(){FavScreen.menu.hide();}, cfg_menuTimeout);");	//start a timer to automatically hide the menu after a certain time (specified above)
printf("			FavScreen.log('log', \"Menu visible... Temporarily disabling menuicon click listener.\", false);");
printf("			menuiconDetachClickListener();");								//temporarily disable the menuicon on-click event listener, since hideOnOutsideClick will handle hiding the menu instead
printf("		}else{");											//else menu is not showing...
printf("			clearTimeout(menu_timeoutHideHandle);");							//cancel the automatic hide timeout
printf("			var delay = 600;");										//define the delay (in milliseconds)
printf("			FavScreen.log('log', \"Menu now not visible... Setting a delay (\"+delay+\"ms) for re-enabling menuicon click listener and hiding modal mask...\", false);");
printf("			setTimeout(function(){");									//re-enable the menuicon click event listener after a short delay
printf("				FavScreen.log('log', \"Menu now not visible... Hiding mask layer and re-enabling menuicon click listener.\", false);");
printf("				if(safeToHideModalMask){");	//check for whether or not we should not hide the modal mask (e.g. VersionInfo or some panel may need it)
printf("					FavScreen.log('log', \"  Hiding mask layer (safeToHideModalMask = \"+safeToHideModalMask+\").\", false);");
printf("					var node_modalMask = document.getElementsByClassName(\"yui3-widget-mask\")[0];");		//get a reference to the modal mask (which, of course, is provided whenever a YUI-Panel reders)
printf("					node_modalMask.style.display = \"none\";");							//hide the modal mask
printf("					node_modalMask.style.top = \"0px\";");								//reset the modal mask's original position for masking the entire document
printf("				}");
printf("				FavScreen.log('log', \"  Re-enabling menuicon click listener.\", false);");
printf("				menuiconAttachClickListener();");
printf("				},delay);");										//any shorter than 600ms seems to cause issues with IE
printf("		}");
printf("		});");//end after-visibleChange
printf("	menuiconAttachClickListener();");								//go ahead and attach the initial menuicon on-click event listener
printf("});");//end YUI.use

printf("function menuAction_refresh(){");
if(isLoadedInMobileApp())
	{
	printf("if(parseAppVersionFromUA(\"0\") >= \"%s\"){", FAVS_APP_IOS_VER_CANRELOADDOC);			//if the apple app version supports native document reload, call the function to trigger that instead of merely refresh the recordset data
	printf("	Spinner.show();");									//show the spinner until the native layer can start reloading the HTML document
	printf("	setTimeout(function(){reloadDocument();},600);");					//just to allow a quick bit of time for them to see the spinner so they know something is going to be happening (reloads might take a few seconds)
	printf("}else{");
	printf("	refreshRecordset('%s', true);", CurrentUserPin);					//make sure we have the latest messages data
	printf("	refreshRecordset_inboxMsgs(\"%s\",true,true);", CurrentUserPin);			//make sure we have the latest inbox data
	printf("}");
	}
else
	{
	//printf("checkRestoreFavoritesNode();");
	printf("refreshRecordset('%s', true);", CurrentUserPin);
	printf("refreshRecordset_inboxMsgs(\"%s\",true,true);", CurrentUserPin);				//make sure we have the latest inbox data
	}
printf("}\n");//end function menuAction_refresh()


/* DOESN'T WORK??
printf("function menuAttachListeners(){");
printf("	FavScreen.menu.on('show', function(e){");
printf("		document.getElementsByClassName(\"yui3-widget-mask\")[0].style.display = \"block\";");
printf("		});");//end attach event listener
printf("	FavScreen.menu.on('hide', function(e){");
printf("		document.getElementsByClassName(\"yui3-widget-mask\")[0].style.display = \"none\";");
printf("		});");//end attach event listener
printf("}");
*/

printf("</script>\n");
}//end add_menu()


/***********************************************************************
* static void add_bodyLayoutContents(void)
*
*	This function prints the contents of the "body" node.
*
*	When you call this, it must be inside the "body" element tags.
*	Please note that this uses and depends on CSS! (see printHtml_headContents)
*
***********************************************************************/
static void add_bodyLayoutContents(void)
{
printf("<div id=\"pagewrapper\">");

printf("	<div id=\"headerwrapper\">");

printf("		<div id=\"logowrapper\" onclick=\"javascript:CreateAlternateSession_oldWayFromFavs(0,0,0,0,0,0)\">"); //DEV-NOTE: make clicking this open a new window with the inbox
printf("			<img id=\"logo\" src=\"%s/logobig2.gif\" ></A>", cgi_icons);
//printf("			<div id=\"logotext\">MessageNet Connections</div>");
printf("		</div>");//end #logowrapper

printf("		<div id=\"pagetitlewrapper\" class=\"withsubtitle\">");
//printf("			<span id=\"pagetitle\" onclick=\"javascript:refreshRecordset('%s', true);\">My %s</span>", CurrentUserPin, FAVS_NAME);	//DEV-NOTE: make dynamic (not just "My") -- also change this  ---- also make clicking this refresh the favorites list
//printf("			<span id=\"pagetitle\" onclick=\"javascript:refreshRecordset('%s', true);\">%s</span>", CurrentUserPin, FAVS_NAME);	//DEV-NOTE: make dynamic (not just "My") -- also change this  ---- also make clicking this refresh the favorites list
//printf("			<span id=\"pagetitle\" onclick=\"javascript:if(FavScreen.node_bodywrapper==null||FavScreen.node_bodywrapper==undefined){refreshRecordset('%s',true);}else{restoreSavedNode_fromLegacyIframe();refreshRecordset('%s',true);}\">%s</span>", CurrentUserPin, CurrentUserPin, FAVS_NAME_SHORT);	//DEV-NOTE: make dynamic (not just "My") -- also change this  ---- also make clicking this refresh the favorites list
/*printf("			<span id=\"pagetitle\" onclick=\"javascript:"
					"if(FavScreen.node_bodywrapper===null||FavScreen.node_bodywrapper===undefined){"
						"if(jumpScrollTo('bodywrapperTopAnchor', true, true)){"
							"FavScreen.set('attrJumpScrollToTopLastTimestamp',Date.now());"
						"}"
					"}else{"
						"Popup.hide();"
						"restoreSavedNode_fromLegacyIframe();"				
						"if(ModalNotification_ConnectionLost.isVisible){ModalNotification_ConnectionLost.hide();}"	//if legacy smcgi showed this, hide it now, so the user can continue using the page
						"refreshRecordset('%s',true,false);"
						"refreshRecordset_inboxMsgs('%s',true,false);"
					"}"
					"\">%s</span>", CurrentUserPin, CurrentUserPin, FAVS_NAME_SHORT);	//DEV-NOTE: make dynamic (not just "My") -- also change this  ---- also make clicking this refresh the favorites list
*/
printf("			<span id=\"pagetitle\">%s</span>", FAVS_NAME_SHORT);
printf("			<script type=\"text/javascript\">");
printf("				var handlePageTitleClick = function(e) {");
printf("					FavScreen.log('verbose', \"handlePageTitleClick(): Called by \"+e.type+\"-event at x=\"+e.x+\"/y=\"+e.y+\".\", true);");
printf("					if(FavScreen.node_bodywrapper === null || FavScreen.node_bodywrapper === undefined) {");
printf("						if(jumpScrollTo('bodywrapperTopAnchor', true, true)) {");
printf("							FavScreen.set('attrJumpScrollToTopLastTimestamp',Date.now());");
printf("						}");
printf("					} else {");
printf("						Popup.hide();");
printf("						restoreSavedNode_fromLegacyIframe();");
printf("						if(ModalNotification_ConnectionLost.isVisible){ModalNotification_ConnectionLost.hide();}");	//if legacy smcgi showed this, hide it now, so the user can continue using the page
printf("						refreshRecordset('%s',true,false);", CurrentUserPin);
printf("						refreshRecordset_inboxMsgs('%s',true,false);", CurrentUserPin);
printf("					}");
printf("					};");//end handlePageTitleClick method definition
//printf("				document.getElementById(\"pagetitle\").addEventListener('click',handlePageTitleClick,false);");
printf("				document.getElementById(\"pagetitle\").onclick = handlePageTitleClick;");
printf("			</script>");
printf("			<span id=\"pagesubtitle\">Mobile</span>");
printf("		</div>");//end #pagetitlewrapper

			//NOTE: be careful about modifying this node, its position, and/or its children... because YUI attaches an event listener to the menu icon's IMG node (this node must be loaded on the page before the menu code is loaded)
printf("		<div id=\"menuiconwrapper\">");
printf("			<div id=\"menuicon\" class=\"unavailable\">");
printf("				<div class=\"hamburgerline\"></div>");
printf("				<div class=\"hamburgerline\"></div>");
printf("				<div class=\"hamburgerline\"></div>");
printf("			</div>");
printf("		</div>");//end #menuiconwrapper

/* DEV-NOTE: later functionality?... (already defined in CSS)
printf("		<div id=\"notificationiconwrapper\">");
printf("			<span>[notification icons]</span>");
printf("		</div>");//end #notificationiconwrapper
*/

printf("		<div class=\"clearfloats\"></div>");

printf("		<div id=\"zoomcontrols\" class=\"zoomcontrols\" style=\"display:none;\">");
printf("			<button type=\"button\" onclick=\"javascript:FavScreen.set('attrZoom',this.value)\" value=\"100%%\">100%%</button>");
printf("			<button type=\"button\" onclick=\"javascript:FavScreen.set('attrZoom',this.value)\" value=\"125%%\">125%%</button>");
printf("			<button type=\"button\" onclick=\"javascript:FavScreen.set('attrZoom',this.value)\" value=\"150%%\">150%%</button>");
printf("			<button type=\"button\" onclick=\"javascript:FavScreen.set('attrZoom',this.value)\" value=\"200%%\">200%%</button>");
printf("		</div>");//end #zoomcontrols

printf("	</div>");//end #headerwrapper

/* DEV-NOTE: these are all candidates for being loaded in external JS files? (since they're theoretically only needed after the document loads) */
add_menu();							// Add dynamic/YUI menu stuff, now that we've completed the anchor for it above
add_yuiInstance_favMsgRecordset();				// Create and populate a client-side YUI Recordset object of this user's favorite messages (NOTE: this is a pre-requisite for many/all of the calls below...)
add_yuiInstance_inboxMsgRecordset();				// Create and populate a client-side YUI Recordset object of this user's current inbox messages (if any exist of course)
//add_yuiInstance_librariesObjectAndRecordsets();			// Create and populate a client-side object of available libraries and their messages recordsets (if any exist of course)

printf("	<div id=\"bodywrapper\">");

/*OVERALL LAYOUT...*/
/* 1.  1St  Tap - Jumps after 4 seconds of not being pressed taking the user to the Top of the list.*/ 
/* 2.  2nd Tap - Jumps the user to the top of the Inbox expanded. -- UPDATE 12/5/14: Move inbox down toward bottom */
/* 3.  3rd Tap - Jumps and displays the List of SubList Headers starting at the top.*/
/* 4.  4th Tap - JUMPs the user to the top of the Frequent Msgs with this portion of the list  expanded. */
/* 5.  5rd tap -  Jumps the user to the top of the Recents Msgs list expanded. */
/* 6.  6th tap -  Jumps the user to Top of sortable Favorites list , expanded. */
/* 7.  7th tap -  Jumps the user to the Emergency msgs sub-list expanded. */
/* 8.  8th tap -  Jumps to the Library User sub-list Msgs*/
/* 9.  9th tap -  Jumps to the Users Drop Box of Msgs Which is followed by the Gift Sub-list.*/
/* 10. 10th tap -  Jumps them back to where they were before the first touch took them to the Top. */

//#1 Top of page / main sortable list (FAVS_SORTED_FLAG)
//DEV-NOTE: Migrate this over to be the new "critical" section... "S" should probably just remain as so
	//try using new class?
	//would need to make sure event listeners are right (launch, edit, reply, drag-drop, etc.) -- especially drag and drop?
	//probably do it (at first) in parallel with existing sorted
//printf("		<a name=\"bodywrapperTopAnchor\" id=\"bodywrapperTopAnchor\" class=\"sectionAnchor jumpEligible\"></a>");			//provide anchor that allows us to jump to the very top of the list
//printf("		<div id=\"contentwrapper-critical\" class=\"contentwrapper roundedcorners\" style=\"visibility:hidden;\"></div>");		//note: this div gets populated via DHTML - be wary of modifying its id attribute value
printf("		<a name=\"bodywrapperTopAnchor\" id=\"bodywrapperTopAnchor\" class=\"sectionAnchor jumpEligible\"></a>");			//provide anchor that allows us to jump to the very top of the list
//printf("		<div id=\"contentwrapper-sorted\" class=\"contentwrapper roundedcorners\" style=\"visibility:hidden;\"></div>");		//note: this div gets populated via DHTML - be wary of modifying its id attribute value
printf("		<div id=\"contentwrapper-critical\" class=\"contentwrapper roundedcorners\" style=\"visibility:hidden;\"></div>");		//note: this div gets populated via DHTML - be wary of modifying its id attribute value

//#3 Inbox messages
printf("		<a name=\"bodywrapperInboxAnchor\" id=\"bodywrapperInboxAnchor\" class=\"sectionAnchor jumpEligible\"></a>");			//provide anchor that allows us to jump to the top of the inbox list
printf("		<div id=\"contentwrapper-inbox\" class=\"contentwrapper roundedcorners\" style=\"visibility:hidden;\"></div>");			//note: this div gets populated via DHTML - be wary of modifying its id attribute value

//#4 Frequently-used msgs
//
//printf("		<a name=\"bodywrapperFrequentlyUsedAnchor\" id=\"bodywrapperFrequentlyUsedAnchor\" class=\"sectionAnchor\"></a>");	//provide anchor that allows us to jump to the top of the frequently-used list
//printf("		<div id=\"contentwrapper-frequentlyused\" class=\"contentwrapper roundedcorners\" style=\"visibility:hidden;\"></div>");	//note: this div gets populated via DHTML - be wary of modifying its id attribute value

//#5 Recently-used msgs
//
//printf("		<a name=\"bodywrapperInboxAnchor\" id=\"bodywrapperInboxAnchor\" class=\"sectionAnchor\"></a>");			//provide anchor that allows us to jump to the top of the inbox list

//#6 Favorite msgs
//
//printf("		<a name=\"bodywrapperInboxAnchor\" id=\"bodywrapperInboxAnchor\" class=\"sectionAnchor\"></a>");			//provide anchor that allows us to jump to the top of the inbox list

//#7 Emergency msgs
//
//printf("		<a name=\"bodywrapperInboxAnchor\" id=\"bodywrapperInboxAnchor\" class=\"sectionAnchor\"></a>");			//provide anchor that allows us to jump to the top of the inbox list

//#2 User's personal libraries (FAVS_LIBRARY_PERSONAL_FLAG)
printf("		<a name=\"bodywrapperPersonalLibsAnchor\" id=\"bodywrapperPersonalLibsAnchor\" class=\"sectionAnchor jumpEligible\"></a>");	//provide anchor that allows us to jump to the top of the sublist header list/directory
printf("		<div id=\"contentwrapper-personallibraries\" class=\"contentwrapper roundedcorners\" style=\"visibility:hidden;\"></div>");	//note: this div gets populated via DHTML - be wary of modifying its id attribute value

//#8 Library-user's msgs (FAVS_LIBRARY_FLAG)
printf("		<a name=\"bodywrapperLibrariesAnchor\" id=\"bodywrapperLibrariesAnchor\" class=\"sectionAnchor jumpEligible\"></a>");		//provide anchor that allows us to jump to the top of the libraries list
printf("		<div id=\"contentwrapper-libraries\" class=\"contentwrapper roundedcorners\" style=\"visibility:hidden;\"></div>");		//note: this div gets populated via DHTML - be wary of modifying its id attribute value

//#9 New/Unsorted/Dropbox (FAVS_UNSORTED_FLAG)
printf("		<a name=\"bodywrapperDropboxAnchor\" id=\"bodywrapperDropboxAnchor\" class=\"sectionAnchor jumpEligible\"></a>");		//provide anchor that allows us to jump to the top of the Aux-1 list
//printf("		<div id=\"contentwrapper-aux1\" class=\"contentwrapper roundedcorners\" style=\"visibility:hidden;\"></div>");			//note: this div gets populated via DHTML - be wary of modifying its id attribute value
printf("		<div id=\"contentwrapper-dropbox\" class=\"contentwrapper roundedcorners\" style=\"visibility:hidden;\"></div>");		//note: this div gets populated via DHTML - be wary of modifying its id attribute value

//Removed msgs (formerly "deleted")
//FAVS_REMOVED_FLAG | FAVS_DELETED_FLAG
//printf("		<a name=\"bodywrapperRemovedAnchor\" id=\"bodywrapperRemovedAnchor\" class=\"sectionAnchor jumpEligible\"></a>");	//provide anchor that allows us to jump to the top of the removed-msgs list
//printf("		<div id=\"contentwrapper-removed\" class=\"contentwrapper roundedcorners\"></div>");					//note: this div gets populated via DHTML - be wary of modifying its id attribute value

printf("	</div>");//end #bodywrapper

printf("	<div id=\"footerwrapper\" style=\"display:none\"></div>");
//		+-[#footerwrapper]-----+
//		| ----  ----  __       |
//		|  /\    /\  \  /  /\  |
//		|  /\   /  \  \/  /__\ |
//		|  --    --            |
//		+----------------------+
//
//		+-[div#footerwrapper]-------------------------------------------------------------------------------------+
//		| +-[div#jumpnavwrapper]--------------------------------------------------------------------------------+ |
//		| | +-[span.jumpnavbutton]-+ +-[span.jumpnavbutton]-+ +-[span.jumpnavbutton]-+ +-[span.jumpnavbutton]-+ | |
//		| | |        [img]         | |        [img]         | |        [img]         | |        [img]         | | |
//		| | +----------------------+ +----------------------+ +----------------------+ +----------------------+ | |
//		| +-----------------------------------------------------------------------------------------------------+ |
//		+---------------------------------------------------------------------------------------------------------+
printf("<script type=\"text/javascript\">");
printf("	cfg_scrollDirectionNormal = false;");
printf("	Math.easeInOutQuad = function (t, b, c, d) {");			//add a light-weight ease-in/out method to the Math library (t=current time, b=start value, c=change in value, d=duration)
printf("		t /= d/2;");
printf("		if (t < 1) return c/2*t*t + b;");
printf("		t--;");
printf("		return -c/2 * (t*(t-2) - 1) + b;");
printf("		};");
printf("	function scrollTo_animated(element, to, duration, boolPreservePrevScrollPos) {");//make a custom scrollTo that appears animated (without all the external CSS or JS frameworks)
//printf("		var start = element.scrollTop;");
printf("		var start = element.scrollTop || element.parentNode.scrollTop;");	//so firefox doesn't animate the scroll from the very top (since it gets 0 from element.scrollTop)
//printf("		var zoomFactor = parseInt(FavScreen.get('attrZoom'))/100;");
printf("		var zoomFactor = 1;");
printf("		if(FavScreen.get('attrJumpNavMode') === MODE_JUMPNAV_UP) {");
printf("			to = to;");	//for some reason, going up doesn't require the offset that going-down does
printf("		}");
printf("		else {");
printf("			to = to - 10;");//apply offset, since we added pixel space of pagetitle bottom padding (initially did this to allow header elements to be tapped)
printf("		}");
printf("		var change = (to * zoomFactor) - start;");
printf("		var currentTime = 0;");
printf("		var increment = 20;");						//seems to be a good all-around interval... any faster (lower) may kill CPU, any slower (higher) may not appear smooth enough
printf("		duration = increment * Math.round(duration/increment);");	//ensure duration is rounded to the nearest factor of increment's value (so scroll increments are missed)
printf("		if( FavScreen.get('attrInteractionMode') != MODE_REPLYING");
printf("		 && Boolean(boolPreservePrevScrollPos == false) ){");
printf("			FavScreen.set('attrPreviousScrollPositionPixelY', FavScreen.get('attrCurrentScrollPositionPixelY'));");//save the current scroll position before we change it
printf("		}");
printf("		var animateScroll = function() {");
printf("			currentTime += increment;");
printf("			var val = Math.easeInOutQuad(currentTime, start, change, duration);");	//do the ease-in/out magic
//printf("			element.scrollTop = val;");						//do the actual scroll (note: doesn't work in firefox due to disagreement in HTML-spec meaning: https://miketaylr.com/posts/2014/11/document-body-scrollTop.html)
printf("			element.scrollTop = element.parentNode.scrollTop = val;");		//do the actual scroll (note: doesn't work in firefox due to disagreement in HTML-spec meaning: https://miketaylr.com/posts/2014/11/document-body-scrollTop.html)
printf("			if(currentTime < duration) {");						//if we still have time remaining in our duration...
printf("				setTimeout(animateScroll, increment);");				//recurse
printf("			}");
printf("			};");
printf("		animateScroll();");
printf("	}");
printf("	function updateJumpNavIconsForMode(strMode) {");
//printf("		var strClassNameForRotation180 = 'rotated180 green';");	//just match what's in the CSS file (since loaded images are pointing down, 180 means pointing up) 		-- for mask image method
//printf("		var strClassNameForRotation0 = 'rotated0 yellow';");	//just match what's in the CSS file (since loaded images are pointing down, 0 means no rotational change) 	-- for mask image method
printf("		var strClassNameForRotation180 = 'rotated180';");	//just match what's in the CSS file (since loaded images are pointing down, 180 means pointing up) 		-- for static image method
printf("		var strClassNameForRotation0 = 'rotated0';");		//just match what's in the CSS file (since loaded images are pointing down, 0 means no rotational change) 	-- for static image method
printf("		var arrNodes = document.getElementById('jumpnavwrapper').getElementsByClassName('jumpnavbutton');");
printf("		switch(strMode) {");
printf("			case MODE_JUMPNAV_DOWN:");			//default image state is down, so just remove the rotation style (also, if static image method, need to background-image src)
printf("				for(var i=0; i<arrNodes.length; i++) {");		//for each of the button-nodes...
printf("					if(arrNodes[i].id == 'btnA') {");
printf("						arrNodes[i].style.backgroundImage = \"url(\"+preloadedJumpNavButtonImage_btnA_down.src+\")\";");	//should be yellow-down now
printf("					}");
printf("					if(arrNodes[i].id == 'btnB') {");
printf("						arrNodes[i].style.backgroundImage = \"url(\"+preloadedJumpNavButtonImage_btnB_down.src+\")\";");	//should be yellow-down now
printf("					}");
printf("					if(arrNodes[i].id == 'btnC') {");
printf("						arrNodes[i].style.backgroundImage = \"url(\"+preloadedJumpNavButtonImage_btnC_yellow.src+\")\";");	//should be yellow now, not white
printf("					}");
printf("					if(arrNodes[i].id == 'btnD') {");
printf("						arrNodes[i].style.backgroundImage = \"url(\"+preloadedJumpNavButtonImage_btnD_white.src+\")\";");	//should be white now, not green
printf("					}");
printf("					if(arrNodes[i].className.indexOf('affectedbyjumpnavmode') > -1) {");	//if this image-icon is in an eligible container, flip it back to its natural state by removing the rotation class
printf("						if(arrNodes[i].className.indexOf(strClassNameForRotation180) > -1) {");	//if rotated class exists, we'll need to replace it with non-rotated class (else, no need to do anything, as default images are already same as rotated-0)
printf("							arrNodes[i].className = arrNodes[i].className.replace(strClassNameForRotation180, strClassNameForRotation0);");
printf("						}");
printf("					}");
printf("				}");
printf("				break;");
printf("			case MODE_JUMPNAV_UP:");			//default image state is down, so apply the rotation style to appear up
printf("				FavScreen.log('log',\"updateJumpNavIconsForMode(): Using strMode = '\"+strMode+\"'.\",true);");
printf("				for(var i=0; i<arrNodes.length; i++) {");		//for each of the button-nodes...
printf("					if(arrNodes[i].id == 'btnA') {");
printf("						arrNodes[i].style.backgroundImage = \"url(\"+preloadedJumpNavButtonImage_btnA_up.src+\")\";");		//should be green-up now
printf("					}");
printf("					if(arrNodes[i].id == 'btnB') {");
printf("						arrNodes[i].style.backgroundImage = \"url(\"+preloadedJumpNavButtonImage_btnB_up.src+\")\";");		//should be green-up now
printf("					}");
printf("					if(arrNodes[i].id == 'btnC') {");
printf("						arrNodes[i].style.backgroundImage = \"url(\"+preloadedJumpNavButtonImage_btnC_white.src+\")\";");	//should be white now, not yellow
printf("					}");
printf("					if(arrNodes[i].id == 'btnD') {");
printf("						arrNodes[i].style.backgroundImage = \"url(\"+preloadedJumpNavButtonImage_btnD_green.src+\")\";");	//should be green now, not white
printf("					}");
printf("					if(arrNodes[i].className.indexOf('affectedbyjumpnavmode') > -1) {");	//if this image-icon is in an eligible container, flip it by applying the rotation class
printf("						if(arrNodes[i].className.indexOf(strClassNameForRotation0) > -1) {");	//if non-rotated class exists, we'll need to replace it with rotated class
printf("							arrNodes[i].className = arrNodes[i].className.replace(strClassNameForRotation0, strClassNameForRotation180);");
printf("						}else{");
printf("							arrNodes[i].className = arrNodes[i].className + ' ' + strClassNameForRotation180;");
printf("						}");
printf("					}");
printf("				}");
printf("				break;");
printf("			default:");
printf("				FavScreen.log('warn',\"updateJumpNavIconsForMode(): Unknown strMode value (\"+strMode+\").\",true);");
printf("				break;");
printf("		}");
printf("	}");
printf("	function getAnchorDataByClass(strClassName) {");	// Returns an array of data objects (like: [{},{},...] ) for anchor-nodes and their positional data
printf("		if(typeof strClassName !== 'string') {");
printf("			FavScreen.log('error','getAnchorDataByClass(): Required parameter not specified, aborting.',true);");
printf("			return false;");
printf("		}");
printf("		var ret = [];");								//initialize a return value
printf("		var arrAnchorNodes = document.getElementsByClassName(strClassName);");		//get a list of section anchors on the page (hopefully they're in the same order as what the user sees on-screen, ideally)
printf("		var numOfAnchorNodes = arrAnchorNodes.length;");
printf("		var o;");
printf("		for(var i=0; i<numOfAnchorNodes; i++) {");					//for each section anchor found, go through and construct a data object to put into the returned array
printf("			o = {");
printf("				anchorDomId : arrAnchorNodes[i].id");
printf("				,anchorDomName : arrAnchorNodes[i].name");
//printf("				,anchorPosY : arrAnchorNodes[i].offsetTop");
printf("				,anchorPosY : arrAnchorNodes[i].offsetTop * (parseInt(FavScreen.get('attrZoom'))/100)");
printf("				,anchorPosYNext : undefined");
printf("				,anchorPosYPrev : undefined");
printf("				};");
printf("			if(i == 0) {");									//if we're at the first anchor node, need to set any 'prev' values since they would result in array out of bounds if we did i-1
printf("				o.anchorPosYPrev = o.anchorPosY;");						//note: can't use document.getElementById('bodywrapper').offsetTop, since it would report 60 (due to moving it down because of headerwrapper) / can't do 0 since that may be higher than first node's calculated position (due to CSS quirks)
//printf("				o.anchorPosYNext = arrAnchorNodes[i+1].offsetTop;");
printf("				o.anchorPosYNext = arrAnchorNodes[i+1].offsetTop * (parseInt(FavScreen.get('attrZoom'))/100);");
printf("			}");
printf("			else if(i == numOfAnchorNodes - 1) {");						//if we're at the last anchor node, need to set any 'next' values since they would result in array out of bounds if we did i+1
//printf("				o.anchorPosYPrev = arrAnchorNodes[i-1].offsetTop;");
printf("				o.anchorPosYPrev = arrAnchorNodes[i-1].offsetTop * (parseInt(FavScreen.get('attrZoom'))/100);");
printf("				o.anchorPosYNext = o.anchorPosY;");						//just set the next equal to the current
printf("			}");
printf("			else {");									//else we should be somewhere in the meaty middle of the array, so our -1 and +1 on i should be valid
//printf("				o.anchorPosYPrev = arrAnchorNodes[i-1].offsetTop;");
printf("				o.anchorPosYPrev = arrAnchorNodes[i-1].offsetTop * (parseInt(FavScreen.get('attrZoom'))/100);");
//printf("				o.anchorPosYNext = arrAnchorNodes[i+1].offsetTop;");
printf("				o.anchorPosYNext = arrAnchorNodes[i+1].offsetTop * (parseInt(FavScreen.get('attrZoom'))/100);");
printf("			}");
printf("			ret.push(o);");									//add this completed object as a new element in the array
printf("		}");
printf("		return ret;");									//return the completed array of objects
printf("	}");
printf("	function flashHeaderWrapper(strCssColor) {");
printf("		n = document.getElementById('headerwrapper');");
printf("		n.style.backgroundColor = strCssColor;");
printf("		setTimeout( function() {");
printf("			n.style.backgroundColor = '';");		//this needs to be an explicit value like this, to prevent rapid calls from locking in the color provided in the previous call's argument
printf("			}, 300);");
printf("		setTimeout( function() {");
printf("			n.style.backgroundColor = strCssColor;");
printf("			}, 300*2);");
printf("		setTimeout( function() {");
printf("			n.style.backgroundColor = '';");		//this needs to be an explicit value like this, to prevent rapid calls from locking in the color provided in the previous call's argument
printf("			}, 300*3);");
printf("	}");
printf("	function flashFooterWrapper(strCssColor) {");
printf("		n = document.getElementById('footerwrapper');");
printf("		n.style.backgroundColor = strCssColor;");
printf("		setTimeout( function() {");
printf("			n.style.backgroundColor = '';");		//this needs to be an explicit value like this, to prevent rapid calls from locking in the color provided in the previous call's argument
printf("			}, 300);");
printf("		setTimeout( function() {");
printf("			n.style.backgroundColor = strCssColor;");
printf("			}, 300*2);");
printf("		setTimeout( function() {");
printf("			n.style.backgroundColor = '';");		//this needs to be an explicit value like this, to prevent rapid calls from locking in the color provided in the previous call's argument
printf("			}, 300*3);");
printf("	}");
printf("	var handleJumpNav_atLimit = false;");				//flag for knowing when we've hit the top or bottom limit
printf("	function handleJumpNavButtonAction_btnA() {");	//section jumping (HTML anchors, definitely)
printf("		var cm = FavScreen.get('attrJumpNavMode');");				//get the current mode for jump-scroll
printf("		var ad = getAnchorDataByClass(\"sectionAnchor\");");			//get an array of objects representing the anchors and any relevant data about those anchors
printf("		var currPosY = FavScreen.get('attrCurrentScrollPositionPixelY');");	//get the current scroll position (DEV-NOTE: in case this doesn't update fast enough, may need to get current position natively here instead?)
printf("		var nextAnchorPosY, prevAnchorPosY;");					//declare some vars that'll get used in the loops further below
//printf("		ad.sort(function(a,b) {");						//sort the array by ascending pixel position
//printf("			var aval = a.anchorPosY;");
//printf("			var bval = b.anchorPosY;");
//printf("			if (aval < bval) return -1;");
//printf("			if (aval > bval) return 1;");
//printf("			return 0;");
//printf("			});");//end ad.sort
printf("		if(cm === MODE_JUMPNAV_UP) {");						//if current mode is up, scroll to previous section
printf("			var cfg_scrollFudgeAmount = 7;");					//for some reason (yet unknown), doing the scroll doesn't always get us exactly to the specified pixel position
printf("			currPosY = currPosY - cfg_scrollFudgeAmount;");				//for some reason (yet still), iOS needs a bit more fudging
printf("			if(currPosY<=0) {");							//if we're now scrolled all the way to the top...
printf("				if(handleJumpNav_atLimit) {");						//if a we've been flagged at the limit (meaning that a previous button press resulted in being at the top), we should now wrap around
printf("					scrollTo_animated(document.body, ad[ad.length-1].anchorPosY, 150);");	//"wrap around" by jumping to the last major section
printf("					handleJumpNav_atLimit = false;");					//reset flag
printf("					return;");
printf("				}");
printf("				else {");
printf("					flashHeaderWrapper('gray');");						//flash the header
printf("					handleJumpNav_atLimit = true;");					//set flag, so next button press can wrap around
printf("				}");
printf("			}");
printf("			for(var i=0; i<ad.length; i++) {");					//looping through the list of anchors available on the page, to determine our whereabouts, take appropriate scrolling action...
printf("				thisAnchorID = ad[i].anchorDomId;");
printf("				thisAnchorPosY = ad[i].anchorPosY;");
printf("				prevAnchorPosY = ad[i].anchorPosYPrev;");
printf("				nextAnchorPosY = ad[i].anchorPosYNext;");
printf("				if((currPosY>thisAnchorPosY) && (currPosY<=nextAnchorPosY)) {");//if we're currently within this section, jump to the top of it (and break out since we're done with this button-press' event)
printf("					FavScreen.log('log',\"handleJumpNavButtonAction_btnA(): Currently within the section anchored by '\"+thisAnchorID+\"', jumping to the top of it @ \"+thisAnchorPosY+\"-\"+cfg_scrollFudgeAmount+\").\",true);");
printf("					scrollTo_animated(document.body, thisAnchorPosY-cfg_scrollFudgeAmount, 150);");
printf("					break;");
printf("				}");
printf("				if(currPosY==thisAnchorPosY) {");				//if we're currently at the top of this section, jump to the previous one (and break out since we're done with this button-press' event)
printf("					FavScreen.log('log',\"handleJumpNavButtonAction_btnA(): Currently at the top of the section anchored by '\"+thisAnchorID+\"', jumping to the top of the previous anchor @ \"+prevAnchorPosY+\"-\"+cfg_scrollFudgeAmount+\").\",true);");
printf("					scrollTo_animated(document.body, prevAnchorPosY-cfg_scrollFudgeAmount, 150);");
printf("					break;");
printf("				}");
printf("				if((currPosY>thisAnchorPosY) && (thisAnchorPosY==nextAnchorPosY)) {");//if we're currently within this section, but also at the last section and scrolled down into extra bodywrapper area, jump to the top of section (and break out since we're done with this button-press' event)
printf("					FavScreen.log('log',\"handleJumpNavButtonAction_btnA(): Currently within the section anchored by '\"+thisAnchorID+\"' (final section?), but perhaps scrolled down into extra bodywrapper padding area, so jumping to the top of it @ \"+thisAnchorPosY+\"-\"+cfg_scrollFudgeAmount+\").\",true);");
printf("					scrollTo_animated(document.body, thisAnchorPosY-cfg_scrollFudgeAmount, 150);");
printf("					break;");
printf("				}");
printf("			}");
printf("		}");
printf("		else if(cm === MODE_JUMPNAV_DOWN) {");					//else if current mode is down, scroll to next section
printf("			var cfg_scrollFudgeAmount = 14;");					//for some reason (yet unknown), doing the scroll doesn't always get us exactly to the specified pixel position
printf("			currPosY = currPosY + cfg_scrollFudgeAmount;");				//for some reason (yet still), iOS needs a bit more fudging
//printf("			var positionOfTopOfBottomMostPagination = document.getElementById('bodywrapper').clientHeight - (FavScreen.get('attrBodyWrapperHeight') + FavScreen.get('attrHeaderWrapperHeight') + parseInt(window.getComputedStyle(document.getElementById('bodywrapper'),null).getPropertyValue('padding-bottom'))*2);");
//printf("			var positionOfTopOfBottomMostPagination = document.getElementById('bodywrapper').clientHeight - (FavScreen.get('attrBodyWrapperHeight') + FavScreen.get('attrHeaderWrapperHeight') + parseInt(window.getComputedStyle(document.getElementById('bodywrapper'),null).getPropertyValue('padding-bottom'))*(parseInt(FavScreen.get('attrZoom'))/100));");
printf("			var positionOfTopOfBottomMostPagination = ad[ad.length-1].anchorPosY;");
printf("			if(currPosY >= positionOfTopOfBottomMostPagination - cfg_scrollFudgeAmount) {");//if we're scrolled all the way to the bottom, change mode to up
printf("				if(handleJumpNav_atLimit) {");						//if a we've been flagged at the limit (meaning that a previous button press resulted in being at the bottom), we should now wrap around
printf("					scrollTo_animated(document.body, -67, 150);");
printf("					handleJumpNav_atLimit = false;");					//reset flag
printf("				}");
printf("				else {");
printf("					flashHeaderWrapper('gray');");						//flash the footer
printf("					handleJumpNav_atLimit = true;");					//set flag, so next button press can wrap around
printf("				}");
printf("			}");
printf("			for(var i=0; i<ad.length; i++) {");					//looping through the list of anchors available on the page, to determine our whereabouts, take appropriate scrolling action...
printf("				thisAnchorID = ad[i].anchorDomId;");
printf("				thisAnchorPosY = ad[i].anchorPosY;");
printf("				prevAnchorPosY = ad[i].anchorPosYPrev;");
printf("				nextAnchorPosY = ad[i].anchorPosYNext;");
printf("				if((currPosY<nextAnchorPosY) && (currPosY>=thisAnchorPosY)) {");//if we're currently within this section, jump to the next one (and break out since we're done with this button-press' event)
printf("					FavScreen.log('log',\"handleJumpNavButtonAction_btnA(): Currently within the section anchored by '\"+thisAnchorID+\"', jumping to next anchor @ \"+nextAnchorPosY+\").\",true);");
printf("					scrollTo_animated(document.body, nextAnchorPosY, 150);");
printf("					break;");
printf("				}");
printf("				if(currPosY==thisAnchorPosY) {");				//if we're currently at the top of this section, jump to the next one (and break out since we're done with this button-press' event)
printf("					FavScreen.log('log',\"handleJumpNavButtonAction_btnA(): Currently at the top of the section anchored by '\"+thisAnchorID+\"', jumping to next anchor @ \"+nextAnchorPosY+\").\",true);");
printf("					scrollTo_animated(document.body, nextAnchorPosY, 150);");
printf("					break;");
printf("				}");
printf("			}");
printf("		}");
printf("		else {");	//error in FavScreen class attributes
printf("			FavScreen.log('error',\"handleJumpNavButtonAction_btnA(): Could not determine or invalid current jump mode attribute (attrJumpNavMode) value from FavScreen class ('\"+cm+\"'), not jumping.\",true);");
printf("		}");
printf("	}");
printf("	function handleJumpNavButtonAction_btnB() {");	//sub-section jumping (HTML anchors??)
printf("		var cm = FavScreen.get('attrJumpNavMode');");				//get the current mode for jump-scroll
printf("		var ad = getAnchorDataByClass(\"jumpEligible\");");			//get an array of objects representing the anchors and any relevant data about those anchors
printf("		var currPosY = FavScreen.get('attrCurrentScrollPositionPixelY');");	//get the current scroll position (DEV-NOTE: in case this doesn't update fast enough, may need to get current position natively here instead?)
printf("		var nextAnchorPosY, prevAnchorPosY;");					//declare some vars that'll get used in the loops further below
printf("		if(cm === MODE_JUMPNAV_UP) {");						//if current mode is up, scroll to previous section
printf("			var cfg_scrollFudgeAmount = 7;");					//for some reason (yet unknown), doing the scroll doesn't always get us exactly to the specified pixel position
printf("			currPosY = currPosY - cfg_scrollFudgeAmount;");				//for some reason (yet still), iOS needs a bit more fudging
printf("			if(currPosY<=0) {");							//if we're scrolled all the way to the top, change mode to down
printf("				if(handleJumpNav_atLimit) {");						//if a we've been flagged at the limit (meaning that a previous button press resulted in being at the top), we should now wrap around
printf("					scrollTo_animated(document.body, ad[ad.length-1].anchorPosY, 150);");	//"wrap around" by jumping to the last minor or major section
printf("					handleJumpNav_atLimit = false;");					//reset flag
printf("					return;");
printf("				}");
printf("				else {");
printf("					flashHeaderWrapper('gray');");						//flash the header
printf("					handleJumpNav_atLimit = true;");					//set flag, so next button press can wrap around
printf("				}");
printf("			}");
printf("			for(var i=0; i<ad.length; i++) {");					//looping through the list of anchors available on the page, to determine our whereabouts, take appropriate scrolling action...
printf("				thisAnchorID = ad[i].anchorDomId;");
printf("				thisAnchorPosY = ad[i].anchorPosY;");
printf("				prevAnchorPosY = ad[i].anchorPosYPrev;");
printf("				nextAnchorPosY = ad[i].anchorPosYNext;");
printf("				if((currPosY>thisAnchorPosY) && (currPosY<=nextAnchorPosY)) {");//if we're currently within this section, jump to the top of it (and break out since we're done with this button-press' event)
printf("					FavScreen.log('log',\"handleJumpNavButtonAction_btnB(): Currently within the section anchored by '\"+thisAnchorID+\"', jumping to the top of it @ \"+thisAnchorPosY+\"-\"+cfg_scrollFudgeAmount+\").\",true);");
printf("					scrollTo_animated(document.body, thisAnchorPosY-cfg_scrollFudgeAmount, 150);");
printf("					break;");
printf("				}");
printf("				if(currPosY==thisAnchorPosY) {");				//if we're currently at the top of this section, jump to the previous one (and break out since we're done with this button-press' event)
printf("					FavScreen.log('log',\"handleJumpNavButtonAction_btnB(): Currently it the top of the section anchored by '\"+thisAnchorID+\"', jumping to the top of the previous anchor @ \"+prevAnchorPosY+\"-\"+cfg_scrollFudgeAmount+\").\",true);");
printf("					scrollTo_animated(document.body, prevAnchorPosY-cfg_scrollFudgeAmount, 150);");
printf("					break;");
printf("				}");
printf("				if((currPosY>thisAnchorPosY) && (thisAnchorPosY==nextAnchorPosY)) {");//if we're currently within this section, but also at the last section and scrolled down into extra bodywrapper area, jump to the top of section (and break out since we're done with this button-press' event)
printf("					FavScreen.log('log',\"handleJumpNavButtonAction_btnB(): Currently within the section anchored by '\"+thisAnchorID+\"' (final section?), but perhaps scrolled down into extra bodywrapper padding area, so jumping to the top of it @ \"+thisAnchorPosY+\"-\"+cfg_scrollFudgeAmount+\").\",true);");
printf("					scrollTo_animated(document.body, thisAnchorPosY-cfg_scrollFudgeAmount, 150);");
printf("					break;");
printf("				}");
printf("			}");
printf("		}");
printf("		else if(cm === MODE_JUMPNAV_DOWN) {");					//else if current mode is down, scroll to next section
printf("			var cfg_scrollFudgeAmount = 14;");					//for some reason (yet unknown), doing the scroll doesn't always get us exactly to the specified pixel position
printf("			currPosY = currPosY + cfg_scrollFudgeAmount;");				//for some reason (yet still), iOS needs a bit more fudging
//printf("			var positionOfTopOfBottomMostPagination = document.getElementById('bodywrapper').clientHeight - (FavScreen.get('attrBodyWrapperHeight') + FavScreen.get('attrHeaderWrapperHeight') + parseInt(window.getComputedStyle(document.getElementById('bodywrapper'),null).getPropertyValue('padding-bottom'))*2);");
//printf("			var positionOfTopOfBottomMostPagination = document.getElementById('bodywrapper').clientHeight - (FavScreen.get('attrBodyWrapperHeight') + FavScreen.get('attrHeaderWrapperHeight') + parseInt(window.getComputedStyle(document.getElementById('bodywrapper'),null).getPropertyValue('padding-bottom'))*(parseInt(FavScreen.get('attrZoom'))/100));");
printf("			var positionOfTopOfBottomMostPagination = ad[ad.length-1].anchorPosY;");
printf("			if(currPosY >= positionOfTopOfBottomMostPagination - cfg_scrollFudgeAmount) {");//if we're scrolled all the way to the bottom, change mode to up
printf("				if(handleJumpNav_atLimit) {");						//if a we've been flagged at the limit (meaning that a previous button press resulted in being at the bottom), we should now wrap around
printf("					scrollTo_animated(document.body, -67, 150);");
printf("					handleJumpNav_atLimit = false;");					//reset flag
printf("				}");
printf("				else {");
printf("					flashHeaderWrapper('gray');");						//flash the footer
printf("					handleJumpNav_atLimit = true;");					//set flag, so next button press can wrap around
printf("				}");
printf("			}");
printf("			for(var i=0; i<ad.length; i++) {");					//looping through the list of anchors available on the page, to determine our whereabouts, take appropriate scrolling action...
printf("				thisAnchorID = ad[i].anchorDomId;");
printf("				thisAnchorPosY = ad[i].anchorPosY;");
printf("				prevAnchorPosY = ad[i].anchorPosYPrev;");
printf("				nextAnchorPosY = ad[i].anchorPosYNext;");
printf("				if((currPosY<nextAnchorPosY) && (currPosY>=thisAnchorPosY)) {");//if we're currently within this section, jump to the next one (and break out since we're done with this button-press' event)
printf("					FavScreen.log('log',\"handleJumpNavButtonAction_btnB(): Currently within the section anchored by '\"+thisAnchorID+\"', jumping to next anchor @ \"+nextAnchorPosY+\").\",true);");
printf("					scrollTo_animated(document.body, nextAnchorPosY, 150);");
printf("					break;");
printf("				}");
printf("				if(currPosY==thisAnchorPosY) {");				//if we're currently at the top of this section, jump to the next one (and break out since we're done with this button-press' event)
printf("					FavScreen.log('log',\"handleJumpNavButtonAction_btnB(): Currently at the top of the section anchored by '\"+thisAnchorID+\"', jumping to next anchor @ \"+nextAnchorPosY+\").\",true);");
printf("					scrollTo_animated(document.body, nextAnchorPosY, 150);");
printf("					break;");
printf("				}");
printf("			}");
printf("		}");
printf("		else {");	//error in FavScreen class attributes
printf("			FavScreen.log('error',\"handleJumpNavButtonAction_btnB(): Could not determine or invalid current jump mode attribute (attrJumpNavMode) value from FavScreen class ('\"+cm+\"'), not jumping.\",true);");
printf("		}");
printf("	}");
printf("	function handleJumpNavButtonAction_btnC() {");	//down-mode & page down (pixel-scroll based?)
printf("		var currentMode = FavScreen.get('attrJumpNavMode');");
printf("		var currPosY = FavScreen.get('attrCurrentScrollPositionPixelY');");	//get the current scroll position (DEV-NOTE: in case this doesn't update fast enough, may need to get current position natively here instead?)
printf("		var cfg_scrollFudgeAmount = 14;");					//for some reason (yet unknown), doing the scroll doesn't always get us exactly to the specified pixel position
printf("		currPosY = currPosY + cfg_scrollFudgeAmount;");				//for some reason (yet still), iOS needs a bit more fudging
//printf("		var positionOfTopOfBottomMostPagination = document.getElementById('bodywrapper').clientHeight - (FavScreen.get('attrBodyWrapperHeight') + FavScreen.get('attrHeaderWrapperHeight') + parseInt(window.getComputedStyle(document.getElementById('bodywrapper'),null).getPropertyValue('padding-bottom'))*2);");
printf("		var positionOfTopOfBottomMostPagination = document.getElementById('bodywrapper').clientHeight - (FavScreen.get('attrBodyWrapperHeight') + FavScreen.get('attrHeaderWrapperHeight') + parseInt(window.getComputedStyle(document.getElementById('bodywrapper'),null).getPropertyValue('padding-bottom'))*(parseInt(FavScreen.get('attrZoom'))/100));");
printf("		if(currPosY >= positionOfTopOfBottomMostPagination - cfg_scrollFudgeAmount) {");//if we're scrolled all the way to the bottom, change mode to up
printf("			if(handleJumpNav_atLimit) {");						//if a we've been flagged at the limit (meaning that a previous button press resulted in being at the bottom), we should now wrap around
printf("				scrollTo_animated(document.body, -67, 150);");				//"wrap around" by jumping to the top
printf("				handleJumpNav_atLimit = false;");					//reset flag
printf("				return;");
printf("			}");
printf("			else {");
printf("				flashHeaderWrapper('gray');");						//flash the footer
printf("				handleJumpNav_atLimit = true;");					//set flag, so next button press can wrap around
printf("			}");
printf("		}");
printf("		if(currentMode===MODE_JUMPNAV_UP){");		//hitting down mode while in up mode... change the mode and exit
printf("			FavScreen.log('log',\"handleJumpNavButtonAction_btnC(): Changing mode to page down...\",true);");
printf("			FavScreen.set('attrJumpNavMode', MODE_JUMPNAV_DOWN);");
printf("			return;");
printf("		}else if(currentMode===MODE_JUMPNAV_DOWN){");	//hitting down mode while already in down mode... proceed to continue page down
printf("			FavScreen.log('log',\"handleJumpNavButtonAction_btnC(): Paging down...\",true);");
printf("		}else{");					//error case... default to change-to-down-mode
printf("			FavScreen.log('warn',\"handleJumpNavButtonAction_btnC(): Unknown attrJumpNavMode (\"+FavScreen.get('attrJumpNavMode')+\"). Defaulting to paging down.\",true);");
printf("			FavScreen.set('attrJumpNavMode', MODE_JUMPNAV_DOWN);");
printf("		}");
printf("		var bwHeight = FavScreen.get('attrBodyWrapperHeight');");
printf("		var currScroll = FavScreen.get('attrCurrentScrollPositionPixelY');");	//DEV-NOTE: this could be taking some time to update/poll, which may be causing delayed or missed jumps when rapidly pressing button
printf("		var targetPos = currScroll + bwHeight;");
printf("		scrollTo_animated(document.body, targetPos, 150);");
printf("	}");
printf("	function handleJumpNavButtonAction_btnD() {");	//up-mode & page up (pixel-scroll based?)
printf("		var currentMode = FavScreen.get('attrJumpNavMode');");
printf("		var currPosY = FavScreen.get('attrCurrentScrollPositionPixelY');");	//get the current scroll position (DEV-NOTE: in case this doesn't update fast enough, may need to get current position natively here instead?)
printf("		var cfg_scrollFudgeAmount = 7;");					//for some reason (yet unknown), doing the scroll doesn't always get us exactly to the specified pixel position
printf("		currPosY = currPosY - cfg_scrollFudgeAmount;");				//for some reason (yet still), iOS needs a bit more fudging
printf("		var positionOfTopOfBottomMostPagination = document.getElementById('bodywrapper').clientHeight - (FavScreen.get('attrBodyWrapperHeight') + FavScreen.get('attrHeaderWrapperHeight') + parseInt(window.getComputedStyle(document.getElementById('bodywrapper'),null).getPropertyValue('padding-bottom'))*(parseInt(FavScreen.get('attrZoom'))/100));");
printf("		if(currPosY<=0) {");							//if we're scrolled all the way to the top, change mode to down
printf("			if(handleJumpNav_atLimit) {");						//if a we've been flagged at the limit (meaning that a previous button press resulted in being at the top), we should now wrap around
printf("				scrollTo_animated(document.body, positionOfTopOfBottomMostPagination, 150);");	//"wrap around" by jumping to the last pagination
printf("				handleJumpNav_atLimit = false;");					//reset flag
printf("				return;");
printf("			}");
printf("			else {");
printf("				flashHeaderWrapper('gray');");						//flash the header
printf("				handleJumpNav_atLimit = true;");					//set flag, so next button press can wrap around
printf("			}");
printf("		}");
printf("		if(currentMode===MODE_JUMPNAV_DOWN){");		//hitting up mode while in down mode... change the mode and exit
printf("			FavScreen.log('log',\"handleJumpNavButtonAction_btnD(): Changing mode to page up...\",true);");
printf("			FavScreen.set('attrJumpNavMode', MODE_JUMPNAV_UP);");
printf("			return;");
printf("		}else if(currentMode==MODE_JUMPNAV_UP){");	//hitting up mode while already in up mode... proceed to continue page up
printf("			FavScreen.log('log',\"handleJumpNavButtonAction_btnD(): Paging up...\",true);");
printf("		}else{");					//error case... default to change-to-down-mode
printf("			FavScreen.log('warn',\"handleJumpNavButtonAction_btnD(): Unknown attrJumpNavMode (\"+FavScreen.get('attrJumpNavMode')+\"). Defaulting to paging up.\",true);");
printf("			FavScreen.set('attrJumpNavMode', MODE_JUMPNAV_UP);");
printf("		}");
printf("		var bwHeight = FavScreen.get('attrBodyWrapperHeight');");
printf("		var currScroll = FavScreen.get('attrCurrentScrollPositionPixelY');");	//DEV-NOTE: this could be taking some time to update/poll, which may be causing delayed or missed jumps when rapidly pressing button
printf("		var targetPos = currScroll - bwHeight;");
printf("		scrollTo_animated(document.body, targetPos, 150);");
printf("	}");
printf("	function handleJumpNavButtonAction(e) {");		//Handles a jump-nav button event (clicking/tapping a jump nav button), accepting the event as the required argument
printf("		var btnID = e.currentTarget.id;");
printf("		e.stopImmediatePropagation();");			//be extra safe and prevent any other event handlers from firing (e.g. launch/view message)
printf("		e.stopPropagation();");					//be extra safe and prevent any other event handlers from firing (e.g. launch/view message)
printf("		e.preventDefault();");					//be extra safe and prevent any other event handlers from firing (e.g. launch/view message)
printf("		switch(btnID) {");
printf("			case 'btnA':");
printf("				handleJumpNavButtonAction_btnA();");
printf("				break;");
printf("			case 'btnB':");
printf("				handleJumpNavButtonAction_btnB();");
printf("				break;");
printf("			case 'btnC':");
printf("				handleJumpNavButtonAction_btnC();");
printf("				break;");
printf("			case 'btnD':");
printf("				handleJumpNavButtonAction_btnD();");
printf("				break;");
printf("			default:");
printf("				break;");
printf("		}");
printf("	}");
printf("	var preloadedJumpNavButtonImage_btnA_down,");
printf("	    preloadedJumpNavButtonImage_btnA_up,");
printf("	    preloadedJumpNavButtonImage_btnB_down,");
printf("	    preloadedJumpNavButtonImage_btnB_up,");
printf("	    preloadedJumpNavButtonImage_btnC_yellow,");
printf("	    preloadedJumpNavButtonImage_btnC_white,");
printf("	    preloadedJumpNavButtonImage_btnD_green,");
printf("	    preloadedJumpNavButtonImage_btnD_white;");
printf("	function loadJumpNavButtons() {");						//Load, generate and return the node containing our jump-nav buttons
//printf("		var MODE_STATIC = 'static';");
//printf("		var MODE_CSSMASK = 'css-mask';");
////printf("		cfg_mode = MODE_CSSMASK;");							//configure the method you want to use (1st version used this, but not yet supported in most browsers, so excluding for now)
//printf("		cfg_mode = MODE_STATIC;");							//configure the method you want to use
			//configure and assemble the complete buttons, depending on mode desired...
//printf("		if(cfg_mode === MODE_CSSMASK) {");							//if configured for CSS-mask icons...
/* DEV-NOTE: un-commenting this won't break things (as of v0.37.0-beta)... CSS has also been updated to work with this... just leaving out for now to help keep code lean
printf("			var node_span = document.createElement('span');");					//create a wrapper template for the arrow images (this could be styled to look like a button, potentially)
printf("			    node_span.className = \"jumpnavbutton mask\";");						//assign class for these wrappers
printf("			    node_span.addEventListener('click',handleJumpNavButtonAction);");				//assign event handler to these wrappers (inherently should pass the click event object, which gives us the distinction for each button)
printf("			var node_span_btnA = node_span.cloneNode();");						//create the first button based on the template above
printf("			    node_span_btnA.id = \"btnA\";");								//assign a unique DOM ID for this button
printf("			    node_span_btnA.className = node_span_btnA.className + \" affectedbyjumpnavmode yellow\";");	//flag this node as being affected by any changes in jump-nav mode
printf("			    node_span_btnA.style.webkitMaskImage = \"url('%s/icons/32x32/%s')\";", cgi_icons, FAVS_ICON_ARROW_WHITE_DOUBLE_HARD_DOWN);//give this button its default icon-image
printf("			    node_span_btnA.addEventListener('click',handleJumpNavButtonAction);");			//assign event handler to this button (inherently should pass the click event object, which gives us this button's distinction)
printf("			var node_span_btnB = node_span.cloneNode();");						//create the second button based on the template above
printf("			    node_span_btnB.id = \"btnB\";");								//assign a unique DOM ID for this button
printf("			    node_span_btnB.className = node_span_btnB.className + \" affectedbyjumpnavmode yellow\";");	//flag this node as being affected by any changes in jump-nav mode
printf("			    node_span_btnB.style.webkitMaskImage = \"url('%s/icons/32x32/%s')\";", cgi_icons, FAVS_ICON_ARROW_WHITE_SINGLE_HARD_DOWN);//give this button its default icon-image
printf("			    node_span_btnB.addEventListener('click',handleJumpNavButtonAction);");			//assign event handler to this button (inherently should pass the click event object, which gives us this button's distinction)
printf("			var node_span_btnC = node_span.cloneNode();");						//create the third button based on the template above
printf("			    node_span_btnC.id = \"btnC\";");								//assign a unique DOM ID for this button
printf("			    node_span_btnC.className = node_span_btnC.className + \" yellow\";");			//flag this node as being affected by any changes in jump-nav mode
printf("			    node_span_btnC.style.webkitMaskImage = \"url('%s/icons/32x32/%s')\";", cgi_icons, FAVS_ICON_ARROW_WHITE_SINGLE_DOWN);//give this button its default icon-image
printf("			    node_span_btnC.addEventListener('click',handleJumpNavButtonAction);");			//assign event handler to this button (inherently should pass the click event object, which gives us this button's distinction)
printf("			var node_span_btnD = node_span.cloneNode();");						//create the fourth button based on the template above
printf("			    node_span_btnD.id = \"btnD\";");								//assign a unique DOM ID for this button
printf("			    node_span_btnD.className = node_span_btnD.className + \" green\";");			//flag this node as being affected by any changes in jump-nav mode
printf("			    node_span_btnD.style.webkitMaskImage = \"url('%s/icons/32x32/%s')\";", cgi_icons, FAVS_ICON_ARROW_WHITE_SINGLE_UP);//give this button its default icon-image
printf("			    node_span_btnD.addEventListener('click',handleJumpNavButtonAction);");			//assign event handler to this button (inherently should pass the click event object, which gives us this button's distinction)
*/
//printf("		}");
//printf("		else if(cfg_mode === MODE_STATIC) {");							//if configured for static image-icons...
printf("			preloadedJumpNavButtonImage_btnA_down = new Image();");
printf("	    		preloadedJumpNavButtonImage_btnA_down.src = '%s/icons/32x32/%s';", cgi_icons, FAVS_ICON_JUMP_DOWN_MAJORSEC_YELLOW);
printf("			preloadedJumpNavButtonImage_btnA_up = new Image();");
//printf("	    		preloadedJumpNavButtonImage_btnA_up.src = '%s/icons/32x32/%s';", cgi_icons, FAVS_ICON_JUMP_UP_MAJORSEC_GREEN);
printf("	    		preloadedJumpNavButtonImage_btnA_up.src = '%s/icons/32x32/%s';", cgi_icons, FAVS_ICON_JUMP_DOWN_MAJORSEC_GREEN);	//note: using the down image here, so it can simply be rotated to point up (and also give us the rotation animation)
printf("			preloadedJumpNavButtonImage_btnB_down = new Image();");
printf("	    		preloadedJumpNavButtonImage_btnB_down.src = '%s/icons/32x32/%s';", cgi_icons, FAVS_ICON_JUMP_DOWN_MINORSEC_YELLOW);
printf("			preloadedJumpNavButtonImage_btnB_up = new Image();");
//printf("	    		preloadedJumpNavButtonImage_btnB_up.src = '%s/icons/32x32/%s';", cgi_icons, FAVS_ICON_JUMP_UP_MINORSEC_GREEN);
printf("	    		preloadedJumpNavButtonImage_btnB_up.src = '%s/icons/32x32/%s';", cgi_icons, FAVS_ICON_JUMP_DOWN_MINORSEC_GREEN);	//note: using the down image here, so it can simply be rotated to point up (and also give us the rotation animation)
printf("			preloadedJumpNavButtonImage_btnC_yellow = new Image();");
printf("	    		preloadedJumpNavButtonImage_btnC_yellow.src = '%s/icons/32x32/%s';", cgi_icons, FAVS_ICON_JUMP_DOWN_PAGE_YELLOW);
printf("			preloadedJumpNavButtonImage_btnC_white = new Image();");
printf("	    		preloadedJumpNavButtonImage_btnC_white.src = '%s/icons/32x32/%s';", cgi_icons, FAVS_ICON_JUMP_DOWN_PAGE_WHITE);
printf("			preloadedJumpNavButtonImage_btnD_green = new Image();");
printf("	    		preloadedJumpNavButtonImage_btnD_green.src = '%s/icons/32x32/%s';", cgi_icons, FAVS_ICON_JUMP_UP_PAGE_GREEN);
printf("			preloadedJumpNavButtonImage_btnD_white = new Image();");
printf("	    		preloadedJumpNavButtonImage_btnD_white.src = '%s/icons/32x32/%s';", cgi_icons, FAVS_ICON_JUMP_UP_PAGE_WHITE);
printf("			var node_span = document.createElement('span');");							//create a wrapper template for the arrow images (this could be styled to look like a button, potentially)
printf("			    node_span.className = \"jumpnavbutton static\";");								//assign class for these wrappers
//printf("			    node_span.addEventListener('click',handleJumpNavButtonAction);");						//assign event handler to these wrappers (inherently should pass the click event object, which gives us the distinction for each button)	//DEV-NOTE: this seems to add an extra click (to focus??) before actually working, on iOS at least
printf("			    node_span.onclick = handleJumpNavButtonAction;");						//assign event handler to these wrappers (inherently should pass the click event object, which gives us the distinction for each button)
printf("			var node_span_btnA = node_span.cloneNode();");								//create the first button based on the template above
printf("			    node_span_btnA.id = \"btnA\";");										//assign a unique DOM ID for this button
printf("			    node_span_btnA.className = node_span_btnA.className + \" affectedbyjumpnavmode\";");			//flag this node as being affected by any changes in jump-nav mode
printf("			    node_span_btnA.style.backgroundImage = \"url(\"+preloadedJumpNavButtonImage_btnA_down.src+\")\";");		//give this button its default icon-image (spec says to change to green with change to up)
//printf("			    node_span_btnA.addEventListener('click',handleJumpNavButtonAction);");					//assign event handler to this button (inherently should pass the click event object, which gives us this button's distinction)	//DEV-NOTE: this seems to add an extra click (to focus??) before actually working, on iOS at least
printf("			    node_span_btnA.onclick = handleJumpNavButtonAction;");					//assign event handler to this button (inherently should pass the click event object, which gives us this button's distinction)
//printf("			    node_span_btnA.innerHTML = '&nbsp;';");					//assign event handler to this button (inherently should pass the click event object, which gives us this button's distinction)
printf("			var node_span_btnB = node_span.cloneNode();");								//create the second button based on the template above
printf("			    node_span_btnB.id = \"btnB\";");										//assign a unique DOM ID for this button
printf("			    node_span_btnB.className = node_span_btnB.className + \" affectedbyjumpnavmode short\";");			//flag this node as being affected by any changes in jump-nav mode
printf("			    node_span_btnB.style.backgroundImage = \"url(\"+preloadedJumpNavButtonImage_btnB_down.src+\")\";");		//give this button its default icon-image (spec says to change to green with change to up)
//printf("			    node_span_btnB.addEventListener('click',handleJumpNavButtonAction);");					//assign event handler to this button (inherently should pass the click event object, which gives us this button's distinction)	//DEV-NOTE: this seems to add an extra click (to focus??) before actually working, on iOS at least
printf("			    node_span_btnB.onclick = handleJumpNavButtonAction;");					//assign event handler to this button (inherently should pass the click event object, which gives us this button's distinction)
printf("			var node_span_btnC = node_span.cloneNode();");								//create the third button based on the template above
printf("			    node_span_btnC.id = \"btnC\";");										//assign a unique DOM ID for this button
printf("			    node_span_btnC.className = node_span_btnC.className + \" yellow short\";");					//flag this node as being affected by any changes in jump-nav mode
printf("			    node_span_btnC.style.backgroundImage = \"url(\"+preloadedJumpNavButtonImage_btnC_yellow.src+\")\";");	//give this button its default icon-image (spec says to change to white with mode change to up / yellow when down --this will never point up)
//printf("			    node_span_btnC.addEventListener('click',handleJumpNavButtonAction);");					//assign event handler to this button (inherently should pass the click event object, which gives us this button's distinction)	//DEV-NOTE: this seems to add an extra click (to focus??) before actually working, on iOS at least
printf("			    node_span_btnC.onclick = handleJumpNavButtonAction;");					//assign event handler to this button (inherently should pass the click event object, which gives us this button's distinction)
printf("			var node_span_btnD = node_span.cloneNode();");								//create the fourth button based on the template above
printf("			    node_span_btnD.id = \"btnD\";");										//assign a unique DOM ID for this button
printf("			    node_span_btnD.className = node_span_btnD.className + \" short\";");					//flag this node as being affected by any changes in jump-nav mode
printf("			    node_span_btnD.style.backgroundImage = \"url(\"+preloadedJumpNavButtonImage_btnD_white.src+\")\";");	//give this button its default icon-image (spec says to change to white with mode change to down / green when up --this will never point down)
//printf("			    node_span_btnD.addEventListener('click',handleJumpNavButtonAction);");					//assign event handler to this button (inherently should pass the click event object, which gives us this button's distinction)	//DEV-NOTE: this seems to add an extra click (to focus??) before actually working, on iOS at least
printf("			    node_span_btnD.onclick = handleJumpNavButtonAction;");					//assign event handler to this button (inherently should pass the click event object, which gives us this button's distinction)
//printf("		}");
			//add the completed default buttons to their container in the footer (after its created, of course)...
printf("		var node_container = document.createElement('div');");					//create a container node to return that contains our buttons
printf("		    node_container.id = \"jumpnavwrapper\";");
printf("		node_container.appendChild(node_span_btnA);");
printf("		node_container.appendChild(node_span_btnB);");
printf("		node_container.appendChild(node_span_btnC);");
printf("		node_container.appendChild(node_span_btnD);");
printf("		return node_container;");
printf("	}");
printf("	document.getElementById(\"footerwrapper\").appendChild(loadJumpNavButtons());");		//populate the footer with our buttons
printf("	document.getElementById(\"footerwrapper\").style.display = \"table\";");			//show the footer (displaying as table so contents can be vertically-aligned in the middle)

// Handle initial Spinner loading behavior for older versions that didn't load it natively on initial load, to let the user know that stuff is happening...
printf("	if((typeof parseAppVersionFromUA === \"function\") && parseAppVersionFromUA(\"0\") >= \"%s\"){", FAVS_APP_IOS_VER_JSCANCONTROLNATIVESPINNER);
		/* let the native spinner stay showing.. no need to show a non-native spinner */
printf("	}else{");
printf("		var spinnerInit_cfg_intervalTime = 100;");						//configure however often to keep trying to show the spinner (while waiting for the spinner class to initialize)
printf("		var spinnerInit_cfg_intervalMax = 90;");						//configure however many maximum times to interval (so we can cancel the interval if taking too long)
printf("		var spinnerInit_i = 0;");
printf("		var spinnerInit_intervalHandle;");
printf("		function initialLoadingSpinnerShow(){");						//define how to handle the initial-load spinner behavior...
printf("			spinnerInit_i++;");									//increment our counter, so we can cancel the interval if trying too many times
printf("			if(Spinner.initialized){");								//if the spinner is ready by now (it, itself, takes time to load), then show it
printf("				clearInterval(spinnerInit_intervalHandle);");						//cancel setInterval
printf("				Spinner.show();");									//show the spinner
printf("				spinnerInit_cfg_intervalTime = spinnerInit_cfg_intervalMax = spinnerInit_i = spinnerInit_intervalHandle = undefined;");//clear the variables that we no longer need
printf("			}");
printf("			if(spinnerInit_i > spinnerInit_cfg_intervalMax){");					//if we've been trying to show the spinner for too long, just give up, because things might already be loaded by now, anyway
printf("				clearInterval(spinnerInit_intervalHandle);");						//cancel setInterval
printf("				console.warn(\"initialLoadingSpinnerShow(): Waited for spinner initialization for too long, aborting to prevent infinite loop/interval.\");");
printf("			}");
printf("		}");
printf("		spinnerInit_intervalHandle = setInterval(\"initialLoadingSpinnerShow()\", spinnerInit_cfg_intervalTime);");//call the above function every spinnerInit_cfg_intervalTime-th of a second (it will automatically clear itself after spinnerInit_cfg_intervalMax times)
printf("	}");
printf("</script>");

printf("</div>");//end #pagewrapper
}//end add_bodyLayoutContents()


/***********************************************************************
* static void add_jsSrcAndFiles(void)
*
*	This function prints various misc JavaScript (e.g. shims) and 
*	HTML includes for external JavaScript files, etc.
*
***********************************************************************/
static void add_jsSrcAndFiles(void)
{
//printf("<script src=\"%s/~silentm/javascripts/shim_classList.js\" />", cgi_base);		//include the file that helps better support classList across browsers (since it's newer HTML5 and might not be supported by all)

printf("<script type=\"text/javascript\" src=\"%s/~silentm/javascripts/favorites/fastclick.min.js\"></script>", cgi_base); 	// note: probably shouldn't load this asynchronously, since it's a lower-level feature
//printf("<script type=\"text/javascript\" src=\"%s/~silentm/javascripts/favorites/navigation.js\"></script>", cgi_base); 	// note: probably shouldn't load this asynchronously, since it's a lower-level feature

printf("<script type=\"text/javascript\">");

printf("	function attachFastClick(objSpecificNodeToAddFastClickTo) {");			//Handle attachment of the FastClick override (specific node argument is optional)... if none provided, just defaults to attaching to the main nodes specified in the function below
printf("		FavScreen.log('verbose',\"attachFastClick(): Called.\",true);");
printf("		var ret = [];");
printf("		try {");
printf("			if((typeof objSpecificNodeToAddFastClickTo === 'object') && (objSpecificNodeToAddFastClickTo.nodeType == 1)) {");	//if arg is a valid DOM node object...
printf("				ret.push( FastClick.attach(objSpecificNodeToAddFastClickTo) );");
printf("				objSpecificNodeToAddFastClickTo = true;");									//set flag for rest of function to use
printf("			}");
printf("		}");
printf("		catch(err) {");
printf("			FavScreen.log('error',\"attachFastClick(): Argument for overriding a specific node is not a valid DOM node object (typeof = '\"+typeof objSpecificNodeToAddFastClickTo+\"').\",true);");
printf("			return err;");
printf("		}");
printf("		if(!objSpecificNodeToAddFastClickTo) {");					//if no specific node argument was specified, then just do our default attachments...
printf("			ret.push( FastClick.attach(document.getElementById('footerwrapper')) );");	//attach the fastclick override to our main 'body' node, containing all of our message-content
printf("			ret.push( FastClick.attach(document.getElementById('bodywrapper')) );");	//attach the fastclick override to our main 'body' node, containing all of our message-content
printf("			ret.push( FastClick.attach(document.getElementById('pagetitle')) );");		//attach the fastclick override to the page title node (this should avoid the menu, which has issues with fastclick)
printf("		}");
//printf("		for(var i=0; i<ret.length; i++) {");						//for each of the FastClick instances, modify certain attributes
//printf("			ret[i].touchBoundary = 15;");							//increase the threshold for cancelling a tap if the finger moves, from the default of 10 (this makes it easier to tap without having to be delicate)
//printf("		}");
printf("		FavScreen.log('verbose',\"attachFastClick(): Finished.\",true);");
printf("		return ret;");									//note: you don't need to actually do anything with this, if you don't want... the FastClick overrides will exist and work either way
printf("	}");

// Instantiate our fast-click on the elements we want it to be active on (seems to break menu)...
//printf("	if('addEventListener' in document) {");						//basic ability check for adding event listeners
//printf("		document.addEventListener('DOMContentLoaded', function() {");		//waiting for the document to be fully loaded...
//printf("			setTimeout(attachFastClick, 1000);");
//printf("			}, false);");
//printf("	}");

// Shim 'Date.now()' support for older IE (pre-ECMA-5 browsers)...
printf("	if(!Date.now){");
printf("		Date.now = function(){return new Date().getTime();};");
printf("	}");

// Shim 'console' support for older IE (8 and below - and sometimes 9, depending on debug/compatibility mode)
// IE8 has the console command; but before certain patches, it isn't instantiated until developer-tools is opened. Therefore, calling it in the application may result in an error, so patch with dummy objects to prevent errors - it's the best we can do with Micro$oft's problem child.
printf("	if(typeof window.console === \"undefined\"){");
printf("		console = {};");
printf("		console.log = function(){};");
printf("		console.info = function(){};");
printf("		console.warn = function(){};");
printf("		console.error = function(){};");
printf("	}");

// Shim 'document.getElementsByClassName()' for older IE (8 and below)
// DEV-NOTE: This may not actually work, but at least it prevents warnings... look into more later why some menu items are broken (menu is what uses this method)
printf("	if(!document.getElementsByClassName){");
printf("		document.getElementsByClassName = (function(){");
printf("			function traverse(node,callback){");				//local utility function to traverse the DOM (note: this is recursive)
printf("				callback(node);");
printf("				for(var i=0; i<node.childNodes.length; i++){");
printf("					traverse(node.childNodes[i],callback);");
printf("				}");//end for
printf("			}");//end function
printf("			return function(name){");					//actual definition of the getElementsByClassName method
printf("				var result = [];");
printf("				traverse(document.body,function(node){");
printf("					if(node.className == name){");
printf("						result.push(node);");
printf("					}");//end if
printf("					});");//end traverse call
printf("				return result;");
printf("				}");//end return function
printf("		})()");//end definition for document.getElementsByClassName
printf("	}");
// DEV-NOTE: This closure method doesn't seem to break anything, but also doesn't fix the issue...
/*
printf("(function() {");
printf("    var indexOf = [].indexOf || function(prop) {");
printf("        for (var i = 0; i < this.length; i++) {");
printf("            if (this[i] === prop) return i;");
printf("        }");
printf("        return -1;");
printf("    };");
printf("    window.getElementsByClassName = function(className,context) {");
printf("        if (context.getElementsByClassName) return context.getElementsByClassName(className);");
printf("        var elems = document.querySelectorAll ? context.querySelectorAll(\".\" + className) : (function() {");
printf("            var all = context.getElementsByTagName(\"*\"),");
printf("                elements = [],");
printf("                i = 0;");
printf("            for (; i < all.length; i++) {");
printf("                if (all[i].className && (\" \" + all[i].className + \" \").indexOf(\" \" + className + \" \") > -1 && indexOf.call(elements,all[i]) === -1) elements.push(all[i]);");
printf("            }");
printf("            return elements;");
printf("        })();");
printf("        return elems;");
printf("    };");
printf("})();");
*/

// Shim the 'trim()' method for older IE (8 and below)
printf("	if(typeof String.prototype.trim !== 'function'){");
printf("		String.prototype.trim = function() {");
printf("			return this.replace(/^\\s+|\\s+$/g, ''); ");
printf("		}");
printf("	}");

// The following adds a :hover rule on mouse-based devices (the actual stylesheet already adds a global :active rule.
// This ensures that our hover effect only happens on mouse-based devices, while not on touch devices.
if(!isLoadedOnMobileDevice())
	{
	printf("document.styleSheets[0].insertRule('ul.messagelist li.messagecell:hover {background-color:#dddddd;}', 0);");
	}

// The following adds a method for achieving higher geolocation accuracy.
// It uses the watchPosition method along with a timeout to keep trying to get the best position as the GPS chip acquires a better and better lock.
//	Example:	navigator.geolocation.getAccurateCurrentPosition(onSuccess, onError, onProgress, {desiredAccuracy:100, maxWait:10000});
printf("	if(navigator.geolocation){");
printf("		navigator.geolocation.getHighlyAccurateCurrentPosition = function(geolocationSuccess, geolocationError, geoprogress, options){");
printf("			var lastCheckedPosition;");
printf("			var locationEventCount = 0;");
printf("			var watchID, timerID;");
printf("			options = options || {};");			//initialize as an object literal if nothing was provided
printf("			var checkLocation = function(position){");
printf("				lastCheckedPosition = position;");
printf("				locationEventCount = locationEventCount + 1;");
printf("				if ((position.coords.accuracy <= options.desiredAccuracy) && (locationEventCount > 1)) {");	//ignore the first event unless it's the only one, since some devices apparently give us a cachec location even though maximumAge is set to zero
printf("					clearTimeout(timerID);");
printf("					navigator.geolocation.clearWatch(watchID);");
printf("					foundPosition(position);");
printf("				}else{");
printf("					geoprogress(position);");
printf("				}");
printf("				};");//end checkLocation method definition
printf("			var stopTrying = function () {");
printf("				navigator.geolocation.clearWatch(watchID);");
printf("				foundPosition(lastCheckedPosition);");
printf("				};");//end stopTrying method definition
printf("			var onError = function (error) {");
printf("				clearTimeout(timerID);");
printf("				navigator.geolocation.clearWatch(watchID);");
printf("				geolocationError(error);");
printf("				};");//end onError method definition
printf("			var foundPosition = function (position) {");
printf("				geolocationSuccess(position);");
printf("				};");//end foundPosition method definition
printf("			if(!options.maxWait)		options.maxWait = 15000;");		//default maximum wait time in milliseconds, if none provided
printf("			if(!options.desiredAccuracy)	options.desiredAccuracy = 100;");	//default accuracy threshold in meters (tests inside our building seem to give us around 65 meters), if none provided
printf("			if(!options.timeout)		options.timeout = options.maxWait;");	//default to our defined maxWait value set above, if none provided
printf("			options.maximumAge = 0;");						//force current locations only
printf("			options.enableHighAccuracy = true;");					//force high accuracy
printf("			watchID = navigator.geolocation.watchPosition(checkLocation, onError, options);");
printf("			timerID = setTimeout(stopTrying, options.maxWait);");			//set a timeout that will abort the geolocation loop
printf("			};");//end getHighlyAccurateCurrentPosition method definition
printf("	}");

// Basic integrity checking...
/*
printf("	var fxn_ctx_doCheck_nameWithCo = function(){ctx.updateStringly(PRODUCT_NAME);var ret = (ctx.result===1949365911?true:false);return ret;};");
printf("	var ctx;");
printf("	function initialize_ctx() {");
printf("		if(typeof Checksum === \"function\") {");
printf("			ctx = new Checksum(\"fnv32\", 0);");
printf("		}");
printf("		else {");
printf("			setTimeout(initialize_ctx, 500);");
printf("		}");
printf("	}");//end function
//printf("	function run_ctx() {");
//printf("	}");//end function
printf("	initialize_ctx();");
*/
printf("	var integrityMayBeCompromised = false;");	//flag for telling whether something came across the wire wrong or not
printf("	function checkSetIntegSec() {");
printf("		if(\"%s\"!==vig_decrypt(\"ZmuwtxcWik Tmohxphkwts\",%s)) {", PRODUCT_NAME, FAVS_OBJ_KEY_ARR);
printf("			integrityMayBeCompromised = true;");
printf("		}");
printf("		return integrityMayBeCompromised;");
printf("	}");

printf("</script>");
}


/***********************************************************************
* static void add_cssFiles(void)
*
*	This function prints HTML includes for external CSS files.
*
***********************************************************************/
static void add_cssFiles(void)
{
char dtsec[DTSEC_LENGTH];
get_dtsec(dtsec);		//get current dtsec, to append as a query parameter to the stylesheet directive, to help prevent caching
char *dtsec_nospaces = remove_leading_space(dtsec);

//printf("<link rel=\"stylesheet\" type=\"text/css\" href=\"%s/~silentm/css/smcgi_favorites.css?currentdtsec=%s\" />", cgi_base, dtsec_nospaces);	//link our main style sheet for favorites (only use for debugging or something)
printf("<link rel=\"stylesheet\" type=\"text/css\" href=\"%s/~silentm/css/smcgi_favorites.min.css?currentdtsec=%s\" />", cgi_base, dtsec_nospaces);	//link our main style sheet for favorites (this file should be minified)
}


/***********************************************************************
* static void construct_favorites_main(int withFullSystem)
*
*	This function creates the client document that hosts the "favorites" screen.
*
*		- withFullSystem:	If true, then two windows will open (one with favorites and the other with the classic system), otherwise only the favorites screen will pop open
*
*	NOTES TO DEVELOPER:
*	- The content created within this function should be done in a strict W3C standards-compliant manner.
*	- It needs to be suitable for rendering on most/any device or screen size, so all layouts should strive to be "fluid."
*	- AVOID LAYOUT TABLES if possible. In principle, tables should ONLY be used to layout tabular data ~~never to layout a page.
*	- Also try to avoid defining styles here (use the CSS instead).
*	- I've tried to use this hierarchy/wording... (so if you see that in the tage in this file, you know what they mean)
*		"Window"       -->         "Document"         -->        "Body"	        -->          "Page"           -->        "header" and "body" etc.
*	   (OS-level win/tab)       (html, head, body, etc.)       (the html body tag)	     (favorites pagewrapper)       (headerwrapper and bodywrapper, etc.)
*
***********************************************************************/
void construct_favorites_main(int withFullSystem)
{
char *httpUserAgentForLogin = getenv("HTTP_USER_AGENT");        /* use this here instead of cgi_detect_browser() because we want more detailed info than just the few it offers */

printf("<!DOCTYPE html>\n\n");	//HTML-5 doctype
printf("<html>\n\n");

printf("<head>\n");
add_CopyRight(NULL, TRUE);
printf("	<title>%s %s</title>\n", cgi_product_name, FAVS_NAME_FULL);
if(httpUserAgentForLogin && 
	(  strstr(httpUserAgentForLogin, "iPad")	//example: Mozilla/5.0 (iPad; CPU OS 7_0_6 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11B651 Safari/9537.53
	|| strstr(httpUserAgentForLogin, "iPhone")
	|| strstr(httpUserAgentForLogin, "iPod") ))	//likely not needed, since iPod Touch seems to be caught by iPhone above, but can't hurt
	{
	//printf("<meta name=\"viewport\" content=\"initial-scale=1, user-scalable=yes, width=device-width\">");					//ensures that page elements aren't rendered too small on high pixel density devices (DEV-NOTE: this might need extensive testing across platforms)
	//printf("<meta name=\"viewport\" content=\"initial-scale=1, user-scalable=yes, width=device-width, minimum-scale=1\">");			//ensures that page elements aren't rendered too small on high pixel density devices (DEV-NOTE: this might need extensive testing across platforms)
	//printf("<meta name=\"viewport\" content=\"initial-scale=1, user-scalable=no, width=device-width, minimum-scale=1\">");			//ensures that page elements aren't rendered too small on high pixel density devices (DEV-NOTE: this might need extensive testing across platforms)
	//printf("<meta name=\"viewport\" content=\"initial-scale=1, user-scalable=no, width=device-width, minimum-scale=1, minimal-ui\">\n");		//ensures that page elements aren't rendered too small on high pixel density devices (DEV-NOTE: this might need extensive testing across platforms)
	//printf("<meta name=\"viewport\" content=\"initial-scale=1, user-scalable=no, width=device-width, minimum-scale=1, maximum-scale=1, minimal-ui\">\n");	//ensures that page elements aren't rendered too small on high pixel density devices (DEV-NOTE: this might need extensive testing across platforms)
	//printf("<meta name=\"viewport\" content=\"initial-scale=1, user-scalable=no, width=device-width, minimum-scale=1, maximum-scale=1\">\n");	//ensures that page elements aren't rendered too small on high pixel density devices (DEV-NOTE: this might need extensive testing across platforms)
	printf("<meta name=\"viewport\" content=\"initial-scale=1.0, target-densityDpi=device-dpi, width=device-width, height=device-height, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n");//ensures that page elements aren't rendered too small on high pixel density devices (DEV-NOTE: this might need extensive testing across platforms)
	printf("<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n");									//tell mobile safari this is a web app
	printf("<meta name=\"format-detection\" content=\"telephone=no\">\n");										//tell mobile safari to NOT format numbers (per Kevin, 2015.02.27) ~This override only works with phone numbers.. need to change native app "dataDetectorTypes" for other data types
	}
else if(httpUserAgentForLogin &&
	strstr(httpUserAgentForLogin, "Android") )	//example: Mozilla/5.0 (Linux; Android 4.2.2; en-us; SAMSUNG SCH-I545 Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Version/1.0 Chrome/18.0.1025.308 Mobile Safari/535.19
	{
	if( strstr(httpUserAgentForLogin, "Chrome") )
		{
		printf("<meta name=\"viewport\" content=\"initial-scale=1.0, target-densityDpi=device-dpi, width=device-width, height=device-height, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n");//ensures that page elements aren't rendered too small on high pixel density devices (DEV-NOTE: this might need extensive testing across platforms)
		printf("<meta name=\"mobile-web-app-capable\" content=\"yes\">\n");										//tell mobile chrome this is a web app
		}
	}

//NOTE: it's important that the following load in a certain order!
add_cssFiles();
add_yuiFiles();
add_jsSrcAndFiles();
add_jsPageGlobals();

printf("	<script type=\"text/javascript\">\n");										//some basic core stuff
printf("		function doOnloadStuff(){");
printf("			if(typeof FavScreen === 'object') {FavScreen.log('verbose',\"doOnloadStuff(): Starting...\",true);} else {console.log('doOnloadStuff(): Starting...');}");
printf("			window.resizeTo(%d, %d);", main_favorites_window_width, main_favorites_window_height);		//since this was originally the login window, let's resize it to a more appropriate size for the favorites screen (defined in smcgi.c globals)
/*
if(httpUserAgentForLogin && 
	(  strstr(httpUserAgentForLogin, "iPad")	//example: Mozilla/5.0 (iPad; CPU OS 7_0_6 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11B651 Safari/9537.53
	|| strstr(httpUserAgentForLogin, "iPhone")
	|| strstr(httpUserAgentForLogin, "iPod")	//likely not needed, since iPod Touch seems to be caught by iPhone above, but can't hurt
	|| strstr(httpUserAgentForLogin, "Android") ))	//example: Mozilla/5.0 (Linux; Android 4.2.2; en-us; SAMSUNG SCH-I545 Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Version/1.0 Chrome/18.0.1025.308 Mobile Safari/535.19
	{
	printf("		if(window.innerWidth>window.innerHeight){");
	printf("			FavScreen.set('attrDeviceOrientation', ORIENTATION_LANDSCAPE);");
	printf("		}");
	printf("		else{");
	printf("			FavScreen.set('attrDeviceOrientation', ORIENTATION_PORTRAIT);");
	printf("			document.getElementById('logotext').style.display = \"none\";");			//remove the logotext from display
	printf("			document.getElementById('pagetitle').style.left = \"70px\";");
	printf("		}");
	printf("		setTimeout(function(){window.scrollTo(0,1);},500);");						//DEV-NOTE: detect older and use this only on older, as newer standards work instead
	printf("		document.documentElement.requestFullscreen();");						//DEV-NOTE: not sure whether this is really needed... doesn't seem to hurt anything having it here though
	}
*/
printf("			try {");
printf("				loadModeSpecificAssets();");
printf("			} catch(err) {");
printf("				console.warn('doOnloadStuff(): Problem calling loadModeSpecificAssets. FavScreen may not be initialized yet. Will try again in a few seconds.');");
printf("				setTimeout(function(){loadModeSpecificAssets();}, 3500);");				//IE BLOWS ~ this was calling before FavScreen was initialized, so this routine's tests (which depend on attributes) were failing, resulting in launch-mode stuff not working
printf("			}");

printf("			try {");
printf("				loadPanels();");
printf("			} catch(err) {");
printf("				console.warn('doOnloadStuff(): Problem calling loadPanels(). External dialogs JavaScript file may not be loaded yet. Will try again in a few seconds.');");
printf("				setTimeout(function(){loadPanels();}, 3500);");						//this was calling before favscreen.min.js was loaded <-- old note
printf("			}");

printf("			try {");
printf("				initializePanels();");
printf("			} catch(err) {");
printf("				console.warn('doOnloadStuff(): Problem calling initializePanels(). Panel classes may not be instantiated yet. Will try again in a few seconds.');");
printf("				setTimeout(function(){initializePanels();}, 3500);");					//this was calling before favscreen.min.js was loaded <-- old note
printf("			}");

printf("			try {");
printf("				var test_expectedNumberOfSectionsToBeLoaded = 3;");
printf("				var temp_result = loadSections();");
printf("				if(temp_result.int_sectionInstancesCreated < test_expectedNumberOfSectionsToBeLoaded && temp_result.int_sectionInstancesExist < test_expectedNumberOfSectionsToBeLoaded) {");
printf("					console.warn('doOnloadStuff(): Unexpected result ('+JSON.stringify(temp_result)+') from loadSections(). The expected number of sections ('+test_expectedNumberOfSectionsToBeLoaded+') was/is not instantiated. Trying one more time after 1s...');");
printf("					setTimeout(function(){loadSections();}, 1000);");
printf("				}");
printf("			} catch(err) {");
printf("				console.warn('doOnloadStuff(): Problem calling loadSections(). External favscreen JavaScript file may not be loaded yet. Will try again in a few seconds.');");
printf("				setTimeout(function(){loadSections();}, 3500);");					//this was calling before favscreen.min.js was loaded
printf("			}");

printf("			try {");
printf("				initializeSections();");
printf("			} catch(err) {");
printf("				console.warn('doOnloadStuff(): Problem calling initializeSections(). Major-section classes may not be instantiated yet. Will try again in a few seconds.');");
printf("				setTimeout(function(){initializeSections();}, 3500);");					//this was calling before favscreen.min.js was loaded
printf("			}");

printf("			try {");
printf("				renderSections();");
printf("			} catch(err) {");
printf("				console.warn('doOnloadStuff(): Problem calling renderSections(). Major-section classes may not be instantiated or initialized yet. Will try again in a few seconds.');");
printf("				setTimeout(function(){renderSections();}, 3500);");					//this was calling before favscreen.min.js was loaded
printf("			}");

printf("			if(typeof FavScreen === 'object') {FavScreen.log('verbose',\"doOnloadStuff(): Finished.\",true);} else {console.log('doOnloadStuff(): Finished.');}");
printf("		}\n");//end function doOnloadStuff
if(withFullSystem)														//if we need to also pop a window for the full-system, do so now...
	{
	DIAGNOSTIC_LOG_1("%s screen has been directed to pop a window with the full-system interface", FAVS_NAME_FULL);
	printf("	var withFullSystem = true;");										//indicate that we need to call the function that pops the window... which will be written by add_bodyLayoutContents()-->add_menu()... ultimately gets called once ClassFavScreen gets initialized
	}
printf("	</script>\n");
printf("</head>\n\n");

printf("<body class=\"yui3-skin-sam\" onLoad=\"doOnloadStuff();\">");								//apply the standard YUI CSS. Also, once the page is finished loading, run the logic that resizes the browser window.
printf("	<form action=\"%s\" method=\"post\" onSubmit=\"return HasFormBeenLoaded(1)\">", cgi_server);
add_bodyLayoutContents();
printf("	</form>");


printf("</body>\n\n");

printf("</html>");
}


/***********************************************************************
* static void construct_favorites_installApp(void)
*
*	This function creates the client document that intercepts 
*	login and provides a screen from which to install the mobile app.
*
***********************************************************************/
void construct_favorites_installApp(void)
{
char *httpUserAgentForLogin = getenv("HTTP_USER_AGENT");        /* use this here instead of cgi_detect_browser() because we want more detailed info than just the few it offers */

printf("<!DOCTYPE html>");	//HTML-5 doctype
printf("<html>");

printf("<head>");
add_CopyRight(NULL, TRUE);
printf("	<title>%s %s</title>\n", cgi_product_name, FAVS_NAME_FULL);
if(httpUserAgentForLogin && 
	(  strstr(httpUserAgentForLogin, "iPad")	//example: Mozilla/5.0 (iPad; CPU OS 7_0_6 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11B651 Safari/9537.53
	|| strstr(httpUserAgentForLogin, "iPhone")
	|| strstr(httpUserAgentForLogin, "iPod") ))	//likely not needed, since iPod Touch seems to be caught by iPhone above, but can't hurt
	{
	printf("<meta name=\"viewport\" content=\"initial-scale=1, user-scalable=no, width=device-width, minimum-scale=1\">");			//ensures that page elements aren't rendered too small on high pixel density devices (DEV-NOTE: this might need extensive testing across platforms)
	printf("<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">");									//tell mobile safari this is a web app
	}
else if(httpUserAgentForLogin &&
	strstr(httpUserAgentForLogin, "Android") )	//example: Mozilla/5.0 (Linux; Android 4.2.2; en-us; SAMSUNG SCH-I545 Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Version/1.0 Chrome/18.0.1025.308 Mobile Safari/535.19
	{
	if( strstr(httpUserAgentForLogin, "Chrome") )
		{
		printf("<meta name=\"viewport\" content=\"initial-scale=1.0, target-densityDpi=device-dpi, width=device-width, height=device-height, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n");//ensures that page elements aren't rendered too small on high pixel density devices (DEV-NOTE: this might need extensive testing across platforms)
		printf("<meta name=\"mobile-web-app-capable\" content=\"yes\">\n");										//tell mobile chrome this is a web app
		}
	}

if(httpUserAgentForLogin && 
	(  strstr(httpUserAgentForLogin, "iPad")	//example: Mozilla/5.0 (iPad; CPU OS 7_0_6 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11B651 Safari/9537.53
	|| strstr(httpUserAgentForLogin, "iPhone")
	|| strstr(httpUserAgentForLogin, "iPod") ))	//likely not needed, since iPod Touch seems to be caught by iPhone above, but can't hurt
	{
	char app_argument[50];															//prepare an app-argument string (initialize here, so we don't use the stack unnecessarily)
	char user_pin[PIN_LENGTH];														//declare a local copy of user pin we can work with
	char app_arg_userPin[8+(PIN_LENGTH*3)];													//example: "userpin=USER%20PIN"   non-valid characters may be encoded with "%XX" syntax - 3 characters for each one - hence multiplication

	//build the name-value pair for user pin...
	strcpyl(user_pin, CurrentUserPin, sizeof(user_pin));											//first, get the full current user pin (with trailing spaces)
	remove_trailing_space(user_pin);													//strip the trailing spaces, as we don't want them in the app-argument string
	snprintf(app_arg_userPin, sizeof(app_arg_userPin), "userpin=%s", url_encode(user_pin));							//replace invalid chars with valid URL-encoded chars

	//build the entire complete app-argument string...
	snprintf(app_argument, sizeof(app_argument), "%s", cgi_base);
	//snprintf(app_argument, sizeof(app_argument), "?%s", cgi_base, server_ip, app_arg_userPin);
	remove_trailing_space(app_argument);
	//DIAGNOSTIC_LOG_1("TEST app-arg = '%s'", app_argument);

	printf("<meta name=\"apple-itunes-app\" content=\"app-id=%s, app-argument=%s\">", FAVS_APPLE_APPSTORE_ID, app_argument);		//prepare Apple App-Store smart banner
	}
if(httpUserAgentForLogin 
	&& strstr(httpUserAgentForLogin, "Android"))	//example: Mozilla/5.0 (Linux; Android 4.2.2; en-us; SAMSUNG SCH-I545 Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Version/1.0 Chrome/18.0.1025.308 Mobile Safari/535.19
	{
	//code for google play store?
	}
add_cssFiles();
printf("	<script type=\"text/javascript\">");
printf("	function doOnloadStuff(){");
printf("	}");//end doOnloadStuff
printf("	</script>");
printf("</head>");

printf("<body class=\"yui3-skin-sam\" id=\"smartbanner\" style=\"background:%s url('%s/smlogo_icontrans.png') no-repeat 150px 0px;\" onLoad=\"doOnloadStuff();\">", main_bgcolor, cgi_icons);//apply the standard YUI CSS. Also, once the page is finished loading, run the logic that resizes the browser window.
printf("	<form action=\"%s\" method=\"post\" onSubmit=\"return HasFormBeenLoaded(1)\">", cgi_server);
printf("		<div style=\"text-align:center\">");
//printf("			<h3>MessageNet<br>%s</h3>", FAVS_NAME_FULL);
printf("			<h3>To get the app<br>tap OPEN above</h3>");
printf("			<h3>or</h3>");
//printf("			<h3 class=\"applesmartbannerlinkblue\">Tap OPEN Above</h3>");
//printf("			<div id=\"browserloginoption\">");
printf("				<input type=\"hidden\" name=\"generateFavoriteScreen\" value=\"%d\"></input>", TRUE);						//flag for smcgi to load favs main
printf("				<input type=\"hidden\" name=\"%s\" value=\"%s\"></input>", cgi_identification_field, cgi_EncodeLoginPin(CurrentUserPin));	//smcgi requires authentication (use this since we should've already logged in - we come here from the login post-process)
printf("				<input type=\"submit\" name=\"submit\" value=\"Finish Login\" style=\"font-size:1em;\"></input>");
//printf("			</div>");
printf("		</div>");
printf("	</form>");
printf("</body>");

printf("</html>");
}


/***********************************************************************
* static void construct_favorites_noLoginAvailable(void)
*
*	This function creates the client document that provides the user 
*	with at least some kind of screen if their mobile app is decommissioned.
*
***********************************************************************/
void construct_favorites_noLoginAvailable(void)
{
char *httpUserAgentForLogin = getenv("HTTP_USER_AGENT");        /* use this here instead of cgi_detect_browser() because we want more detailed info than just the few it offers */

printf("<!DOCTYPE html>");	//HTML-5 doctype
printf("<html>");

printf("<head>");
add_CopyRight(NULL, TRUE);
printf("	<title>%s %s</title>\n", cgi_product_name, FAVS_NAME_FULL);
if(httpUserAgentForLogin && 
	(  strstr(httpUserAgentForLogin, "iPad")	//example: Mozilla/5.0 (iPad; CPU OS 7_0_6 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11B651 Safari/9537.53
	|| strstr(httpUserAgentForLogin, "iPhone")
	|| strstr(httpUserAgentForLogin, "iPod") ))	//likely not needed, since iPod Touch seems to be caught by iPhone above, but can't hurt
	{
	printf("<meta name=\"viewport\" content=\"initial-scale=1, user-scalable=no, width=device-width, minimum-scale=1\">");			//ensures that page elements aren't rendered too small on high pixel density devices (DEV-NOTE: this might need extensive testing across platforms)
	printf("<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">");									//tell mobile safari this is a web app
	}
else if(httpUserAgentForLogin &&
	strstr(httpUserAgentForLogin, "Android") )	//example: Mozilla/5.0 (Linux; Android 4.2.2; en-us; SAMSUNG SCH-I545 Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Version/1.0 Chrome/18.0.1025.308 Mobile Safari/535.19
	{
	if( strstr(httpUserAgentForLogin, "Chrome") )
		{
		printf("<meta name=\"viewport\" content=\"initial-scale=1.0, target-densityDpi=device-dpi, width=device-width, height=device-height, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n");//ensures that page elements aren't rendered too small on high pixel density devices (DEV-NOTE: this might need extensive testing across platforms)
		printf("<meta name=\"mobile-web-app-capable\" content=\"yes\">\n");										//tell mobile chrome this is a web app
		}
	}
add_cssFiles();
printf("	<script type=\"text/javascript\">");
printf("	function doOnloadStuff(){");
printf("	}");//end doOnloadStuff
printf("	</script>");
printf("</head>");

printf("<body class=\"yui3-skin-sam\" id=\"nologinavailable\" style=\"background:%s url('%s/smlogo_icontrans.png') no-repeat 150px 0px;\" onLoad=\"doOnloadStuff();\">", main_bgcolor, cgi_icons);//apply the standard YUI CSS. Also, once the page is finished loading, run the logic that resizes the browser window.
printf("	<form action=\"%s\" method=\"post\" onSubmit=\"return HasFormBeenLoaded(1)\">", cgi_server);
printf("		<div style=\"text-align:center\">");
printf("			<h2>MessageNet<br>%s</h2>", FAVS_NAME_FULL);
printf("			<h2>Service Deactivated</h2>");
printf("			<h3>Contact Support to Reactivate</h3>");
printf("		</div>");
printf("	</form>");
printf("</body>");

printf("</html>");
}
